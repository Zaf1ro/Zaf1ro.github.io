<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="MST (Minimum Spanning Tree)"/>




  <meta name="keywords" content="Algorithm," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/afab.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/afab.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/afab.html"/>


<meta name="description" content="1135. Connecting Cities With Minimum CostThere are n cities labeled from 1 to n. You are given the integer n and an array connections where $connections[i] &#x3D; [x_i, y_i, &amp;#123;cost&amp;#125;_i]$ indicates">
<meta property="og:type" content="article">
<meta property="og:title" content="MST (Minimum Spanning Tree)">
<meta property="og:url" content="https://zaf1ro.github.io/p/afab.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1135. Connecting Cities With Minimum CostThere are n cities labeled from 1 to n. You are given the integer n and an array connections where $connections[i] &#x3D; [x_i, y_i, &amp;#123;cost&amp;#125;_i]$ indicates">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/Kruskal.gif">
<meta property="article:published_time" content="2023-03-07T20:59:33.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.026Z">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/Algorithm/Kruskal.gif">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
MST (Minimum Spanning Tree) - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1135-Connecting-Cities-With-Minimum-Cost"><span class="toc-text">1135. Connecting Cities With Minimum Cost</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Prim%E2%80%99s-Algorithm"><span class="toc-text">1. Prim’s Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Kruskal-s-algorithm"><span class="toc-text">2. Kruskal&#39;s algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1584-Min-Cost-to-Connect-All-Points"><span class="toc-text">1584. Min Cost to Connect All Points</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Kruskal-s-algorithm"><span class="toc-text">1. Kruskal&#39;s algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Prim%E2%80%99s-Algorithm"><span class="toc-text">2. Prim’s Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree"><span class="toc-text">1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal-s-algorithm"><span class="toc-text">Kruskal&#39;s algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1168-Optimize-Water-Distribution-in-a-Village"><span class="toc-text">1168. Optimize Water Distribution in a Village</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal-s-algorithm-1"><span class="toc-text">Kruskal&#39;s algorithm</span></a></li></ol></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          MST (Minimum Spanning Tree)
        
      </h1>
      <time class="post-time">
          03/07/23
      </time>
    </header>

    <div class="post-content">
      <h2 id="1135-Connecting-Cities-With-Minimum-Cost"><a href="#1135-Connecting-Cities-With-Minimum-Cost" class="headerlink" title="1135. Connecting Cities With Minimum Cost"></a>1135. Connecting Cities With Minimum Cost</h2><p>There are <code>n</code> cities labeled from <code>1</code> to <code>n</code>. You are given the integer <code>n</code> and an array <code>connections</code> where <code>$connections[i] = [x_i, y_i, &#123;cost&#125;_i]$</code> indicates that the cost of connecting city <code>$x_i$</code> and city <code>$y_i$</code> (bidirectional connection) is <code>$&#123;cost&#125;_i$</code>.</p>
<p>Return the minimum <strong>cost</strong> to connect all the <code>n</code> cities such that there is at least one path between each pair of cities. If it is impossible to connect all the <code>n</code> cities, return <code>-1</code>,</p>
<p>The cost is the sum of the connections&#39; costs used.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 4, connections = [[1,2,3],[3,4,4]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: There is no way to connect all cities even if all edges are used.</span><br></pre></td></tr></table></figure>

<h3 id="1-Prim’s-Algorithm"><a href="#1-Prim’s-Algorithm" class="headerlink" title="1. Prim’s Algorithm"></a>1. Prim’s Algorithm</h3><p>Prim算法步骤如下:</p>
<ol>
<li>随机挑选一个vertex作为起点</li>
<li>将该vertex连接的所有edge放入最小堆(min heap)</li>
<li>若最小堆中仍有edge, 则一直执行以下步骤<ol>
<li>从最小堆中取出权重最小的edge</li>
<li>查看该edge连接的vertex是否已被访问, 若之前访问过, 则重复上一步骤; 若vertex未被访问过:<ol>
<li>记录该vertex, 防止重复访问</li>
<li>记录edge的权重</li>
<li>将该vertex连接的所有edge放入最小堆</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>由于tree不允许存在任何circle, 因此Prim需要记录每次访问的vertex, 避免形成circle. Prim算法的前提是无向图(Undirected graph), 不适用于有向图(Directed graph). 该算法的时间复杂度为$O(e\log{e})$(e为edge数).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(Edge e)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.edges.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.from = from;</span><br><span class="line">            <span class="built_in">this</span>.to = to;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> <span class="title class_">Node</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] conn: connections) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> conn[<span class="number">0</span>], n2 = conn[<span class="number">1</span>], w = conn[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (nodes[n1] == <span class="literal">null</span>) nodes[n1] = <span class="keyword">new</span> <span class="title class_">Node</span>(n1);</span><br><span class="line">            <span class="keyword">if</span> (nodes[n2] == <span class="literal">null</span>) nodes[n2] = <span class="keyword">new</span> <span class="title class_">Node</span>(n2);</span><br><span class="line">            nodes[n1].addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>(n1, n2, w));</span><br><span class="line">            nodes[n2].addEdge(<span class="keyword">new</span> <span class="title class_">Edge</span>(n2, n1, w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.weight-b.weight);</span><br><span class="line">        <span class="comment">// Find all edges connecting to the node</span></span><br><span class="line">        <span class="keyword">for</span> (Edge e: nodes[<span class="number">1</span>].edges) &#123;</span><br><span class="line">            pq.offer(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> pq.poll(); <span class="comment">// Find the minimum among these edges</span></span><br><span class="line">            <span class="keyword">if</span> (visited[edge.to]) <span class="keyword">continue</span>; <span class="comment">// Add the chosen edge to MST if it does not form any cycle</span></span><br><span class="line">            visited[edge.to] = <span class="literal">true</span>;</span><br><span class="line">            res += edge.weight;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (Edge e: nodes[edge.to].edges) &#123;</span><br><span class="line">                pq.offer(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == n ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Kruskal-s-algorithm"><a href="#2-Kruskal-s-algorithm" class="headerlink" title="2. Kruskal&#39;s algorithm"></a>2. Kruskal&#39;s algorithm</h3><p>Kruskal算法同样只适用于无向图, 算法思路如下:</p>
<ol>
<li>对graph中所有的edge按照权重从小到大排序</li>
<li>假设graph中的每个vertex都是一个独立的tree, 从排序后的edge集合中不断取出最小值:</li>
<li>若取出的edge不会构成circle, 则将该edge加入结果, 并将edge两边的vertex连接为一颗tree</li>
<li>若取出的edge构成circle, 则忽略该edge</li>
</ol>
<p><img src="/images/Algorithm/Kruskal.gif" alt="Kruskal&#39;s algorithm on a complete graph with weights based on Euclidean distance"></p>
<p>该算法的时间复杂度为$O(e\log{e})$(e为edge数).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>], ranks = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(connections, (a,b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] conn: connections) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> find(parents, conn[<span class="number">0</span>]), p2 = find(parents, conn[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">continue</span>;</span><br><span class="line">            res += conn[<span class="number">2</span>];</span><br><span class="line">            count++;</span><br><span class="line">            union(parents, ranks, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == n ? res : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == i) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> find(parents, parents[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span>[] ranks, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[i] &lt; ranks[j]) &#123;</span><br><span class="line">            parents[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ranks[i] &gt; ranks[j]) &#123;</span><br><span class="line">            parents[j] = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ranks[i]++;</span><br><span class="line">            parents[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1584-Min-Cost-to-Connect-All-Points"><a href="#1584-Min-Cost-to-Connect-All-Points" class="headerlink" title="1584. Min Cost to Connect All Points"></a>1584. Min Cost to Connect All Points</h2><p>You are given an array <code>points</code> representing integer coordinates of some points on a 2D-plane, where <code>points[i] = [$x_i$, $y_i$]</code>.</p>
<p>The cost of connecting two points <code>$[x_i, y_i]$</code> and <code>$[x_j, y_j]$</code> is the manhattan distance between them: <code>$|x_i - x_j| + |y_i - y_j|$</code>, where <code>|val|</code> denotes the absolute value of val.</p>
<p>Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">Output: 20</span><br></pre></td></tr></table></figure>

<h3 id="1-Kruskal-s-algorithm"><a href="#1-Kruskal-s-algorithm" class="headerlink" title="1. Kruskal&#39;s algorithm"></a>1. Kruskal&#39;s algorithm</h3><p>与上一题相同, 该题可使用Kruskal寻找最小生成树, 该算法的时间复杂度为<code>$O(e\log(e))$</code>(e为edge数, n为vertex数, 则$e &#x3D; n^2$)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="type">int</span>[][] edges = <span class="keyword">new</span> <span class="title class_">int</span>[n*n][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, k = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                edges[k][<span class="number">0</span>] = i;</span><br><span class="line">                edges[k][<span class="number">1</span>] = j;</span><br><span class="line">                edges[k++][<span class="number">2</span>] = Math.abs(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + Math.abs(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges, (a, b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[n], ranks = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> find(parents, edge[<span class="number">0</span>]), p2 = find(parents, edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">continue</span>;</span><br><span class="line">            res += edge[<span class="number">2</span>];</span><br><span class="line">            union(parents, ranks, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == i) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> find(parents, parents[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span>[] ranks, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[i] &lt;= ranks[j]) &#123;</span><br><span class="line">            parents[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (ranks[i] == ranks[j]) ranks[j]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Prim’s-Algorithm"><a href="#2-Prim’s-Algorithm" class="headerlink" title="2. Prim’s Algorithm"></a>2. Prim’s Algorithm</h3><p>思路与上一题相同, 算法时间复杂度为<code>$O(n^2)$</code>(n为vertex数), 但由于该题每两个点组成一条边, 因此edge数远超vertex数, 导致Kruskal算法的耗时更长, 总结:</p>
<ul>
<li>Prim算法适合点与点连接稠密的图</li>
<li>Kruskal算法适合点与点连接稀疏的图</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length, res = <span class="number">0</span>, count = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (count++ &lt; n) &#123;</span><br><span class="line">            <span class="comment">// calculate manhattan distance</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[j]) <span class="keyword">continue</span>;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;j, Math.abs(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + Math.abs(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>])&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (visited[pq.peek()[<span class="number">0</span>]]) pq.poll();</span><br><span class="line">            <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">            visited[p[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">            res += p[<span class="number">1</span>];</span><br><span class="line">            i = p[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree"><a href="#1489-Find-Critical-and-Pseudo-Critical-Edges-in-Minimum-Spanning-Tree" class="headerlink" title="1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree"></a>1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree</h2><p>Given a weighted undirected connected graph with <code>n</code> vertexs numbered from <code>0</code> to <code>n - 1</code>, and an array edges where <code>edges[i] = [$a_i$, $b_i$, $\text&#123;weight&#125;_i$]</code> represents a bidirectional and weighted edge between nodes <code>$a_i$</code> and <code>$b_i$</code>. A minimum spanning tree (MST) is a subset of the graph&#39;s edges that connects all vertexs without cycles and with the minimum possible total edge weight.</p>
<p>Find all the critical and pseudo-critical edges in the given graph&#39;s minimum spanning tree (MST). An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge. On the other hand, a pseudo-critical edge is that which can appear in some MSTs but not all.</p>
<h3 id="Kruskal-s-algorithm"><a href="#Kruskal-s-algorithm" class="headerlink" title="Kruskal&#39;s algorithm"></a>Kruskal&#39;s algorithm</h3><p>按照题目的描述, graph的edge分为三类:</p>
<ul>
<li>critial edge: 组成MST的必要边, 若去掉该edge, 会导致MST的weight变化</li>
<li>pesudo-critial edge: 组成MST的可选边, 该边可被其他权重的路径替代, 因此剔除该边也不会影响MST的weight</li>
<li>other edge: 不能作为MST的边</li>
</ul>
<p>该解法的步骤如下:</p>
<ol>
<li>通过Kruskal计算MST的最小总权重值</li>
<li>遍历所有edge, 计算排除该edge的情况下MST的总权重值, 若不相同, 则说明该边对于MST不可或缺, 也就是critical edge</li>
<li>再次遍历所有edge, 跳过critical edge, 计算MST的总权重值前先加入该边:</li>
</ol>
<ul>
<li>若MST的总权重值与最小总权重值相同: 说明该边不是other edge, 也就是pesudo-critical edge</li>
<li>若不同: 说明该边是other edge</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">isSkip</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.from = from;</span><br><span class="line">            <span class="built_in">this</span>.to = to;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findCriticalAndPseudoCriticalEdges</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] e)</span> &#123;</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> <span class="title class_">Edge</span>[e.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e.length; i++) &#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> <span class="title class_">Edge</span>(e[i][<span class="number">0</span>], e[i][<span class="number">1</span>], e[i][<span class="number">2</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges, (a,b)-&gt;a.weight-b.weight);</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> findMstWeight(Arrays.copyOf(parents, n), <span class="keyword">new</span> <span class="title class_">int</span>[n], edges);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge: edges) &#123;</span><br><span class="line">            edge.isSkip = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (min != findMstWeight(Arrays.copyOf(parents, n), <span class="keyword">new</span> <span class="title class_">int</span>[n], edges)) &#123;</span><br><span class="line">                res.get(<span class="number">0</span>).add(edge.index);</span><br><span class="line">            &#125;</span><br><span class="line">            edge.isSkip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.get(<span class="number">0</span>).contains(edge.index)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span>[] p = Arrays.copyOf(parents, n), r = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            p[edge.from] = edge.to;</span><br><span class="line">            r[edge.to]++;</span><br><span class="line">            <span class="keyword">if</span> (min == findMstWeight(p, r, edges) + edge.weight) &#123;</span><br><span class="line">                res.get(<span class="number">1</span>).add(edge.index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMstWeight</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span>[] ranks, Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e: edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isSkip) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> find(parents, e.from), p2 = find(parents, e.to);</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">continue</span>;</span><br><span class="line">            res += e.weight;</span><br><span class="line">            union(parents, ranks, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == i) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> find(parents, parents[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span>[] ranks, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[i] &lt;= ranks[j]) &#123;</span><br><span class="line">            parents[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (ranks[i] == ranks[j]) ranks[j]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="1168-Optimize-Water-Distribution-in-a-Village"><a href="#1168-Optimize-Water-Distribution-in-a-Village" class="headerlink" title="1168. Optimize Water Distribution in a Village"></a>1168. Optimize Water Distribution in a Village</h2><p>There are <code>n</code> houses in a village. We want to supply water for all the houses by building wells and laying pipes.</p>
<p>For each house <code>i</code>, we can either build a well inside it directly with cost <code>wells[i - 1]</code> (note the -1 due to 0-indexing), or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes where each <code>pipes[j] = [$\text&#123;house1&#125;_j$, $\text&#123;house2&#125;_j$, $\text&#123;cost&#125;_j$]</code> represents the cost to connect <code>$\text&#123;house1&#125;_j$</code> and <code>$\text&#123;house2&#125;_j$</code> together using a pipe. Connections are bidirectional, and there could be multiple valid connections between the same two houses with different costs.</p>
<p>Return the minimum total cost to supply water to all houses.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The image shows the costs of connecting houses using pipes.</span><br><span class="line">The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.</span><br></pre></td></tr></table></figure>

<h3 id="Kruskal-s-algorithm-1"><a href="#Kruskal-s-algorithm-1" class="headerlink" title="Kruskal&#39;s algorithm"></a>Kruskal&#39;s algorithm</h3><p>该题并不要求每个vertex连通, 因此看起来与MST无关; 但换一种思路, 假设不允许挖井, house只能从一个水库取水, 一个house连接到水库的pipe成本等同于自己挖井的成本, 那么整个图只存在edge的权重值, 不存在vertex的权重值, 使用Kruskal构成的MST包含两类vertex:</p>
<ul>
<li>直接与水库相连的house</li>
<li>与其他house建立pipe的house, 换句话说, 该house与水库间接相连</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostToSupplyWater</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] wells, <span class="type">int</span>[][] pipes)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] pipe: pipes) &#123; <span class="comment">// cost of pipe to other house</span></span><br><span class="line">            edges.add(pipe);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// cost of pipe to the reservoir</span></span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i+<span class="number">1</span>, wells[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Kruskal&#x27;s algorithm</span></span><br><span class="line">        Collections.sort(edges, (a,b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span>[] parents = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>], ranks = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] e: edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> find(parents, e[<span class="number">0</span>]), p2 = find(parents, e[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (p1 == p2) <span class="keyword">continue</span>;</span><br><span class="line">            res += e[<span class="number">2</span>];</span><br><span class="line">            union(parents, ranks, p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parents[i] == i) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> find(parents, parents[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parents, <span class="type">int</span>[] ranks, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ranks[i] &lt;= ranks[j]) &#123;</span><br><span class="line">            parents[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (ranks[i] == ranks[j]) ranks[j]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parents[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Algorithm/">Algorithm</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/c8ae.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">Shortest Path in Graph</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/9bcb.html">
        <span class="next-text nav-default">BFS for Graph</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/afab.html';
  var disqus_title = "MST (Minimum Spanning Tree)";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
