<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="StatefulSet"/>




  <meta name="keywords" content="K8s," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/c933.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/c933.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/c933.html"/>


<meta name="description" content="Introduction无论是ReplicaSet或Deployment, 其只能创建和管理stateless pod, 以下是stateless pod和stateful pod的区别:    Feature Stateless Pod Stateful Pod    State Management 不创建或依赖任何persistent state 每个pod都有自己的persistent s">
<meta property="og:type" content="article">
<meta property="og:title" content="StatefulSet">
<meta property="og:url" content="https://zaf1ro.github.io/p/c933.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="Introduction无论是ReplicaSet或Deployment, 其只能创建和管理stateless pod, 以下是stateless pod和stateful pod的区别:    Feature Stateless Pod Stateful Pod    State Management 不创建或依赖任何persistent state 每个pod都有自己的persistent s">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-1-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-1-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-1-3.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-1-4.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-2-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-2-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-2-3.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-2-4.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-2-5.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-3-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-3-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-4-1.png">
<meta property="article:published_time" content="2019-11-07T18:43:55.000Z">
<meta property="article:modified_time" content="2025-05-01T20:01:57.870Z">
<meta property="article:tag" content="K8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/Kubernetes/statefulset-1-1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
StatefulSet - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Replicating-Stateful-Pods"><span class="toc-text">1. Replicating Stateful Pods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Run-Multiple-Replicas-with-Separate-Storage"><span class="toc-text">1.1 Run Multiple Replicas with Separate Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Provide-a-Stable-Identity-for-Each-Pod"><span class="toc-text">1.2 Provide a Stable Identity for Each Pod</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-StatefulSet"><span class="toc-text">2. StatefulSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Provide-a-Stable-Network-Identity"><span class="toc-text">2.1 Provide a Stable Network Identity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Provide-Stable-Dedicated-Storage"><span class="toc-text">2.2 Provide Stable Dedicated Storage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-StatefulSet-s-At-Most-One-Semantics"><span class="toc-text">2.3 StatefulSet&#39;s At-Most-One Semantics</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Use-a-StatefulSet"><span class="toc-text">3. Use a StatefulSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Create-the-App-and-Container-image"><span class="toc-text">3.1 Create the App and Container image</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Deploy-the-App-through-a-StatefulSet"><span class="toc-text">3.2 Deploy the App through a StatefulSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-Create-the-Persistent-Volume"><span class="toc-text">3.2.1 Create the Persistent Volume</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-Creating-the-Governing-Service"><span class="toc-text">3.2.2 Creating the Governing Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-Creating-the-StatefulSet-Manifest"><span class="toc-text">3.2.3 Creating the StatefulSet Manifest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-Create-the-StatefulSet"><span class="toc-text">3.2.4 Create the StatefulSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-Examine-the-Generated-Stateful-Pod"><span class="toc-text">3.2.5 Examine the Generated Stateful Pod</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Communicate-with-Your-Pods"><span class="toc-text">3.3 Communicate with Your Pods</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Discovering-peers-in-a-StatefulSet"><span class="toc-text">4. Discovering peers in a StatefulSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Implement-peer-discovery-through-DNS"><span class="toc-text">4.1 Implement peer discovery through DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Update-a-StatefulSet"><span class="toc-text">4.2 Update a StatefulSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Understand-How-StatefulSets-Deal-with-Node-Failures"><span class="toc-text">5. Understand How StatefulSets Deal with Node Failures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Simulate-a-Node-s-Disconnection-From-the-Network"><span class="toc-text">5.1 Simulate a Node&#39;s Disconnection From the Network</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Delete-the-Pod-Forcibly"><span class="toc-text">5.2 Delete the Pod Forcibly</span></a></li></ol></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          StatefulSet
        
      </h1>
      <time class="post-time">
          11/07/19
      </time>
    </header>

    <div class="post-content">
      <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>无论是ReplicaSet或Deployment, 其只能创建和管理stateless pod, 以下是stateless pod和stateful pod的区别:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Stateless Pod</th>
<th>Stateful Pod</th>
</tr>
</thead>
<tbody><tr>
<td>State Management</td>
<td>不创建或依赖任何persistent state</td>
<td>每个pod都有自己的persistent state</td>
</tr>
<tr>
<td>Interchangeability</td>
<td>pod间可互相替换</td>
<td>pod无法互相替换</td>
</tr>
<tr>
<td>Deployment Controller</td>
<td>Deployment或ReplicaSet</td>
<td>StatefulSet</td>
</tr>
<tr>
<td>Storage</td>
<td>所有pod共享同一PV</td>
<td>每个pod拥有自己的PV</td>
</tr>
<tr>
<td>Scalability</td>
<td>可任意水平拓展</td>
<td>无法随意水平拓展</td>
</tr>
<tr>
<td>Fault Tolerance</td>
<td>损失一个pod不会影响其他pod</td>
<td>随时任意pod都会影响数据完整性</td>
</tr>
</tbody></table>
<p>对于计算密集型事务, 由于单个node&#x2F;pod无法处理所有请求, 可借助stateless pod的水平拓展能力解决计算瓶颈; 但对于数据密集型事务, 由于数据量巨大而无法将所有数据放入一个pod&#x2F;node中, 需将全部数据分散到多个node&#x2F;pod中, 例如:</p>
<ul>
<li>Database: MySQL, Oracle, PostgreSQL, Cassandra, Elasticsearch等</li>
<li>Distributed File System: GlusterFS, Ceph等</li>
<li>Message Broker: Kafka, RabbitMQ</li>
<li>Session data store: 很多应用依赖session追踪用户</li>
<li>IoT system: 负责存储手机IoT设备获取的数据</li>
</ul>
<h2 id="1-Replicating-Stateful-Pods"><a href="#1-Replicating-Stateful-Pods" class="headerlink" title="1. Replicating Stateful Pods"></a>1. Replicating Stateful Pods</h2><p>ReplicaSet会从一个pod template创建多个pod, 若pod template中包含一个PVC, 则所有pod都共享该PVC对应的PV:<br><img src="/images/Kubernetes/statefulset-1-1.png" alt="All pods from the same ReplicaSet always use the same PersistentVolumeClaim and PersistentVolume"></p>
<h3 id="1-1-Run-Multiple-Replicas-with-Separate-Storage"><a href="#1-1-Run-Multiple-Replicas-with-Separate-Storage" class="headerlink" title="1.1 Run Multiple Replicas with Separate Storage"></a>1.1 Run Multiple Replicas with Separate Storage</h3><p>如果想让每个pod使用各自volume, 可采取以下方式:</p>
<ul>
<li>手动创建pod: 手动创建多个pod, 并让每个pod使用不同的PVC. 由于未使用ReplicaSet, 需要手动管理pod: pod不可用时需手动删除并重新创建pod.</li>
<li>一个pod对应一个ReplicaSet: 创造多个ReplicaSet, 每个ReplicaSet只管理一个pod, 并使用不同PVC. 虽然ReplicaSet会自动管理pod, 但需要额外创建多个ReplicaSet; 且无法随意修改pod数量: 增加或减少pod数量时, 需手动创建或删除ReplicaSet.<br><img src="/images/Kubernetes/statefulset-1-2.png" alt="Using one ReplicaSet for each pod instance"></li>
<li>在同一volume中使用不同文件路径: 一个ReplicaSet管理多个pod, 但每个pod访问不同文件目录, 从而实现数据分布式. 但由于无法给每个pod指定不同的文件目录, 需要pod自己检查文件目录是否被其他pod使用, 因此需要某种pod间的合作机制:<br><img src="/images/Kubernetes/statefulset-1-3.png" alt="Working around the shared storage problem by having the app in each pod use a different file directory"></li>
</ul>
<h3 id="1-2-Provide-a-Stable-Identity-for-Each-Pod"><a href="#1-2-Provide-a-Stable-Identity-for-Each-Pod" class="headerlink" title="1.2 Provide a Stable Identity for Each Pod"></a>1.2 Provide a Stable Identity for Each Pod</h3><p>当pod不可用时, ReplicaSet会替换新的pod, 这就导致一个问题: 由于每个pod拥有各自数据, 其他pod无法提供不可用pod的数据, 当新的pod替换不可用pod时, 我们无法获知新pod的地址, 因此需要让每个pod都有一个稳定的<strong>网络身份</strong>(固定IP地址或域名). 这与ReplicaSet为新创建pod随机分配一个hostname或IP地址相冲突, 最容易想到的解决方案: 为每个pod创建对应的service.<br><img src="/images/Kubernetes/statefulset-1-4.png" alt="Using one Service and ReplicaSet per pod to provide a stable network address"></p>
<h2 id="2-StatefulSet"><a href="#2-StatefulSet" class="headerlink" title="2. StatefulSet"></a>2. StatefulSet</h2><p>StatefulSet作为k8s的一种资源, 提供了一种管理stateful pod的解决方案. 以下是StatefulSet和ReplicaSet&#x2F;Deployment的区别:</p>
<ul>
<li>Goals: ReplicaSet负责管理non-stateful application; StatefulSet负责管理stateful application </li>
<li>Identity: ReplicaSet为pod随机分配名字和hostname; StatefulSet按顺序为pod分配名字和hostname</li>
<li>Volume: ReplicaSet中的所有pod绑定PVC对应的PV; StatefulSet中的pod拥有各自PV</li>
</ul>
<h3 id="2-1-Provide-a-Stable-Network-Identity"><a href="#2-1-Provide-a-Stable-Network-Identity" class="headerlink" title="2.1 Provide a Stable Network Identity"></a>2.1 Provide a Stable Network Identity</h3><p>StatefulSet中所有pod名字都会以递增整数作为结尾(以0为起点), 因此pod的域名可预测; ReplicaSet则会为pod添加随机后缀:<br><img src="/images/Kubernetes/statefulset-2-1.png" alt="Pods created by a StatefulSet have predictable hostnames"></p>
<p>StatefulSet需要<strong>headless service</strong>, 从而让每个pod都有自己的DNS记录, 其他服务可通过DNS记录访问对应pod. 假设<code>default</code> namespace中的service名为<code>foo</code>, 第一个pod的名字为<code>A-0</code>, 则该pod的域名为<code>a-0.foo.default.svc.cluster.local</code>; 除此之外, 还可通过SRV记录访问所有pod, 其域名为<code>foo.default.svc.cluster.local</code>.<br>当pod所在的node不可用时, StatefulSet会在其他node上创建该pod, 且保证新创建的pod的名字和hostname与之前pod相同; ReplicaSet则会重新分配pod的名字和hostname:<br><img src="/images/Kubernetes/statefulset-2-2.png" alt="StatefulSet replaces a lost pod with a new one with the same identity"></p>
<p>增加StatefulSet的replica count时, StatefulSet会创建一个新的pod, 其名字为下一个未使用的索引; 减小StatefulSet的replica count时, 会按照索引大小倒序移除pod, 且一次只移除一个pod:<br><img src="/images/Kubernetes/statefulset-2-3.png" alt="Scaling down a StatefulSet always removes the pod with the highest ordinal index first"></p>
<h3 id="2-2-Provide-Stable-Dedicated-Storage"><a href="#2-2-Provide-Stable-Dedicated-Storage" class="headerlink" title="2.2 Provide Stable Dedicated Storage"></a>2.2 Provide Stable Dedicated Storage</h3><p>当一个pod因不可用而创建新的pod时, StatefulSet需保证新创建的pod依然绑定之前pod对应的volume, 由于PVC与PV一一对应, 因此StatefulSet只需保证pod与PVC一一对应即可, PVC负责管理对应的PV:<br><img src="/images/Kubernetes/statefulset-2-4.png" alt="A StatefulSet creates both pods and PersistentVolumeClaims"></p>
<p>因此, 增加replica count时, StatefulSet会创建两个API对象: pod与对应的PVC; 减小replica count时, StatefulSet只会移除pod, 不会删除对应的PVC, 因为一旦删除PVC, 其对应的PV也会被回收, 为了防止数据丢失需保留PVC; 也可手动删除PVC来回收PV; 当replica count恢复到之前数量时, 新创建的pod会绑定原有PVC:<br><img src="/images/Kubernetes/statefulset-2-5.png" alt="StatefulSets preserve the PersistentVolumeClaims when scaling down"></p>
<h3 id="2-3-StatefulSet-s-At-Most-One-Semantics"><a href="#2-3-StatefulSet-s-At-Most-One-Semantics" class="headerlink" title="2.3 StatefulSet&#39;s At-Most-One Semantics"></a>2.3 StatefulSet&#39;s At-Most-One Semantics</h3><p>由于StatefulSet支持新建pod复用不可用pod的identity(pod名字, hostname和PVC), 需保证只有pod不可用时才创建新的pod, 为此StatefulSet使用<strong>at-most-one</strong>语义来确保同一时间最多只有一个pod使用使用该身份, StatefulSet会尽最大努力确认pod是否不可用.</p>
<h2 id="3-Use-a-StatefulSet"><a href="#3-Use-a-StatefulSet" class="headerlink" title="3. Use a StatefulSet"></a>3. Use a StatefulSet</h2><h3 id="3-1-Create-the-App-and-Container-image"><a href="#3-1-Create-the-App-and-Container-image" class="headerlink" title="3.1 Create the App and Container image"></a>3.1 Create the App and Container image</h3><p>为了更好地展示StatefulSet, 需创建一个应用, 其可写入和读取volume中的数据, 并可以与其他服务通信:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> dataFile = <span class="string">&quot;/var/data/kubia.txt&quot;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">function</span>(<span class="params">request, response</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = fs.<span class="title function_">createWriteStream</span>(dataFile);</span><br><span class="line">    file.<span class="title function_">on</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">fd</span>) &#123;</span><br><span class="line">      request.<span class="title function_">pipe</span>(file);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;New data has been received and stored.&quot;</span>);</span><br><span class="line">      response.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">      response.<span class="title function_">end</span>(<span class="string">&quot;Data stored on pod &quot;</span> + os.<span class="title function_">hostname</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="title function_">fileExists</span>(dataFile)</span><br><span class="line">      ? fs.<span class="title function_">readFileSync</span>(dataFile, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">      : <span class="string">&quot;No data posted yet&quot;</span>;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&quot;You&#x27;ve hit &quot;</span> + os.<span class="title function_">hostname</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&quot;Data stored on this pod: &quot;</span> + data + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.<span class="title function_">createServer</span>(handler);</span><br><span class="line">www.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>上述Node.js程序监听8080端口: 收到POST请求时将请求数据写入<code>/var/data/kubia.txt</code>; 收到GET请求时从该文件中读取数据并回复.</p>
<h3 id="3-2-Deploy-the-App-through-a-StatefulSet"><a href="#3-2-Deploy-the-App-through-a-StatefulSet" class="headerlink" title="3.2 Deploy the App through a StatefulSet"></a>3.2 Deploy the App through a StatefulSet</h3><p>部署应用时需创建三种资源:</p>
<ul>
<li>PV: 负责存储数据(k8s cluster不支持动态创建PV时需手动创建PV)</li>
<li>Service: 负责网路通信</li>
<li>StatefulSet</li>
</ul>
<p>StatefulSet会自动创建PersistentVolumeClaim, 所以并不需手动创建PVC.</p>
<h4 id="3-2-1-Create-the-Persistent-Volume"><a href="#3-2-1-Create-the-Persistent-Volume" class="headerlink" title="3.2.1 Create the Persistent Volume"></a>3.2.1 Create the Persistent Volume</h4><p>使用Google Kunernetets Engine时, 需先创建三个GCE Persistent Disk:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gcloud compute disks create --size=1GiB --zone=us-east1-b pv-a</span><br><span class="line">$ gcloud compute disks create --size=1GiB --zone=us-east1-b pv-b</span><br><span class="line">$ gcloud compute disks create --size=1GiB --zone=us-east1-b pv-c</span><br></pre></td></tr></table></figure>
<p>以下是使用GCE persistent disk的PV, 一共有三个PV(pv-a, pv-b和pv-c), 每个PV有1Mb空间.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">List</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv-a</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">capacity:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Mi</span></span><br><span class="line">    <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">    <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line">    <span class="attr">gcePersistentDisk:</span></span><br><span class="line">      <span class="attr">pdName:</span> <span class="string">pv-a</span></span><br><span class="line">      <span class="attr">fsType:</span> <span class="string">nfs4</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pv-b</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-Creating-the-Governing-Service"><a href="#3-2-2-Creating-the-Governing-Service" class="headerlink" title="3.2.2 Creating the Governing Service"></a>3.2.2 Creating the Governing Service</h4><p><code>clusterIP: None</code>表示这是一个headless service, 负责为stateful的每个pod提供网络身份.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-Creating-the-StatefulSet-Manifest"><a href="#3-2-3-Creating-the-StatefulSet-Manifest" class="headerlink" title="3.2.3 Creating the StatefulSet Manifest"></a>3.2.3 Creating the StatefulSet Manifest</h4><p><code>volumeClaimTemplates</code>指定StatefulSet创建何种规格的PVC. </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia-pet</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/var/data</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Mi</span></span><br><span class="line">      <span class="attr">accessModes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure>
<p>可以发现, 除了<code>volumeClaimTemplates</code>外, StatefulSet的配置与ReplicaSet基本相同. 上述StatefulSet包含2个pod, 每个pod包含<code>app: kubia</code>的label, pod会将<code>/var/data</code>路径挂载到名为<code>data</code>的volume上. <code>volumeClaimTemplates</code>则定义了一个PVC的模板, 会为每个pod生成对应的PVC.</p>
<h4 id="3-2-4-Create-the-StatefulSet"><a href="#3-2-4-Create-the-StatefulSet" class="headerlink" title="3.2.4 Create the StatefulSet"></a>3.2.4 Create the StatefulSet</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl create -f kubia-statefulset.yaml</span><br><span class="line">statefulset <span class="string">&quot;kubia&quot;</span> created</span><br></pre></td></tr></table></figure>
<p>创建StatefulSet立刻查看pod:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME    READY STATUS            RESTARTS AGE</span><br><span class="line">kubia-0 0/1   ContainerCreating 0        1s</span><br></pre></td></tr></table></figure>
<p>不同于ReplicaSet, StatefulSet不会立即创建所有pod, 而是先创建第一个pod, 直到该pod处于运行状态时才创建下一个pod:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME    READY STATUS            RESTARTS AGE</span><br><span class="line">kubia-0 1/1   Running           0        8s</span><br><span class="line">kubia-1 0/1   ContainerCreating 0        2s</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-Examine-the-Generated-Stateful-Pod"><a href="#3-2-5-Examine-the-Generated-Stateful-Pod" class="headerlink" title="3.2.5 Examine the Generated Stateful Pod"></a>3.2.5 Examine the Generated Stateful Pod</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">po</span> <span class="string">kubia-0</span> <span class="string">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/kubia-pet</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/data</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">data-kubia-0</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>可以看到, StatefulSet会为名为<code>kubia-0</code>的pod创造一个名为<code>data-kubia-0</code>的PVC, 也就是volumeClaimTemplates的名字加上pod的名字, 并其挂载到container的<code>/var/data</code>路径上:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME         STATUS VOLUME CAPACITY ACCESSMODES AGE</span><br><span class="line">data-kubia-0 Bound  pv-c   0                    37s</span><br><span class="line">data-kubia-1 Bound  pv-a   0                    37s</span><br></pre></td></tr></table></figure>

<h3 id="3-3-Communicate-with-Your-Pods"><a href="#3-3-Communicate-with-Your-Pods" class="headerlink" title="3.3 Communicate with Your Pods"></a>3.3 Communicate with Your Pods</h3><p>假设外部服务想要访问名为<code>kubia-0</code>的pod, 可将API server作为中间代理,  则访问路径如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;apiServerHost&gt;:&lt;port&gt;/api/v1/namespaces/default/pods/kubia-0/proxy/&lt;path&gt;</span><br></pre></td></tr></table></figure>
<p>为避免配置SSL certificate, 可使用<code>kubectl proxy</code>简化与API server的通信:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl proxy</span><br><span class="line">Starting to serve on 127.0.0.1:8001</span><br><span class="line"></span><br><span class="line">$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br><span class="line">You<span class="string">&#x27;ve hit kubia-0</span></span><br><span class="line"><span class="string">Data stored on this pod: No data posted yet</span></span><br></pre></td></tr></table></figure>
<p>整个GET请求的流程如下:<br><img src="/images/Kubernetes/statefulset-3-1.png" alt="Connect to a pod through both the kubectl proxy and API server proxy"></p>
<p>也可通过API server向pod发送POST请求:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -d <span class="string">&quot;Hey there!&quot;</span> localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br><span class="line">Data stored on pod kubia-0</span><br><span class="line"></span><br><span class="line">$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-0/proxy/</span><br><span class="line">You<span class="string">&#x27;ve hit kubia-0</span></span><br><span class="line"><span class="string">Data stored on this pod: Hey there!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ curl localhost:8001/api/v1/namespaces/default/pods/kubia-1/proxy/</span></span><br><span class="line"><span class="string">You&#x27;</span>ve hit kubia-1</span><br><span class="line">Data stored on this pod: No data posted yet</span><br></pre></td></tr></table></figure>

<p>删除pod后, StatefulSet会像ReplicaSet一样创建新的pod, 新创建的pod会使用被删除pod的名字, hostname和volume:<br><img src="/images/Kubernetes/statefulset-3-2.png" alt="A stateful pod may be rescheduled to a different node, but it retains the name, hostname, and storage"></p>
<p>减小replica count时, StatefulSet按照序号从大到小关闭pod, 同一时间只会有一个pod处于<code>terminating</code>状态. </p>
<h2 id="4-Discovering-peers-in-a-StatefulSet"><a href="#4-Discovering-peers-in-a-StatefulSet" class="headerlink" title="4. Discovering peers in a StatefulSet"></a>4. Discovering peers in a StatefulSet</h2><p>虽然外部服务可通过API server与pod沟通, 但我们需要一种不依赖于k8s的方式与pod直接通信: <strong>SRV record</strong>. SRV记录用于表示一组拥有相同服务的服务器的hostname和port. 为获取StatefulSet的SRV记录, 可执行<code>dig</code>命令(在临时运行的pod中):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl run -it srvlookup --image=tutum/dnsutils --<span class="built_in">rm</span> --restart=Never -- dig SRV kubia.default.svc.cluster.local</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">kubia.default.svc.cluster.local. 30 IN SRV 10 33 0 kubia-0.kubia.default.svc.cluster.local.</span><br><span class="line">kubia.default.svc.cluster.local. 30 IN SRV 10 33 0 kubia-1.kubia.default.svc.cluster.local.</span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">kubia-0.kubia.default.svc.cluster.local. 30 IN A 172.17.0.4</span><br><span class="line">kubia-1.kubia.default.svc.cluster.local. 30 IN A 172.17.0.6</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>ANSWER SECTION</code>中有两条SRV记录, 分别表示<code>kubia-0</code>和<code>kubia-1</code>. 若想在运行时获取所有SRV记录, 可在程序中执行<strong>SRV DNS lookup</strong>获取StatefulSet的所有SRV记录:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dns.<span class="title function_">resolveSrv</span>(<span class="string">&quot;kubia.default.svc.cluster.local&quot;</span>, callBackFunction); <span class="comment">// service name</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是, SRV记录没有前后顺序, 因此SRV记录的显示顺序不表示pod的创建顺序.</p>
<h3 id="4-1-Implement-peer-discovery-through-DNS"><a href="#4-1-Implement-peer-discovery-through-DNS" class="headerlink" title="4.1 Implement peer discovery through DNS"></a>4.1 Implement peer discovery through DNS</h3><p>由于StatefulSet中的pod各自拥有不同的数据, 当外部服务想要获取StatefulSet的所有数据时, 需要外部服务查找SRV记录, 并逐个获取每个pod的数据; 为方便获取全部数据, 可让pod接收外部服务的请求时从其他pod中收集数据, 并将全部数据回复给外部服务.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">&#x27;dns&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> dataFile = <span class="string">&quot;/var/data/kubia.txt&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> serviceName = <span class="string">&quot;kubia.default.svc.cluster.local&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">8080</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> handler = <span class="keyword">function</span>(<span class="params">request, response</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">url</span> == <span class="string">&#x27;/data&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> data = <span class="title function_">fileExists</span>(dataFile)</span><br><span class="line">        ? fs.<span class="title function_">readFileSync</span>(dataFile, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        : <span class="string">&quot;No data posted yet&quot;</span>;</span><br><span class="line">      response.<span class="title function_">end</span>(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.<span class="title function_">write</span>(<span class="string">&quot;You&#x27;ve hit &quot;</span> + os.<span class="title function_">hostname</span>() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      response.<span class="title function_">write</span>(<span class="string">&quot;Data stored in the cluster:\n&quot;</span>);</span><br><span class="line">      dns.<span class="title function_">resolveSrv</span>(serviceName, <span class="keyword">function</span> (<span class="params">err, addresses</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          response.<span class="title function_">end</span>(<span class="string">&quot;Could not look up DNS SRV records: &quot;</span> + err);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> numResponses = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (addresses.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">          response.<span class="title function_">end</span>(<span class="string">&quot;No peers discovered.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          addresses.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> requestOptions = &#123;</span><br><span class="line">              <span class="attr">host</span>: item.<span class="property">name</span>,</span><br><span class="line">              <span class="attr">port</span>: port,</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;/data&#x27;</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title function_">httpGet</span>(requestOptions, <span class="keyword">function</span> (<span class="params">returnedData</span>) &#123;</span><br><span class="line">              numResponses++;</span><br><span class="line">              response.<span class="title function_">write</span>(<span class="string">&quot;- &quot;</span> + item.<span class="property">name</span> + <span class="string">&quot;: &quot;</span> + returnedData);</span><br><span class="line">              response.<span class="title function_">write</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> (numResponses == addresses.<span class="property">length</span>) &#123;</span><br><span class="line">                response.<span class="title function_">end</span>();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>经过上述修改后, 外部服务可向StatefulSet的任意一个pod发送GET请求, 收到请求的pod会通过SRV DNS lookup获取StatefulSet中所有pod的hostname, 并向所有hostname的<code>/data</code>路径发送GET请求获取数据, 最后组合数据并返回给外部服务, 整个流程如下:<br><img src="/images/Kubernetes/statefulset-4-1.png" alt="The operation of your simplistic distributed data store"></p>
<h3 id="4-2-Update-a-StatefulSet"><a href="#4-2-Update-a-StatefulSet" class="headerlink" title="4.2 Update a StatefulSet"></a>4.2 Update a StatefulSet</h3><p>更新StatefulSet时, 可使用<code>kubectl edit</code>命令修改StatefulSet的YAML文件. 需要注意的是, 修改StatefulSet的YAML文件后, StatefulSet不会替换已有的pod, 只有新创建的pod使用新的manifest. 若需替换旧的pod, 则需删除已有pod:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl edit statefulset kubia</span><br></pre></td></tr></table></figure>
<p>例如, 将<code>spec.relicas</code>从2改为3, 并将<code>spec.template.spec.containers.image</code>从<code>luksa/kubiapet</code>改为<code>luksa/kubia-pet-peers</code>:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME    READY STATUS            RESTARTS AGE</span><br><span class="line">kubia-0 1/1   Running           0        25m</span><br><span class="line">kubia-1 1/1   Running           0        26m</span><br><span class="line">kubia-2 0/1   ContainerCreating 0        4s</span><br></pre></td></tr></table></figure>
<p><code>kubia-0</code>和<code>kubia-1</code>没有任何更新, <code>kubia-2</code>则使用新的image.</p>
<h2 id="5-Understand-How-StatefulSets-Deal-with-Node-Failures"><a href="#5-Understand-How-StatefulSets-Deal-with-Node-Failures" class="headerlink" title="5. Understand How StatefulSets Deal with Node Failures"></a>5. Understand How StatefulSets Deal with Node Failures</h2><p>由于每个pod都是唯一的, StatefulSet需保证同一时间不能存在两个相同的pod同时运行, 只有确认pod没有在运行时才会创建新的pod.</p>
<h3 id="5-1-Simulate-a-Node-s-Disconnection-From-the-Network"><a href="#5-1-Simulate-a-Node-s-Disconnection-From-the-Network" class="headerlink" title="5.1 Simulate a Node&#39;s Disconnection From the Network"></a>5.1 Simulate a Node&#39;s Disconnection From the Network</h3><p>假设k8s clsuter中一个StatefulSet管理3个pod, 分别名为<code>kubia-0</code>, <code>kubia-1</code>和<code>kubia-2</code>, 分别运行在不同的worker node上. 为测试node不可用时StatefulSet的应对策略, 需先断开其中一个worker node的网络接口:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gcloud compute ssh gke-kubia-m0g1</span><br><span class="line">$ <span class="built_in">sudo</span> ifconfig eth0 down</span><br></pre></td></tr></table></figure>
<p>断开连接后, node上的kubelet无法与k8s API server通信, 因此k8s API server无法得知node和其pod的状态:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get node</span><br><span class="line">NAME           STATUS   AGE VERSION</span><br><span class="line">gke-kubia-596v Ready    16m v1.6.2</span><br><span class="line">gke-kubia-m0g1 NotReady 16m v1.6.2</span><br><span class="line">gke-kubia-sgl7 Ready    16m v1.6.2</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME    READY STATUS  RESTARTS AGE</span><br><span class="line">kubia-0 1/1   Unknown 0        15m</span><br><span class="line">kubia-1 1/1   Running 0        14m</span><br><span class="line">kubia-2 1/1   Running 0        13m</span><br></pre></td></tr></table></figure>
<p>Control plane将该node的状态标记为<code>NotReady</code>, 并将pod状态标记为<code>Unknown</code>. 可以发现, StatefulSet并没有创建新的pod来替换该pod, 因为StatefulSet无法确定该pod的状态.<br>若node重新上线, 该pod会回到<code>Running</code>状态; 但若pod的<code>Unknown</code>状态超过一定时间, control plane会试图将该pod移除, 并将pod状态改为<code>Terminating</code>; 但由于node断开连接, kubelet无法回应master的删除请求, 所以pod会一直处于<code>Terminating</code>状态.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl describe po kubia-0</span><br><span class="line">Name: kubia-0</span><br><span class="line">Namespace: default</span><br><span class="line">Node: gke-kubia-default-pool-32a2cac8-m0g1/10.132.0.2</span><br><span class="line">...</span><br><span class="line">Status: Terminating (expires Tue, 23 May 2017 15:06:09 +0200)</span><br><span class="line">Reason: NodeLost</span><br><span class="line">Message: Node gke-kubia-default-pool-32a2cac8-m0g1 <span class="built_in">which</span> was</span><br><span class="line"> running pod kubia-0 is unresponsive</span><br></pre></td></tr></table></figure>

<p>以下三种情况会让k8s会从API server上删除该pod的信息:</p>
<ul>
<li>删除worker node</li>
<li>worker node重新连接, kubelet响应删除请求</li>
<li>强制删除Pod</li>
</ul>
<h3 id="5-2-Delete-the-Pod-Forcibly"><a href="#5-2-Delete-the-Pod-Forcibly" class="headerlink" title="5.2 Delete the Pod Forcibly"></a>5.2 Delete the Pod Forcibly</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl delete po kubia-0</span><br><span class="line">pod <span class="string">&quot;kubia-0&quot;</span> deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get po</span><br><span class="line">NAME READY STATUS RESTARTS AGE</span><br><span class="line">kubia-0 1/1 Unknown 0 15m</span><br><span class="line">kubia-1 1/1 Running 0 14m</span><br><span class="line">kubia-2 1/1 Running 0 13m</span><br></pre></td></tr></table></figure>
<p>删除pod操作并不会真正移除pod, 这是因为control plane只会在kubelet确认删除请求后才会移除该pod, 由于node断开连接, kubelet也就无法回应API server的删除请求.<br>强制删除则不会等待kubelet的确认: 无论pod是否被终止, API server都会删除该pod的信息, StatefulSet也会创建新的pod来替代被删除的pod:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl delete pod kubia-0 --grace-period=0 --force</span><br><span class="line">pod <span class="string">&quot;kubia-0&quot;</span> deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get pods</span><br><span class="line">NAME READY STATUS RESTARTS AGE</span><br><span class="line">kubia-0 0/1 ContainerCreating 0 8s</span><br><span class="line">kubia-1 1/1 Running 0 20m</span><br><span class="line">kubia-2 1/1 Running 0 19m</span><br></pre></td></tr></table></figure>
<p>强制删除可能违背StatefulSet的<strong>at-most-one</strong>原则, 因此执行强制删除前需保证node不可用; 若node重新上线, 两个相同pod可能会导致数据丢失.</p>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/K8s/">K8s</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/b4dd.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">The Transport Layer</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/10cb.html">
        <span class="next-text nav-default">Deployment</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/c933.html';
  var disqus_title = "StatefulSet";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
