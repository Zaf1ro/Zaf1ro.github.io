<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="Interprocess Communication"/>




  <meta name="keywords" content="Unix," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/4cb2.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/4cb2.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/4cb2.html"/>


<meta name="description" content="1. PipesPipes(管道)作为UNIX中时间最长的IPC工具, 有两个缺陷:  Pipes为half-duplex(半双工, 数据只能向一个方便传递). 虽然已经有系统支持full-duplex pipes, 但为了系统兼容性, 还是应将pipes默认为half-duplex Pipes的使用有一个前提: 两个进程有共同的祖先, 一般用于parent process和child proce">
<meta property="og:type" content="article">
<meta property="og:title" content="Interprocess Communication">
<meta property="og:url" content="https://zaf1ro.github.io/p/4cb2.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. PipesPipes(管道)作为UNIX中时间最长的IPC工具, 有两个缺陷:  Pipes为half-duplex(半双工, 数据只能向一个方便传递). 虽然已经有系统支持full-duplex pipes, 但为了系统兼容性, 还是应将pipes默认为half-duplex Pipes的使用有一个前提: 两个进程有共同的祖先, 一般用于parent process和child proce">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/UNIX/ipc-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/UNIX/ipc-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/UNIX/ipc-3.png">
<meta property="article:published_time" content="2019-10-07T13:13:30.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.056Z">
<meta property="article:tag" content="Unix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/UNIX/ipc-1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
Interprocess Communication - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Pipes"><span class="toc-text">1. Pipes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-popen-and-pclose-Functions"><span class="toc-text">2. popen and pclose Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Coprocesses"><span class="toc-text">3. Coprocesses</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-FIFOs"><span class="toc-text">4. FIFOs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-XSI-IPC"><span class="toc-text">5. XSI IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Identifiers-and-Keys"><span class="toc-text">5.1 Identifiers and Keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Permission-Structure"><span class="toc-text">5.2 Permission Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Configuration-Limits"><span class="toc-text">5.3 Configuration Limits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Advantages-and-Disadvantages"><span class="toc-text">5.4 Advantages and Disadvantages</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Message-Queues"><span class="toc-text">6. Message Queues</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Semaphores"><span class="toc-text">7. Semaphores</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Shared-Memory"><span class="toc-text">8. Shared Memory</span></a></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Interprocess Communication
        
      </h1>
      <time class="post-time">
          10/07/19
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Pipes"><a href="#1-Pipes" class="headerlink" title="1. Pipes"></a>1. Pipes</h2><p>Pipes(管道)作为UNIX中时间最长的IPC工具, 有两个缺陷:</p>
<ol>
<li>Pipes为half-duplex(半双工, 数据只能向一个方便传递). 虽然已经有系统支持full-duplex pipes, 但为了系统兼容性, 还是应将pipes默认为half-duplex</li>
<li>Pipes的使用有一个前提: 两个进程有共同的祖先, 一般用于parent process和child process之间的通信</li>
<li>被创建的pipe没有名字</li>
<li>Pipe的buffer空间有限</li>
</ol>
<p>尽管pipes有诸多缺陷, 但仍是最被常用的IPC工具. 调用pipe()可创建一个pipe:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create a pipe that can be used for IPC</span></span><br><span class="line"><span class="comment"> * @param fd: return two file descriptors referring to the </span></span><br><span class="line"><span class="comment"> *        ends of the pipe</span></span><br><span class="line"><span class="comment"> *        1. fd[0]: the read end of the pipe</span></span><br><span class="line"><span class="comment"> *        2. fd[1]: the write end of the pipe</span></span><br><span class="line"><span class="comment"> * @return 0 on success; -1 on error and errno is set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief same as pipe()</span></span><br><span class="line"><span class="comment"> * @param flags: shall be one of the following values:</span></span><br><span class="line"><span class="comment"> *        1. O_CLOEXEC: Set the close-on-exec (FD_CLOEXEC) </span></span><br><span class="line"><span class="comment"> *           flag on the two new file descriptors</span></span><br><span class="line"><span class="comment"> *        2. O_DIRECT: Each write to the pipe is dealt with </span></span><br><span class="line"><span class="comment"> *           as a separate packet, and read from the pipe </span></span><br><span class="line"><span class="comment"> *           will read one packet at a time</span></span><br><span class="line"><span class="comment"> *        3. O_NONBLOCK: Set the O_NONBLOCK file status flag </span></span><br><span class="line"><span class="comment"> *           on the two file descriptions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe2</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>], <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>但单个进程中的pipe没有意义, 通常进程会先调用pipe(), 然后调用fork(), 结果如下:<br><img src="/images/UNIX/ipc-1.png" alt="Half-duplex pipe after a fork"></p>
<p>这时parent process和child process都可以向pipe读取或写入数据. 若想要让child process读取来自parent process的数据, 则关闭parent process中的fd[0]和child process中的fd[1]:<br><img src="/images/UNIX/ipc-2.png" alt="Pipe from parent to child"></p>
<p>当用户关闭pipe的一端时:</p>
<ol>
<li>当write端被关闭后, read端尝试读取会返回0</li>
<li>当read端被关闭后, write端尝试写入会产生SIGPIPE signal; 若无视该信号, 则返回-1并将errno设为EPIPE</li>
</ol>
<p>Kernel中的PIPE_BUF表示pipe的buffer size, POSIX.1规定当进程写入的数据小于PIPE_BUF时, 写入操作必须是原子的; 但若写入数据大于PIPE_BUF, 操作结果有以下几种结果:</p>
<ol>
<li>O_NONBLOCK disabled: 以非原子地形式与其他进程交错写入; write()会被阻塞, 直到写入全部数据</li>
<li>O_NONBLOCK enabled: 若pipe buffer已满, 则write()直接返回-1并将errno设置为EAGAIN; 否则写入部分数据, write()返回还没写入的字节数</li>
</ol>
<h2 id="2-popen-and-pclose-Functions"><a href="#2-popen-and-pclose-Functions" class="headerlink" title="2. popen and pclose Functions"></a>2. popen and pclose Functions</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief open a process by creating a pipe, forking, and </span></span><br><span class="line"><span class="comment"> *        executing the cmdstring</span></span><br><span class="line"><span class="comment"> * @param cmdstring: a pointer to a null-terminated string </span></span><br><span class="line"><span class="comment"> *        containing a shell command line. This command is </span></span><br><span class="line"><span class="comment"> *        passed to /bin/sh using the -c flag; interpretation</span></span><br><span class="line"><span class="comment"> * @param type: a pointer to a null-terminated string which </span></span><br><span class="line"><span class="comment"> *        contains either &#x27;r&#x27; for reading or &#x27;w&#x27; for writing</span></span><br><span class="line"><span class="comment"> * @return a standard I/O stream on success; NULL on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief close the standard I/O stream and wait for the </span></span><br><span class="line"><span class="comment"> *        command to terminate</span></span><br><span class="line"><span class="comment"> * @return the exit status of the command on success; -1 on </span></span><br><span class="line"><span class="comment"> *         error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>
<p>以下是调用popen()时type为&quot;r&quot;和&quot;w&quot;的结果:<br><img src="/images/UNIX/ipc-3.png" alt="Result of popen(cmdstring, &quot;r&quot;) and  popen(cmdstring, &quot;w&quot;)"></p>
<p>注意: popen()不应用于设置了set-user-ID或set-group-ID的程序中. set-ID会提高用户权限, 可能导致shell执行的命令具有破坏性</p>
<h2 id="3-Coprocesses"><a href="#3-Coprocesses" class="headerlink" title="3. Coprocesses"></a>3. Coprocesses</h2><p>Filter作为一种程序, 用于处理或产生stream. UNIX中的filter从standard input中获取数据, 经过处理后将数据写入standard output, 常见的UNIX filter: awk, cat, comm, cut, expand, compress, fold, grep, head, less, more, nl, perl, paste, pr, sed, sh, sort, split, strings, tail, tac, tee, tr, uniq, wc, zcat. 可用Shell的pipe operator (&quot;|&quot;)来连接一个或多个filter, Filter的输入和输出也可以重定向为某个文件或其他设备.<br>Coprocess借鉴filter的思路: 当某个进程既产生filter的输入, 又从filter获取数据时, 该filter就成为这个进程的coprocess. 通常情况下coprocess会创建两个pipe, 一个用于读取其他进程的数据, 另一个用于输出处理过的数据. 相对于popen的单向pipe, coprocess提供了双向数据流.</p>
<h2 id="4-FIFOs"><a href="#4-FIFOs" class="headerlink" title="4. FIFOs"></a>4. FIFOs</h2><p>FIFO也被称为named pipes, 因为FIFO以文件形式存放在文件系统中. 即使两个进程不存在共同祖先, 仍可以使用FIFO进行通信.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief make a FIFO file with name pathname</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief same as mkfifo()</span></span><br><span class="line"><span class="comment"> * @param path, fd: there are three cases</span></span><br><span class="line"><span class="comment"> *        1. If the path specifies an absolute pathname, then</span></span><br><span class="line"><span class="comment"> *           the fd is ignored and mkfifo() behaves like </span></span><br><span class="line"><span class="comment"> *           mkfifo()</span></span><br><span class="line"><span class="comment"> *        2. If the path specifies a relative pathname and </span></span><br><span class="line"><span class="comment"> *           the fd is valid file descriptor for an directory,</span></span><br><span class="line"><span class="comment"> *           the pathname is relative to this directory</span></span><br><span class="line"><span class="comment"> *        3. If the path specifies a relative pathname and </span></span><br><span class="line"><span class="comment"> *           the fd has value AT_FDCWD, the pathname is </span></span><br><span class="line"><span class="comment"> *           starting in the current directory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifoat</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p>FIFO的使用与pipe并无太大区别, 但使用前需调用open()打开指定FIFO文件. 打开FIFO文件时, O_NONBLOCK flag对open()有以下影响:</p>
<ul>
<li>O_NONBLOCK disabled: 对于只读block, open()会等待其他进程写入数据; 对于只写block, open()会等待其他进程读取</li>
<li>O_NONBLOCK enabled: 对于只读block, 若没有进程读取数据, open()会立即返回; 对于只写block, 若没有进程写入数据吗, open()会返回-1并设置errno为ENXIO</li>
</ul>
<p>如同pipe, 当向没有reader的FIFO写入数据时会产生SIGPIPE; 当writer关闭FIFO时, reader会得到EOF. FIFO主要有两种用途:</p>
<ol>
<li>Shell command使用FIFOs在shell pipeline之间传递数据</li>
<li>用于client和server传递数据</li>
</ol>
<h2 id="5-XSI-IPC"><a href="#5-XSI-IPC" class="headerlink" title="5. XSI IPC"></a>5. XSI IPC</h2><p>XSI IPC定义了三个IPC structure: message queue, semaphones, shared memory. 这三种IPC structure虽然存在一定的差异, 但也有很多相似之处.</p>
<h3 id="5-1-Identifiers-and-Keys"><a href="#5-1-Identifiers-and-Keys" class="headerlink" title="5.1 Identifiers and Keys"></a>5.1 Identifiers and Keys</h3><p>三种IPC结构体在kernel中都用一个非负整数表示, 作为其identifier. 每创建一个IPC structure, 分配的IPC identifer都加一; 达到最大值后再从0循环使用.<br>但IPC identifier只在IPC structure内部使用, 进程想要调用IPC structure需要使用IPC structure对应的key. 当创建IPC structure, 进程必须为其指定一个key. Key的类型为key_t, 通常为long integer, kernel会将key转换为IPC identifier. 以下是client和server使用同一个IPC structure的方法:</p>
<ol>
<li>Server创建IPC structure时指定key为IPC_PRIVATE, 获得IPC identifier后将其保存在某个文件中方便client获取. IPC_PRIVATE保证server创建的IPC structure是全新的, 而不是绑定在其他IPC structure上; 缺点是需要I&#x2F;O操作将IPC identifier写入文件, 并让client读取该文件获取IPC identifier. IPC_PRIVATE通常用于parent-child relationship: parent process创建IPC structure后调用fork(), 其child process由于继承IPC identifier, 因此也可以使用该IPC structure且不需要I&#x2F;O操作</li>
<li>Server和client事先准备一个key, sever使用该key创建IPC structure. 问题在于, key可能被其他IPC structure使用并在创建时返回错误, 这时server必须删除现有IPC structure并再次尝试创建新的IPC structure</li>
<li>Server和client可事先准备一个pathname和project ID(character value betweeen 0 and 255)来调用ftok()获取相应的key  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief use the identity of the file named by path and</span></span><br><span class="line"><span class="comment"> *        the least 8 bits of id to generate a key_t type </span></span><br><span class="line"><span class="comment"> *        key. When two processes use the same path and id,</span></span><br><span class="line"><span class="comment"> *        they shall get the same value of key</span></span><br><span class="line"><span class="comment"> * @return the generated key_t value on success; -1 on </span></span><br><span class="line"><span class="comment"> *         error and errno is set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>三种不同的IPC structure(message queue, semaphore, shared memeory)都有对应的创建IPC structure的方法: msgget(), semget(), shmget(). 这三个函数都需要key和flag参数, 以下两种情况会创建一个新的IPC structure:</p>
<ol>
<li>key为IPC_PRIVATE</li>
<li>key没有与现有的IPC structure关联, 且flag设置了IPC_CREAT</li>
</ol>
<p>若想要使用已被创建的IPC structure, 则需要指定一个已经关联的key, 且不能在flag中设置IPC_CREAT. </p>
<h3 id="5-2-Permission-Structure"><a href="#5-2-Permission-Structure" class="headerlink" title="5.2 Permission Structure"></a>5.2 Permission Structure</h3><p>每个IPC structure都有一个关联的ipc_perm structure. 该structure定义了权限和owner ID:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">  <span class="type">uid_t</span> uid;   <span class="comment">/* owner’s effective user ID */</span></span><br><span class="line">  <span class="type">gid_t</span> gid;   <span class="comment">/* owner’s effective group ID */</span></span><br><span class="line">  <span class="type">uid_t</span> cuid;  <span class="comment">/* creator’s effective user ID */</span></span><br><span class="line">  <span class="type">gid_t</span> cgid;  <span class="comment">/* creator’s effective group ID */</span></span><br><span class="line">  <span class="type">mode_t</span> mode; <span class="comment">/* access modes */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ipc_perm structure中的变量都可以通过IPC structure对应的msgctl(), semctl()或shmctl()修改. mode的表示如下:</p>
<table>
<thead>
<tr>
<th align="center">Permission</th>
<th align="center">Bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user-read</td>
<td align="center">0400</td>
</tr>
<tr>
<td align="center">user-write(alter)</td>
<td align="center">0200</td>
</tr>
<tr>
<td align="center">group-read</td>
<td align="center">0040</td>
</tr>
<tr>
<td align="center">group-write(alter)</td>
<td align="center">0020</td>
</tr>
<tr>
<td align="center">other-read</td>
<td align="center">0004</td>
</tr>
<tr>
<td align="center">other-write(alter)</td>
<td align="center">0002</td>
</tr>
</tbody></table>
<h3 id="5-3-Configuration-Limits"><a href="#5-3-Configuration-Limits" class="headerlink" title="5.3 Configuration Limits"></a>5.3 Configuration Limits</h3><p>每个IPC structure都有其limit. 以下是各系统查看IPC-related limits的command:</p>
<ol>
<li>Linux: <strong>ipcs -l</strong></li>
<li>FreeBSD and Mac OS X: <strong>ipcs -T</strong></li>
<li>Solaris: <strong>sysdef -i</strong></li>
</ol>
<h3 id="5-4-Advantages-and-Disadvantages"><a href="#5-4-Advantages-and-Disadvantages" class="headerlink" title="5.4 Advantages and Disadvantages"></a>5.4 Advantages and Disadvantages</h3><p>IPC structure的生存周期与系统生存周期相同. 以message queue为例, 进程的终止并不会让message queue被删除, message queue中的内容也会一直保留, 直到其他进程调用msgrcv(), msgctl(), ipcrm()或系统重启. 相比之下, pipe会在最后一个进程退出时会被自动删除; FIFO虽然不会被自动删除, 但FIFO中的数据会在进程退出时被删除.<br>IPC structure无法被file system获知, 因为IPC structure没有提供file descriptor. XSI IPC通过提供新的system calls(msgget, semop, shmat等)使得进程可以操作IPC structure; 但这也导致IPC无法使用很多I&#x2F;O functions(例如: select, poll).<br>IPC structure也提供了很多pipe和FIFO不具备的特性:</p>
<table>
<thead>
<tr>
<th align="center">IPC type</th>
<th align="center">Connectionless?</th>
<th align="center">Reliable?</th>
<th align="center">Flow control?</th>
<th align="center">Record?</th>
<th align="center">Message types or priorities</th>
</tr>
</thead>
<tbody><tr>
<td align="center">message queues</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">STREAMS</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">UNIX domain stream socket</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">UNIX domain datagram socket</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">FIFOs</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
</tbody></table>
<h2 id="6-Message-Queues"><a href="#6-Message-Queues" class="headerlink" title="6. Message Queues"></a>6. Message Queues</h2><p>Message queue是kernel中的linked list, 并用identifier(也称作queue ID)标示. 进程调用msgget()创建一个新的message queue, 可调用msgsnd()将新信息加入到queue尾部; 调用msgrcv()从queue中取出信息. 每个queue都有一个msqid_ds structure关联:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span> <span class="comment">/* see 5.2 */</span></span><br><span class="line">  <span class="type">msgqnum_t</span> msg_qnum;       <span class="comment">/* number of messages on queue */</span></span><br><span class="line">  <span class="type">msglen_t</span> msg_qbytes;      <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">  <span class="type">pid_t</span> msg_lspid;          <span class="comment">/* pid of last msgsnd() */</span></span><br><span class="line">  <span class="type">pid_t</span> msg_lrpid;          <span class="comment">/* pid of last msgrcv() */</span></span><br><span class="line">  <span class="type">time_t</span> msg_stime;         <span class="comment">/* last-msgsnd() time */</span></span><br><span class="line">  <span class="type">time_t</span> msg_rtime;         <span class="comment">/* last-msgrcv() time */</span></span><br><span class="line">  <span class="type">time_t</span> msg_ctime;         <span class="comment">/* last-change time */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下是message queue常用函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief open an existing queue or create a new queue. If a </span></span><br><span class="line"><span class="comment"> *        new message queue is created, then its msqid_ds </span></span><br><span class="line"><span class="comment"> *        structure is initialized as follows:</span></span><br><span class="line"><span class="comment"> *        1. msg_perm.cuid, msg_perm.uid are set to the </span></span><br><span class="line"><span class="comment"> *           effective user ID of the calling process.</span></span><br><span class="line"><span class="comment"> *        2. msg_perm.cgid, msg_perm.gid are set to the </span></span><br><span class="line"><span class="comment"> *           effective group ID of the calling process.</span></span><br><span class="line"><span class="comment"> *        3. msg_qnum, msg_lspid, msg_lrpid, msg_stime, and </span></span><br><span class="line"><span class="comment"> *           msg_rtime are set to 0.</span></span><br><span class="line"><span class="comment"> *        4. msg_perm.mode is set to the flag.</span></span><br><span class="line"><span class="comment"> *        5. msg_ctime is set to the current time.</span></span><br><span class="line"><span class="comment"> *        6. msg_qbytes is set to the system limit MSGMNB</span></span><br><span class="line"><span class="comment"> * @param key: shall be the following values:</span></span><br><span class="line"><span class="comment"> *        1. IPC_CREAT: create the queue if it doesn&#x27;t exist </span></span><br><span class="line"><span class="comment"> *           in kernel</span></span><br><span class="line"><span class="comment"> *        2. IPC_EXCL: fail when IPC_CREAT is set and queue </span></span><br><span class="line"><span class="comment"> *           already exists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief perform various operations on a message queue</span></span><br><span class="line"><span class="comment"> * @param cmd: shall be the following values:</span></span><br><span class="line"><span class="comment"> *        1. IPC_STAT: Fetch the msqid_ds structure for this </span></span><br><span class="line"><span class="comment"> *           queue</span></span><br><span class="line"><span class="comment"> *        2. IPC_SET: Copy msg_perm.uid, msg_perm.gid, </span></span><br><span class="line"><span class="comment"> *           msg_perm.mode, and msg_qbytes pointed to by buf </span></span><br><span class="line"><span class="comment"> *           to this queue</span></span><br><span class="line"><span class="comment"> *        3. IPC_RMID: Remove the message queue from kernel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief send a message to the queue associated with the </span></span><br><span class="line"><span class="comment"> *        message queue identifier specified by msqid</span></span><br><span class="line"><span class="comment"> * @param ptr: points to a user-defined buffer that contains </span></span><br><span class="line"><span class="comment"> *        1. a field of type long specifying the type of the </span></span><br><span class="line"><span class="comment"> *           message</span></span><br><span class="line"><span class="comment"> *        2. a data portion that holds the data bytes of the </span></span><br><span class="line"><span class="comment"> *           message</span></span><br><span class="line"><span class="comment"> *           struct mymsg &#123;</span></span><br><span class="line"><span class="comment"> *             long   mtype;</span></span><br><span class="line"><span class="comment"> *             char   mtext[1];</span></span><br><span class="line"><span class="comment"> *           &#125;</span></span><br><span class="line"><span class="comment"> * @param bytes: the length of mtext</span></span><br><span class="line"><span class="comment"> * @param flag: if IPC_NOWAIT is specified and message queue </span></span><br><span class="line"><span class="comment"> *        is full, msgsnd() shall return immediately with an </span></span><br><span class="line"><span class="comment"> *        error of EAFAIN. Or it shall be blocked until </span></span><br><span class="line"><span class="comment"> *        there is room for message.</span></span><br><span class="line"><span class="comment"> * @return 0 on success; -1 on failure and errno is set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief read a message from the queue associated with </span></span><br><span class="line"><span class="comment"> *        identifier specified by msqid and store it in the </span></span><br><span class="line"><span class="comment"> *        buffer pointed to by ptr</span></span><br><span class="line"><span class="comment"> * @param nbytes: the size in bytes of mtext</span></span><br><span class="line"><span class="comment"> * @param type: specify the type of message as follows:</span></span><br><span class="line"><span class="comment"> *        1. 0: fetch the first message on the queue</span></span><br><span class="line"><span class="comment"> *        2. &gt; 0: fetch the first message of &#x27;type&#x27;</span></span><br><span class="line"><span class="comment"> *        3. &lt; 0: fetch the first message of the lowest type </span></span><br><span class="line"><span class="comment"> *           that less or equal to the absolute value of `type`</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, </span></span><br><span class="line"><span class="params">               <span class="type">long</span> type, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="7-Semaphores"><a href="#7-Semaphores" class="headerlink" title="7. Semaphores"></a>7. Semaphores</h2><p>Semaphore作为一个counter用于控制多个进程访问一个共享资源, 争夺资源的过程如下:</p>
<ol>
<li>获取semaphore</li>
<li>semaphore &gt; 0: 说明进程可以获取资源, 并将semaphore减一</li>
<li>semaphore &#x3D; 0: 说明当前没有资源, 进程进入休眠并等待被唤醒</li>
</ol>
<p>由于会有多个进程同时操作semaphore, 必须保证semaphore的操作为atomic operation. 最常用的semaphore为binary semaphore(只拥有一个资源, 初始值为1). 但XSI semaphore其包含一些不必要的特性:</p>
<ol>
<li>Semaphore并不简单地只是一个非负整数, 而是一个或多个semaphore value的集合. 当创建XSI semaphore时, 必须说明集合中有几个semaphore value.</li>
<li>创建semaphore和初始化semaphore分别由两个函数完成: semget()和semctl(). 这导致进程无法原子地创建并初始化semaphore</li>
<li>由于XSI IPC都没有自我销毁功能, 必须由进程主动释放</li>
</ol>
<p>Semaphore在kernel中以semid_ds结构体的形式存在:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span> <span class="comment">/* see 5.2 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> sem_nsems; <span class="comment">/* number of semaphores */</span></span><br><span class="line">  <span class="type">time_t</span> sem_otime;         <span class="comment">/* last semop time */</span></span><br><span class="line">  <span class="type">time_t</span> sem_ctime;         <span class="comment">/* last change time */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">sem_base</span>;</span>     <span class="comment">/* ptr to first semaphore */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> *<span class="title">eventn</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">wait_queue</span> *<span class="title">eventz</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>  *<span class="title">undo</span>;</span>   <span class="comment">/* undo requests on this array */</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* One semaphore structure for each semaphore in the system. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">  ushort  semval;  <span class="comment">/* semaphore value, always &gt;= 0 */</span></span><br><span class="line">  <span class="type">short</span>   sempid;  <span class="comment">/* pid of last operation */</span></span><br><span class="line">  ushort  semncnt; <span class="comment">/* num procs awaiting increase in semval */</span></span><br><span class="line">  ushort  semzcnt; <span class="comment">/* num procs awaiting semval = 0 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下是XSI semaphore的常用函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @brief return the semaphore identifier associated with key.</span></span><br><span class="line"><span class="comment"> *        When a new set is created, the semid_ds is </span></span><br><span class="line"><span class="comment"> *        initialized:</span></span><br><span class="line"><span class="comment"> *        1. ipc_perm is initialized, mode is set to flag</span></span><br><span class="line"><span class="comment"> *        2. sem_otime is set to 0</span></span><br><span class="line"><span class="comment"> *        3. sem_ctime is set to the current time</span></span><br><span class="line"><span class="comment"> *        4. sem_nsems is set to nsems</span></span><br><span class="line"><span class="comment"> * @param key: if key is one of the following value, a new </span></span><br><span class="line"><span class="comment"> *        semaphore shall be created:</span></span><br><span class="line"><span class="comment"> *        1. key is equal to IPC_PRIVATE</span></span><br><span class="line"><span class="comment"> *        2. key is not assiociated with any existing </span></span><br><span class="line"><span class="comment"> *           semaphore identifier</span></span><br><span class="line"><span class="comment"> * @param nsems: if reference an existing set, nsems can be 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val; <span class="comment">/* for SETVAL */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span> <span class="comment">/* for IPC_STAT and IPC_SET */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>; <span class="comment">/* for GETALL and SETALL */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief provide semaphore control operations as specified </span></span><br><span class="line"><span class="comment"> *        by cmd. The fourth argument is optional. If </span></span><br><span class="line"><span class="comment"> *        required, it is of type &#x27;union semun&#x27;</span></span><br><span class="line"><span class="comment"> * @param semnum: no. of semaphore value, [0, nsems-1]</span></span><br><span class="line"><span class="comment"> * @param cmd: shall be one of the following values:</span></span><br><span class="line"><span class="comment"> *        1. GETVAL: return the value of semval</span></span><br><span class="line"><span class="comment"> *        2. SETVAL: set the value of semval to arg.val</span></span><br><span class="line"><span class="comment"> *        3. GETPID: return the value of sempid</span></span><br><span class="line"><span class="comment"> *        4. GETNCNT: return the value of semncnt</span></span><br><span class="line"><span class="comment"> *        5. GETZCNT: return the value of semzcnt</span></span><br><span class="line"><span class="comment"> *        6. GETALL: return the value of semval for each </span></span><br><span class="line"><span class="comment"> *           semaphore in the semaphore set and place into </span></span><br><span class="line"><span class="comment"> *           the array pointed to by arg.array</span></span><br><span class="line"><span class="comment"> *        7. SETALL: set the value of semval for each </span></span><br><span class="line"><span class="comment"> *           semaphore in the semaphore set according to the </span></span><br><span class="line"><span class="comment"> *           array pointed to by arg array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ... <span class="comment">/* union semun arg */</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* no. in set [0, nsems-1] */</span></span><br><span class="line">  <span class="type">short</span> sem_op; <span class="comment">/* operation (negative, 0, or positive) */</span></span><br><span class="line">  <span class="type">short</span> sem_flg; <span class="comment">/* IPC_NOWAIT, SEM_UNDO */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief perform an array of operations on a semaphore set</span></span><br><span class="line"><span class="comment"> * @param nops: the length of semoparray</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf semoparray[], <span class="type">size_t</span> nops)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="8-Shared-Memory"><a href="#8-Shared-Memory" class="headerlink" title="8. Shared Memory"></a>8. Shared Memory</h2><p>Shared memory允许多个进程使用同一块内存. Kernel中会给shared memory维持一个structure:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">/* see 5.2 */</span></span><br><span class="line">  <span class="type">size_t</span> shm_segsz;         <span class="comment">/* size of segment in bytes */</span></span><br><span class="line">  <span class="type">pid_t</span> shm_lpid;           <span class="comment">/* pid of last shmop() */</span></span><br><span class="line">  <span class="type">pid_t</span> shm_cpid;           <span class="comment">/* pid of creator */</span></span><br><span class="line">  <span class="type">shmatt_t</span> shm_nattch;      <span class="comment">/* number of current attaches */</span></span><br><span class="line">  <span class="type">time_t</span> shm_atime;         <span class="comment">/* last-attach time */</span></span><br><span class="line">  <span class="type">time_t</span> shm_dtime;         <span class="comment">/* last-detach time */</span></span><br><span class="line">  <span class="type">time_t</span> shm_ctime;         <span class="comment">/* last-change time */</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以下是shared memory的常用函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief obtain a shared memory identifier. When a new </span></span><br><span class="line"><span class="comment"> *        segment is created, the shmid_ds structure are </span></span><br><span class="line"><span class="comment"> *        initialized:</span></span><br><span class="line"><span class="comment"> *        1. The ipc_perm structure is initialized</span></span><br><span class="line"><span class="comment"> *        2. shm_lpid, shm_nattch, shm_atime, shm_dtime are </span></span><br><span class="line"><span class="comment"> *           set to 0</span></span><br><span class="line"><span class="comment"> *        3. shm_ctime is set to the current time</span></span><br><span class="line"><span class="comment"> *        4. shm_segsz is set to the size requested</span></span><br><span class="line"><span class="comment"> * @param key: same as key in semget()</span></span><br><span class="line"><span class="comment"> * @param size: the size of shared memory segment. If </span></span><br><span class="line"><span class="comment"> *        reference an existing segment, size can be 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief operate shared memory control operations</span></span><br><span class="line"><span class="comment"> * @param cmd: shall be one of the following commands:</span></span><br><span class="line"><span class="comment"> *        1. IPC_STAT: fetch and store shmid_ds structure in </span></span><br><span class="line"><span class="comment"> *           the structure pointed to by buf</span></span><br><span class="line"><span class="comment"> *        2. IPC_SET: set shm_perm.uid, shm_perm.gid, and </span></span><br><span class="line"><span class="comment"> *           shm_perm.mode from the structure pointed to by buf </span></span><br><span class="line"><span class="comment"> *        3. IPC_RMID: Remove the shared memory segment set </span></span><br><span class="line"><span class="comment"> *           from the system</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief attach the shared memory segment associated with </span></span><br><span class="line"><span class="comment"> *        shmid to the address space of the calling process</span></span><br><span class="line"><span class="comment"> * @param addr: the segment is attached at the address </span></span><br><span class="line"><span class="comment"> *        specified by one of the following criteria:</span></span><br><span class="line"><span class="comment"> *        1. addr = 0: the segment is attached at the first </span></span><br><span class="line"><span class="comment"> *           available address selected by the kernel</span></span><br><span class="line"><span class="comment"> *        2. addr != 0 and SHM_RND is not specified: the </span></span><br><span class="line"><span class="comment"> *           segment is attached at the address given by addr</span></span><br><span class="line"><span class="comment"> *        3. addr != 0 and SHM_RND is specified, the segment </span></span><br><span class="line"><span class="comment"> *           is attached at the address given by </span></span><br><span class="line"><span class="comment"> *           (addr − (addr modulus SHMLBA))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">int</span> flag)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief detach the shared memory segment located at addr </span></span><br><span class="line"><span class="comment"> *        from the address space of the calling process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Unix/">Unix</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/f841.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">Pods</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/7793.html">
        <span class="next-text nav-default">Thread Control</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/4cb2.html';
  var disqus_title = "Interprocess Communication";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
