<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="Services"/>




  <meta name="keywords" content="K8s," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/1936.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/1936.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/1936.html"/>


<meta name="description" content="1. Introduction当我们使用pod时, 有些pod只需单独运行, 但有些pod需要响应外部请求. 在microservices中, pod之间通过HTTP请求相互通信. 在k8s之前, 应用在服务器上运行, 服务器之间的通信需要系统管理员手动配置每个服务器的IP地址或hostname, 但在k8s中不能为pod手动配置, 原因如下:  Pod生存周期短暂: pod会由于各种原因而随时消">
<meta property="og:type" content="article">
<meta property="og:title" content="Services">
<meta property="og:url" content="https://zaf1ro.github.io/p/1936.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. Introduction当我们使用pod时, 有些pod只需单独运行, 但有些pod需要响应外部请求. 在microservices中, pod之间通过HTTP请求相互通信. 在k8s之前, 应用在服务器上运行, 服务器之间的通信需要系统管理员手动配置每个服务器的IP地址或hostname, 但在k8s中不能为pod手动配置, 原因如下:  Pod生存周期短暂: pod会由于各种原因而随时消">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-1-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-1-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-1-3.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-2-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-3-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-3-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-3-3.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-3-4.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-4-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-4-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-5-1.png">
<meta property="article:published_time" content="2019-10-21T12:34:21.000Z">
<meta property="article:modified_time" content="2025-02-11T17:32:01.074Z">
<meta property="article:tag" content="K8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/Kubernetes/svc-1-1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
Services - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Introduction"><span class="toc-text">1. Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Create-Services"><span class="toc-text">1.1 Create Services</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-Remotely-Execute-Commands-in-Running-Containers"><span class="toc-text">1.1.1 Remotely Execute Commands in Running Containers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-Configure-Session-Affinity-on-the-Service"><span class="toc-text">1.1.2 Configure Session Affinity on the Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-Expose-Multiple-Ports-in-the-Same-Service"><span class="toc-text">1.1.3 Expose Multiple Ports in the Same Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-Use-Named-Ports"><span class="toc-text">1.1.4 Use Named Ports</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Discover-Services"><span class="toc-text">1.2 Discover Services</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-Discover-Services-through-Environment-Variables"><span class="toc-text">1.2.1 Discover Services through Environment Variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-Discover-Services-through-DNS"><span class="toc-text">1.2.2 Discover Services through DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-Run-a-Shell-in-a-Pod-s-Container"><span class="toc-text">1.2.3 Run a Shell in a Pod&#39;s Container</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Connect-to-services-living-outside-the-cluster"><span class="toc-text">2. Connect to services living outside the cluster</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Endpoints"><span class="toc-text">2.1 Endpoints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Manually-Configure-Service-Endpoints"><span class="toc-text">2.2 Manually Configure Service Endpoints</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Create-an-Alias-for-an-External-Service"><span class="toc-text">2.3 Create an Alias for an External Service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Expose-Services-to-External-Clients"><span class="toc-text">3. Expose Services to External Clients</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-NodePort"><span class="toc-text">3.1 NodePort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-LoadBalancer"><span class="toc-text">3.2 LoadBalancer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Summary-of-Service"><span class="toc-text">3.3 Summary of Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-The-Peculiarities-of-External-Connections"><span class="toc-text">3.3 The Peculiarities of External Connections</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Expose-Services-Externally-through-an-Ingress-Resource"><span class="toc-text">4. Expose Services Externally through an Ingress Resource</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Access-the-Service-through-the-Ingress"><span class="toc-text">4.1 Access the Service through the Ingress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Expose-Multiple-Services-through-the-Same-Ingress"><span class="toc-text">4.2 Expose Multiple Services through the Same Ingress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Configure-Ingress-to-handle-TLS-Traffic"><span class="toc-text">4.2 Configure Ingress to handle TLS Traffic</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Signal-when-a-Pod-is-Ready-to-Accept-Connections"><span class="toc-text">5. Signal when a Pod is Ready to Accept Connections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Add-a-Readiness-Probe-to-a-Pod"><span class="toc-text">5.1 Add a Readiness Probe to a Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-What-Readiness-Probe-Should-Do"><span class="toc-text">5.2 What Readiness Probe Should Do</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Headless-Service"><span class="toc-text">6. Headless Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Create-a-Headless-Service"><span class="toc-text">6.1 Create a Headless Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Discover-Pods-through-DNS"><span class="toc-text">6.2 Discover Pods through DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Discover-all-pods-that-aren-t-ready"><span class="toc-text">6.3 Discover all pods that aren&#39;t ready</span></a></li></ol></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Services
        
      </h1>
      <time class="post-time">
          10/21/19
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>当我们使用pod时, 有些pod只需单独运行, 但有些pod需要响应外部请求. 在microservices中, pod之间通过HTTP请求相互通信. 在k8s之前, 应用在服务器上运行, 服务器之间的通信需要系统管理员手动配置每个服务器的IP地址或hostname, 但在k8s中不能为pod手动配置, 原因如下:</p>
<ul>
<li>Pod生存周期短暂: pod会由于各种原因而随时消失或创建, 例如, 调整ReplicaSet的replica count</li>
<li>K8s会在<strong>分配pod到某个node</strong>和<strong>启动pod</strong>之间为pod分配IP地址, 因此client无法提前获知其IP地址</li>
<li>水平拓展导致多个pod具有相同功能: client不应关心有多少个pod提供了对应服务, 同功能的pod应共享一个IP地址</li>
</ul>
<p>为解决这些问题, k8s提供了名为<strong>Service</strong>的资源, 其可为cluster内的一组pod提供单一且不变的入口: service的IP地址和端口号不会改变. client向service发送请求时, 请求会被转发给其中一个pod, 因此client不必在意pod处于哪个node中, 或一共有几个pod.<br>假设现在有一个网站项目: 多个pod运行frontend, 单个pod运行backend. 该项目存在两个问题: </p>
<ul>
<li>client向frontend的某个pod发送请求</li>
<li>frontend接收到client请求后需要连接backend, 我们并不想在backend pod移动到其他node时重新配置frontend pod</li>
</ul>
<p>解决方案: 为frontend创建一个service, 并为backend创建一个service. 当pod的IP地址改变时, service的IP地址也不会改变, cluster中的任何资源都可通过service的IP地址或service的名字访问.<br><img src="/images/Kubernetes/svc-1-1.png" alt="Both internal and external clients usually connect to pods through services"></p>
<h3 id="1-1-Create-Services"><a href="#1-1-Create-Services" class="headerlink" title="1.1 Create Services"></a>1.1 Create Services</h3><p>我们现在有一个ReplicationController, 其中包含三个pod, service负责为所有pod提供一个统一入口.<br><img src="/images/Kubernetes/svc-1-2.png" alt="Label selectors determine which pods belong to the Service"></p>
<p>Service使用label selector选择pod. 以下是两种创建service的方式:</p>
<ol>
<li>执行<code>kubectl expose</code></li>
<li>创建YAML文件并执行<code>kubectl create</code>, <code>port</code>为service的端口号, <code>targetPort</code>为pod的端口号.</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span> </span><br></pre></td></tr></table></figure>

<p>执行<code>kubectl get svc</code>可查看当前cluster上的所有service:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME       CLUSTER-IP     EXTERNAL-IP PORT(S) AGE</span><br><span class="line">kubernetes 10.111.240.1   &lt;none&gt;      443/TCP 30d</span><br><span class="line">kubia      10.111.249.153 &lt;none&gt;      80/TCP  6m </span><br></pre></td></tr></table></figure>
<p>需要注意的是, service的cluster IP只是cluster内部IP地址, cluster外无法访问该IP地址. 以下是在cluster内测试test的几种方式:</p>
<ul>
<li>创建一个pod并向cluster IP发送请求, 查看pod日志来查看是否回复</li>
<li>通过ssh进入node, 执行curl向service发送请求</li>
<li>执行<code>kubectl exec</code>进入运行中的pod, 执行curl向service发送请求</li>
</ul>
<h4 id="1-1-1-Remotely-Execute-Commands-in-Running-Containers"><a href="#1-1-1-Remotely-Execute-Commands-in-Running-Containers" class="headerlink" title="1.1.1 Remotely Execute Commands in Running Containers"></a>1.1.1 Remotely Execute Commands in Running Containers</h4><p><code>kubectl exec</code>可实现在pod内的任意一个container中执行命令. 以下例子从名为<code>kubia-7nog1</code>的pod中执行curl, <code>10.111.249.153</code>为service的IP地址:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> kubia-7nog1 -- curl -s http://10.111.249.153</span><br><span class="line">You’ve hit kubia-gzwli</span><br></pre></td></tr></table></figure>
<p>Double dash(<code>--</code>)是kubectl的option, 可防止kubectl读取命令时将<code>--</code>后的命令当做kubectl的参数. 若不使用<code>--</code>, 则<code>-s</code>会被当作kubectl的参数. 以下是<code>kubectl exec</code>的执行流程:<br><img src="/images/Kubernetes/svc-1-3.png" alt="Using kubectl exec to test out a connection to the service by running curl in one of the pods"></p>
<h4 id="1-1-2-Configure-Session-Affinity-on-the-Service"><a href="#1-1-2-Configure-Session-Affinity-on-the-Service" class="headerlink" title="1.1.2 Configure Session Affinity on the Service"></a>1.1.2 Configure Session Affinity on the Service</h4><p>由于service转发请求时会随机挑选一个pod, 因此client每次请求时可能遇到不同pod. 若需要client的所有请求都发送给同一pod, 则需设置sessionAffinity属性:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>sessionAffinity只支持ClientIP和None(默认为None). 由于service不解析应用层, 因此无法支持基于cookie的session affinity, 只能通过IP地址进行load balance. 设置为ClientIP后, 即使同一个IP address下有多个client连接, 也只会连接到同一Pod.</p>
<h4 id="1-1-3-Expose-Multiple-Ports-in-the-Same-Service"><a href="#1-1-3-Expose-Multiple-Ports-in-the-Same-Service" class="headerlink" title="1.1.3 Expose Multiple Ports in the Same Service"></a>1.1.3 Expose Multiple Ports in the Same Service</h4><p>Service支持多个端口号. 当pod监听多个端口号时, service可设置对应端口号, 但需要注意的是, 每个端口号都需要指定名字:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span> </span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-Use-Named-Ports"><a href="#1-1-4-Use-Named-Ports" class="headerlink" title="1.1.4 Use Named Ports"></a>1.1.4 Use Named Ports</h4><p>上述例子需在Service的YAML文件中明确标注pod的端口号, 但如果我们在pod的YAML文件中为端口号命名, 则service的YAML文件中可直接使用端口号名.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">8443</span> </span><br></pre></td></tr></table></figure>
<p>即便pod修改其端口号, Service也不需要做任何修改:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">http</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="string">https</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-Discover-Services"><a href="#1-2-Discover-Services" class="headerlink" title="1.2 Discover Services"></a>1.2 Discover Services</h3><p>虽然service提供了一个稳定的IP地址和端口号, 但client如何获知Service的IP地址和端口号? 如果需要知道service的IP地址才能访问, 那么service必须在client前创建. K8s提供多种方式让client检测service的IP地址和端口号.</p>
<h4 id="1-2-1-Discover-Services-through-Environment-Variables"><a href="#1-2-1-Discover-Services-through-Environment-Variables" class="headerlink" title="1.2.1 Discover Services through Environment Variables"></a>1.2.1 Discover Services through Environment Variables</h4><p>当k8s启动pod时, 会在pod的environment variable(环境变量)中初始化所有service信息. 若client在service之后创建, 则client pod可通过环境变量访问service的IP地址和端口号. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> kubia-3inly -- <span class="built_in">env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kubia-3inly</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.111.240.1</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">...</span><br><span class="line">KUBIA_SERVICE_HOST=10.111.249.153</span><br><span class="line">KUBIA_SERVICE_PORT=80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>使用环境变量获取service的IP地址和端口号需注意以下几点:</p>
<ul>
<li>若pod的创建时间早于service, 则pod的环境变量中不包含该service</li>
<li>若pod的创建时间晚于service, 但pod创建后执行<code>kubectl edit</code>修改service, 则pod的环境变量不会包含修改后的service</li>
<li>关于service的环境变量命名规则如下:<ul>
<li>Service的环境变量全部为大写字符</li>
<li>Service的IP地址为<code>&lt;SVC_NAME&gt;_SERVICE_HOST</code></li>
<li>若service的YAML文件中未标注<code>ports.name</code>, 则service的端口号为<code>&lt;SVC_NAME&gt;_SERVICE_PORT</code></li>
<li>若service的YAML文件中标注<code>ports.name</code>, 则service的端口号为<code>&lt;SVC_NAME&gt;_SERVICE_PORT_&lt;PORT_NAME&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="1-2-2-Discover-Services-through-DNS"><a href="#1-2-2-Discover-Services-through-DNS" class="headerlink" title="1.2.2 Discover Services through DNS"></a>1.2.2 Discover Services through DNS</h4><p>名为<code>kube-system</code>的namespace中有一个pod名为<strong>kube-dns</strong>, 其作为一个DNS server负责将FQDN转换为IP地址. Cluster中其他pod都可通过该pod查询任何资源的IP地址(每个container的<code>/etc/resolv.conf</code>中包含kube-dns的地址), pod可通过设置<code>dnsPolicy</code>选择是否使用内部DNS解析. Service作为一种资源, 也会在kube-dns中保留一个DNS entry, client只需通过kube-dns查询service的FQDN即可获取其IP地址. 以backend database service为例, 其FQDN为:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">backend-database.default.svc.cluster.locals</span><br></pre></td></tr></table></figure>
<p><code>backend-database</code>为service的名字, <code>default</code>表示service所在的namespace, <code>svc</code>表示资源类型为service, <code>cluster.local</code>为所有cluster domain的后缀, 因此可以不写该后缀. 若frontend pod与backend pod处于同一namespace, 也可省略default, FQDN直接写<code>backend-database</code>即可. 同理, 每个pod也拥有各自的FQDN, 例如: <code>192-168-0-6.default.pod.cluster.local</code>, <code>192-168-0-6</code>表示pod的IP地址, <code>default</code>表示pod所在namespace, <code>pod</code>表示资源类型为pod, <code>cluster.local</code>则为默认后缀. 但由于client需要知道pod的IP地址才能访问域名, 与域名解析的初衷相悖, 因此通常会在pod的<code>spec.hostname</code>和<code>spec.subdomain</code>设置自定义域名.<br>通过内部DNS域名解析获取service的IP地址的优缺点如下:</p>
<ul>
<li>创建service时会自动在DNS server中注册DNS entry, 因此client不必在service之后创建</li>
<li>域名解析只能返回service的IP地址, 端口号仍需手动配置, 或从环境变量获取</li>
</ul>
<h4 id="1-2-3-Run-a-Shell-in-a-Pod-s-Container"><a href="#1-2-3-Run-a-Shell-in-a-Pod-s-Container" class="headerlink" title="1.2.3 Run a Shell in a Pod&#39;s Container"></a>1.2.3 Run a Shell in a Pod&#39;s Container</h4><p>直接进入pod后查看<code>/etc/resolv.conf</code>也可以看到FQDN</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> -it kubia-3inly bash</span><br><span class="line">root@kubia-3inly:/# <span class="built_in">cat</span> /etc/resolv.conf</span><br><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local ...</span><br></pre></td></tr></table></figure>
<p>需要注意的是, 我们无法ping该service的IP地址, 因为service的IP地址是一个虚拟地址, 只有同时使用service的IP地址和端口号时才会使用到service.</p>
<h2 id="2-Connect-to-services-living-outside-the-cluster"><a href="#2-Connect-to-services-living-outside-the-cluster" class="headerlink" title="2. Connect to services living outside the cluster"></a>2. Connect to services living outside the cluster</h2><p>上一节只提到了通过service与cluster内pod的通信, 但client也可以通过service与cluster外的服务通信.</p>
<h3 id="2-1-Endpoints"><a href="#2-1-Endpoints" class="headerlink" title="2.1 Endpoints"></a>2.1 Endpoints</h3><p>K8s中, service并不会直接与pod相连, 而是让endpoint作为中介. 若service包含label selector, k8s创建service时会自动创建对应的endpoints. Endpoint是k8s的一种资源, 其包含一个或多个IP地址和端口号, 负责将pod和service连接起来. 执行<code>kubectl describe svc</code>时会看到该service的endpoints:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl describe svc kubia</span><br><span class="line">Name: kubia</span><br><span class="line">Namespace: default</span><br><span class="line">Labels: &lt;none&gt;</span><br><span class="line">Selector: app=kubia</span><br><span class="line">Type: ClusterIP</span><br><span class="line">IP: 10.111.249.153</span><br><span class="line">Port: &lt;<span class="built_in">unset</span>&gt; 80/TCP</span><br><span class="line">Endpoints: 10.108.1.4:8080,10.108.2.5:8080,10.108.2.6:8080</span><br><span class="line">Session Affinity: None</span><br></pre></td></tr></table></figure>
<p>也可执行<code>kubectl get endpoints</code>直接读取service的endpoints:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get endpoints kubia</span><br><span class="line">NAME  ENDPOINTS                                       AGE</span><br><span class="line">kubia 10.108.1.4:8080,10.108.2.5:8080,10.108.2.6:8080 1h</span><br></pre></td></tr></table></figure>
<p>虽然service有label selector, 但并不会在转发请求时使用. 相反, selector由endpoint拥有. Service接收到了请求后, 会从endpoint中挑选一个IP地址和端口号, 并将请求转发给该地址.</p>
<h3 id="2-2-Manually-Configure-Service-Endpoints"><a href="#2-2-Manually-Configure-Service-Endpoints" class="headerlink" title="2.2 Manually Configure Service Endpoints"></a>2.2 Manually Configure Service Endpoints</h3><p>K8s之所以这样设计, 是为了将service与IP地址&#x2F;端口号分离, 允许用户手动配置地址. 因此为了手动配置endpoint, 可以创建一个没有label selector的service:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> </span><br></pre></td></tr></table></figure>
<p>Endpoint也可通过YAML文件创建. Endpoint的<code>metadata.name</code>必须与service同名, 并在<code>subsets</code>中指定IP地址和端口号.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> </span><br></pre></td></tr></table></figure>
<p>Service和endpoints创建完毕后, 之后创建的pod的环境变量中都包含service的IP地址和端口号.<br><img src="/images/Kubernetes/svc-2-1.png" alt="Pods consuming a service with two external endpoints"></p>
<p>若外部服务并入cluster中, 可给service添加label selector, k8s会自动更新service对应的endpoints; 若service已有label selector, 将selector移除后, k8s不会再更新endpoint, 这意味着service拥有的IP地址永远不会改变.</p>
<h3 id="2-3-Create-an-Alias-for-an-External-Service"><a href="#2-3-Create-an-Alias-for-an-External-Service" class="headerlink" title="2.3 Create an Alias for an External Service"></a>2.3 Create an Alias for an External Service</h3><p>手动配置endpoint让service将请求转发到外部服务虽然可行, 但若外部服务频繁变换地址, 每次变更都需手动更新; K8s提供了更简单的方法: service的<code>spec.type</code>默认为<code>ClusterIP</code>, 表示service只能从一组IP地址中选择一个转发请求; 若将service的<code>spec.type</code>设置为<code>ExternalName</code>, service会将请求转发给<code>spec.externalName</code>, 从而实现访问cluster外部服务.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">someapi.somecompany.com</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>K8s会为<code>ExternalName</code>类型的service创建一个CNAME DNS record. 当pod访问<code>external-service.default.svc.cluster.local</code>时, 请求会被转发给<code>someapi.somecompany.com</code>, 因此service也不需要cluster IP.</p>
<h2 id="3-Expose-Services-to-External-Clients"><a href="#3-Expose-Services-to-External-Clients" class="headerlink" title="3. Expose Services to External Clients"></a>3. Expose Services to External Clients</h2><p>前两节只讲到pod通过service向cluster内&#x2F;外的服务发送请求. 本节则着重于cluster外部服务通过service向pod发送请求. 例如: 为frontend webserver创建service, 从而让cluster外的client顺利访问frontend webserver.<br><img src="/images/Kubernetes/svc-3-1.png" alt="Exposing a service to external clients"></p>
<h3 id="3-1-NodePort"><a href="#3-1-NodePort" class="headerlink" title="3.1 NodePort"></a>3.1 NodePort</h3><p>当使用<code>NodePort</code>类型的service时, k8s会在每个node上保留一个端口号用于该service使用:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-nodeport</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30123</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
<p>该类型的service支持pod访问service的cluster IP, 也支持外部服务访问node的IP地址, 但两者访问的端口号不同:</p>
<ul>
<li>cluster IP对应<code>spec.ports.port</code></li>
<li>Node IP对应<code>spec.ports.nodePort</code></li>
</ul>
<p>当cluster外的client访问cluster中任意node的<code>nodePort</code>时, 都会被service转发到对应的pod, 从而实现cluster外client访问pod. 假设cluster中存在两个node, service如下:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc kubia-nodeport</span><br><span class="line">NAME           CLUSTER-IP     EXTERNAL-IP PORT(S)      AGE</span><br><span class="line">kubia-nodeport 10.111.254.223 &lt;nodes&gt;     80:30123/TCP 2m</span><br></pre></td></tr></table></figure>
<p>以下三种方式都可以访问该service:</p>
<ul>
<li>10.11.254.223:80</li>
<li>&lt;1st node&#39;s IP&gt;:30123</li>
<li>&lt;2nd node&#39;s IP&gt;:30123</li>
</ul>
<p><img src="/images/Kubernetes/svc-3-2.png" alt="An external client connecting to a NodePort service either through Node 1 or 2"></p>
<p>无论cluster外的client向哪个node发送请求, 只要访问端口号为30123, 都会被service转发给对应pod. 虽然client可以向任意node发送请求, 但需要注意的是, 若client发送请求的node不可用, 则请求不会被service处理, 因此通常会在node前使用load balancer, 以便所有请求都会发送给可用的node.</p>
<h3 id="3-2-LoadBalancer"><a href="#3-2-LoadBalancer" class="headerlink" title="3.2 LoadBalancer"></a>3.2 LoadBalancer</h3><p>K8s cluster通常运行在云服务提供商的云基础设施上, 绝大多数云服务提供商都提供load balancer. 将service的类型设置为LoadBalancer时, 云服务提供商会自动添加一个load balancer, 其拥有一个公有IP地址, 会将所有请求都转发给service. 因此client无需知道node的地址, 直接访问load balancer的IP地址即可与pod通信:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-loadbalancer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
<p>执行<code>kubectl create</code>后, 云服务提供商会创建一个load balancer, 并将其IP地址写入service的<code>status.loadBalancer</code>. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc kubia-loadbalancer</span><br><span class="line">NAME               CLUSTER-IP     EXTERNAL-IP    PORT(S)      AGE</span><br><span class="line">kubia-loadbalancer 10.111.241.153 130.211.53.173 80:32143/TCP 1m</span><br></pre></td></tr></table></figure>
<p>上例中, 130.211.53.173即为load balancer的公有IP地址.<br><img src="/images/Kubernetes/svc-3-3.png" alt="An external client connecting to a LoadBalancer service"></p>
<p>需要注意的是, LoadBalancer类型的service不再负责挑选pod, client会直接向load balancer发送请求, 并由load balancer选择pod. 由于浏览器会使用keep-alive connection, 而云服务提供商的load balancer通常支持基于cookie的负载均衡, 即便service的<code>sessionAffinity</code>为None, 一个连接内的请求也只会发送给同一个pod.<br>LoadBalancer类型的service也会在每个node上保留一个端口号, LoadBalancer可以说是NodePort的<strong>超集</strong>, 只是多提供了一个load balancer.</p>
<h3 id="3-3-Summary-of-Service"><a href="#3-3-Summary-of-Service" class="headerlink" title="3.3 Summary of Service"></a>3.3 Summary of Service</h3><p>K8s中的每个node都会运行一个<strong>kube-proxy</strong>, 其与API server保持连接, 确保service和endpoint始终处于最新状态, 并符合配置和管理node上的路由规则. Kube-proxy支持四种模式:</p>
<ul>
<li>iptables (default)</li>
<li>ipvs</li>
<li>userspace</li>
<li>kernelspace</li>
</ul>
<p>以下只讨论iptables模式下的k8s网络配置. 由于数据包的路由规则最终由node上的iptables决定, 因此三种不同类型的service的实现方式如下:</p>
<ul>
<li>ClusterIP: <ol>
<li>Pod中container产生的数据通过veth pair从container network namespace的网络接口流向node network namespace的docker0接口</li>
<li>在node network namespace中, 数据会在iptables的<code>nat</code> table中的<code>PREROUTING</code> chain中经过一系列跳转</li>
<li>k8s依赖iptables内核随机模块来实现负载均衡</li>
<li>使用DNAT将cluster ip转化为pod的ip address</li>
</ol>
</li>
<li>Node Port:<ol>
<li>数据包直接发送到k8s clsuter中的某个node, 在node network namespace的<code>PREROUTING</code> chain中匹配<code>KUBE-SERVICES</code></li>
<li>在<code>KUBE_SERVICES</code>中匹配<code>KUBE-NODEPORTS</code></li>
<li>在<code>KUBE-NODEPORTS</code>中根据端口号匹配<code>KUBE-SVC-XXX</code></li>
<li>后续与cluster ip类型相同</li>
</ol>
</li>
<li>Load Balancer:<ol>
<li>外部client向load balancer发送数据</li>
<li>load balancer接收到数据后通过某种复杂均衡算法将数据发送给k8s cluster中的某个node</li>
<li>后续与node port类型相同</li>
</ol>
</li>
</ul>
<h3 id="3-3-The-Peculiarities-of-External-Connections"><a href="#3-3-The-Peculiarities-of-External-Connections" class="headerlink" title="3.3 The Peculiarities of External Connections"></a>3.3 The Peculiarities of External Connections</h3><p>Service提供了两种外部client访问集群pod的方式:</p>
<ul>
<li>NodePort: client向node发送请求</li>
<li>LoadBalancer: client向load balancer发送请求, load balancer将请求转发给一个可用的node</li>
</ul>
<p>假设client发送的请求直接或被load balancer转发给node1, 而node1中并不存在对应的pod, 则node1会将请求的source IP address替换为自己的IP address, 并将destination IP address替换为pod的IP address, 并转发给对应的node(假设其名为node2). 此时会引发两个问题:</p>
<ul>
<li>node1每次收到请求时, 都需将请求转发给node2, 构成网络延迟</li>
<li>node2收到请求时, 请求的source IP address并不是client的IP address, 而是node1的IP address</li>
</ul>
<p>为解决上述问题, 可在service中配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">externalTrafficPolicy:</span> <span class="string">Local</span></span><br></pre></td></tr></table></figure>
<p>若client访问的node中没有对应pod, 则连接会被挂起, 而不是转发给其他node. 使用<code>externalTrafficPolicy</code>前需注意两点:</p>
<ul>
<li>由于node不会转发请求, 因此需保证client或load balancer将请求发送给拥有pod的node</li>
<li>由于node会自动平衡负载, 因此将<code>externalTrafficPolicy</code>设置为<code>Local</code>可能造成负载失衡, 如下图:<br><img src="/images/Kubernetes/svc-3-4.png" alt="A Service using the Local external traffic policy may lead to uneven load distribution across pods"></li>
</ul>
<p>若只是为了保留client的source IP address, 也可使用以下方案:</p>
<ul>
<li>对于HTTP应用, 可使用HTTP header中的<code>Forwarded</code>或<code>X-FORWARDED-FOR</code></li>
<li>使用proxy协议</li>
</ul>
<h2 id="4-Expose-Services-Externally-through-an-Ingress-Resource"><a href="#4-Expose-Services-Externally-through-an-Ingress-Resource" class="headerlink" title="4. Expose Services Externally through an Ingress Resource"></a>4. Expose Services Externally through an Ingress Resource</h2><p>LoadBalancer虽然解决了外部client如何访问pod的问题, 但由于load balancer需要一个公有IP地址, cluster中的service越多, 就需要越多的公有IP地址. K8s为此提供<strong>Ingress</strong>, Ingress只需一个公有IP地址, 由于Ingress在HTTP应用层操作, 可根据HTTP请求的host和path将请求转发给不同的service:<br><img src="/images/Kubernetes/svc-4-1.png" alt="Multiple services can be exposed through a single Ingresss"></p>
<p>以下是创建Ingress的YAML示例, 其中包含一条rule: 发送向kubia.example.com的请求会被转发给名为kubia-nodeport的service上的80端口</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-Access-the-Service-through-the-Ingress"><a href="#4-1-Access-the-Service-through-the-Ingress" class="headerlink" title="4.1 Access the Service through the Ingress"></a>4.1 Access the Service through the Ingress</h3><p>访问service前需得知Ingress的IP地址:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get ingresses</span><br><span class="line">NAME  HOSTS             ADDRESS        PORTS AGE</span><br><span class="line">kubia kubia.example.com 192.168.99.100 80    29m</span><br></pre></td></tr></table></figure>
<p>得知Ingress的IP地址后, 可让DNS server将该域名解析为Ingress的IP地址, 或在本地的<code>/etc/hosts</code>配置<code>192.168.99.100 kubia.example.com</code>. 向<code>kubia.example.com</code>发送请求时, 请求首先会被解析为Ingress的IP地址, Ingress根据域名选择对应的service, 并通过service对应的endpoint得知对应pod的IP地址, 并将请求转发给该pod的IP地址:<br><img src="/images/Kubernetes/svc-4-2.png" alt="Access pods through an Ingress"></p>
<h3 id="4-2-Expose-Multiple-Services-through-the-Same-Ingress"><a href="#4-2-Expose-Multiple-Services-through-the-Same-Ingress" class="headerlink" title="4.2 Expose Multiple Services through the Same Ingress"></a>4.2 Expose Multiple Services through the Same Ingress</h3><p>Ingress的rules和paths为数组, 因此可将多个host, path和service组合成不同情况:</p>
<ul>
<li>同一host下的多个path指定不同service:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/kubia</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/foo</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">bar</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li>
<li>不同host下的同一path指向不同service:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">spec:</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">foo.example.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">          <span class="attr">backend:</span></span><br><span class="line">            <span class="attr">serviceName:</span> <span class="string">foo</span></span><br><span class="line">            <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">bar.example.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">          <span class="attr">backend:</span></span><br><span class="line">            <span class="attr">serviceName:</span> <span class="string">bar</span></span><br><span class="line">            <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-Configure-Ingress-to-handle-TLS-Traffic"><a href="#4-2-Configure-Ingress-to-handle-TLS-Traffic" class="headerlink" title="4.2 Configure Ingress to handle TLS Traffic"></a>4.2 Configure Ingress to handle TLS Traffic</h3><p>为支持client与Ingress的加密通信, 需让Ingress支持TLS:</p>
<ol>
<li>创建private key和certificate:<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out tls.key 2048</span><br><span class="line">$ openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj /CN=kubia.example.com</span><br></pre></td></tr></table></figure></li>
<li>创建secret<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key</span><br><span class="line">secret <span class="string">&quot;tls-secret&quot;</span> created</span><br></pre></td></tr></table></figure></li>
<li>在Ingress中配置tls和secret<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">tls-secret</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-Signal-when-a-Pod-is-Ready-to-Accept-Connections"><a href="#5-Signal-when-a-Pod-is-Ready-to-Accept-Connections" class="headerlink" title="5. Signal when a Pod is Ready to Accept Connections"></a>5. Signal when a Pod is Ready to Accept Connections</h2><p>当pod被创建时, 若其带有service对用的label, 则会被纳入对用service的管理. 若pod需要一定时间初始化, 而service将client请求转发给该client, 则会发生异常情况, 因此K8s提出<strong>readiness probe</strong>来帮助service判断pod是否可以处理请求, readiness probe会定期检查pod, 但并不负责终止或重启pod. 与liveness probe相同, readiness probe也有三种类型:</p>
<ul>
<li>Exec probe: 在container中执行command, 检查exit status code</li>
<li>HTTP GET probe: 向container发送HTTP GET请求, 检查HTTP status code</li>
<li>TCP Socket probe: 向container的某一端口创建TCP连接, 检查是否成功创建连接</li>
</ul>
<p>假设一个service拥有3个pod, 其中一个pod的readiness probe探测失败, 则会将该pod从service中移除, 从而避免将外部请求转发给该pod.<br><img src="/images/Kubernetes/svc-5-1.png" alt="A pod whose readiness probe fails is removed as an endpoint of a service"></p>
<h3 id="5-1-Add-a-Readiness-Probe-to-a-Pod"><a href="#5-1-Add-a-Readiness-Probe-to-a-Pod" class="headerlink" title="5.1 Add a Readiness Probe to a Pod"></a>5.1 Add a Readiness Probe to a Pod</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">exec:</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ls</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/var/ready</span></span><br><span class="line">        <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>上述YAML文件中为每个pod中的container指定一个readiness probe. 该readiness probe会在pod创建后周期性执行ls &#x2F;var&#x2F;ready. 若&#x2F;var&#x2F;ready不存在, ls返回非零; 反之返回零.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME        READY STATUS  RESTARTS AGE</span><br><span class="line">kubia-53thy 0/1   Running 0        1m</span><br></pre></td></tr></table></figure>
<p>除此之外, readiness probe和liveness probe类似, 也拥有以下属性值:</p>
<ul>
<li>initialDelaySeconds</li>
<li>timeoutSeconds</li>
<li>periodSeconds</li>
</ul>
<h3 id="5-2-What-Readiness-Probe-Should-Do"><a href="#5-2-What-Readiness-Probe-Should-Do" class="headerlink" title="5.2 What Readiness Probe Should Do"></a>5.2 What Readiness Probe Should Do</h3><ul>
<li>为保证client的请求总会成功, 一定要在container中添加readiness probe来判断container是否能够或想要接受请求</li>
<li>若从service中移除某个pod, 可删除pod或修改pod的label</li>
<li>Readiness probe无需包含任何关于pod关闭的逻辑: 当pod被删除, service就立即将该pod移除.</li>
</ul>
<h2 id="6-Headless-Service"><a href="#6-Headless-Service" class="headerlink" title="6. Headless Service"></a>6. Headless Service</h2><p>Service解决了client与pod的通信问题, 但service只会随机选取一个pod与client通信, client无法连接service管理的所有pod. 为此k8s提供了<strong>headless service</strong>, 其不拥有任何IP地址, 因此查询service名时, DNS server会返回所有pod的IP地址, 而不是service的IP地址.</p>
<h3 id="6-1-Create-a-Headless-Service"><a href="#6-1-Create-a-Headless-Service" class="headerlink" title="6.1 Create a Headless Service"></a>6.1 Create a Headless Service</h3><p>创建一个<code>clusterIP</code>为<code>None</code>的Service:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia-headless</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-Discover-Pods-through-DNS"><a href="#6-2-Discover-Pods-through-DNS" class="headerlink" title="6.2 Discover Pods through DNS"></a>6.2 Discover Pods through DNS</h3><p>现在可执行DNS lookup来验证service是否返回pod IP地址, 但由于service中的kubia container不提供nslookup, 因此需要创建一个额外的pod:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl run dnsutils --image=tutum/dnsutils --generator=run-pod/v1 --<span class="built_in">command</span> -- <span class="built_in">sleep</span> infinity</span><br><span class="line">pod <span class="string">&quot;dnsutils&quot;</span> created</span><br></pre></td></tr></table></figure>
<p>接下来可使用该pod验证service是否返回pod的IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl <span class="built_in">exec</span> dnsutils nslookup kubia-headless</span><br><span class="line">...</span><br><span class="line">Name: kubia-headless.default.svc.cluster.local</span><br><span class="line">Address: 10.108.1.4</span><br><span class="line">Name: kubia-headless.default.svc.cluster.local</span><br><span class="line">Address: 10.108.2.5 </span><br></pre></td></tr></table></figure>
<p>上述例子中, headless service的FQDN为<code>kubia-headless.default.svc.cluster.local</code>, 并返回该service的两个pod的IP地址.</p>
<h3 id="6-3-Discover-all-pods-that-aren-t-ready"><a href="#6-3-Discover-all-pods-that-aren-t-ready" class="headerlink" title="6.3 Discover all pods that aren&#39;t ready"></a>6.3 Discover all pods that aren&#39;t ready</h3><p>若想让service展示所有管辖内的pod, 包括尚未准备就绪的pod, 可在创建service时使用alpha feature或<code>publishNotReadyAddresses</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">service.alpha.kubernetes.io/tolerate-unready-endpoints:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----- or -----</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">publishNotReadyAddresses:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">...</span></span><br></pre></td></tr></table></figure>


    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/K8s/">K8s</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/f56f.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">Volumes</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/17e0.html">
        <span class="next-text nav-default">Replication Controllers</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/1936.html';
  var disqus_title = "Services";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
