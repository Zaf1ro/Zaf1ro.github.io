<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="C++ Basic (2)"/>




  <meta name="keywords" content="Programming Language," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/d4cf.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/d4cf.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/d4cf.html"/>


<meta name="description" content="1. delete[]A *pA &#x3D; new A[5];delete pA;      &#x2F;&#x2F; 应写作delete []pA 上述代码调用了5次构造函数, 一次析构函数. 因为delete只会析构一个元素, 也就是数组第一个元素. 所以应调用delete[]来删除数组中的所有对象 2. for loopfor有两种语法:  for (init-statement condition; iterati">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Basic (2)">
<meta property="og:url" content="https://zaf1ro.github.io/p/d4cf.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. delete[]A *pA &#x3D; new A[5];delete pA;      &#x2F;&#x2F; 应写作delete []pA 上述代码调用了5次构造函数, 一次析构函数. 因为delete只会析构一个元素, 也就是数组第一个元素. 所以应调用delete[]来删除数组中的所有对象 2. for loopfor有两种语法:  for (init-statement condition; iterati">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/C/Basic/c-cpp-2-1.png">
<meta property="article:published_time" content="2017-09-09T18:41:09.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.047Z">
<meta property="article:tag" content="Programming Language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/C/Basic/c-cpp-2-1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
C++ Basic (2) - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-delete"><span class="toc-text">1. delete[]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-for-loop"><span class="toc-text">2. for loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-preprocessor"><span class="toc-text">3. preprocessor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Static-Binding"><span class="toc-text">4. Static Binding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-printf"><span class="toc-text">5. printf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Integral-Promotion"><span class="toc-text">6. Integral Promotion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Type-Size-in-32-bit-and-64-bit"><span class="toc-text">7. Type Size in 32-bit and 64-bit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Private-Destructor"><span class="toc-text">8. Private Destructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-const-reference"><span class="toc-text">9. const reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-const-and-decltype"><span class="toc-text">10. const and decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-pointer-of-array"><span class="toc-text">11. pointer of array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-constructor-destructor-and-virtual-function"><span class="toc-text">12. constructor, destructor, and virtual function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-reference-parameter"><span class="toc-text">13. reference parameter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-char"><span class="toc-text">14. char*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-volatile"><span class="toc-text">15. volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Unary-Operator"><span class="toc-text">16. Unary Operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-math-round"><span class="toc-text">17. math.round</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-scanf"><span class="toc-text">18. scanf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Virtual-method-table"><span class="toc-text">19. Virtual method table</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-bool"><span class="toc-text">20. bool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Preprocessor-Directive"><span class="toc-text">21. Preprocessor Directive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-constructor-copy-constructor-and-copy-assignment-operator"><span class="toc-text">22. constructor, copy constructor, and copy assignment operator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Multiple-Inheritance"><span class="toc-text">23. Multiple Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Pointer-Arithmetic-and-array-indexing"><span class="toc-text">24. Pointer Arithmetic and array indexing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Heap-Segment"><span class="toc-text">25. Heap Segment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Operator-Overloading"><span class="toc-text">26. Operator Overloading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-strcat"><span class="toc-text">27. strcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-cast"><span class="toc-text">28. cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-strcmp-return"><span class="toc-text">29. strcmp return:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-static-binding-of-default-parameter"><span class="toc-text">30. static binding of default parameter</span></a></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          C++ Basic (2)
        
      </h1>
      <time class="post-time">
          09/09/17
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-delete"><a href="#1-delete" class="headerlink" title="1. delete[]"></a>1. delete[]</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A *pA = <span class="keyword">new</span> A[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> pA;      <span class="comment">// 应写作delete []pA</span></span><br></pre></td></tr></table></figure>
<p>上述代码调用了5次构造函数, 一次析构函数. 因为delete只会析构一个元素, 也就是数组第一个元素. 所以应调用<code>delete[]</code>来删除数组中的所有对象</p>
<h2 id="2-for-loop"><a href="#2-for-loop" class="headerlink" title="2. for loop"></a>2. for loop</h2><p><code>for</code>有两种语法:</p>
<ul>
<li><code>for (init-statement condition; iteration-expression)</code></li>
<li><code>for (declaration-or-expression; declaration-or-expression; expression)</code></li>
</ul>
<p>上述所有expression和statement都是可选的, 也就是说, 特定情况下我们可选择不填写, 如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(expression1 ; ; expression2)</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(expression1 ; <span class="number">1</span> ; expression2)</span><br></pre></td></tr></table></figure>
<p>等同<code>while(true)</code>.</p>
<h2 id="3-preprocessor"><a href="#3-preprocessor" class="headerlink" title="3. preprocessor"></a>3. preprocessor</h2><ol>
<li><p>preprocessor directives<br>用于简化源程序在不同的执行环境中的更改和编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * #include, #using, #import, #error</span></span><br><span class="line"><span class="comment"> * #define, #undef  </span></span><br><span class="line"><span class="comment"> * #if, #else, #ifdef, #ifndef, #elif, #endif</span></span><br><span class="line"><span class="comment"> * #line, #pragma</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>preprocessor operators</p>
<ol>
<li>字符串化运算符(<code>#</code>)</li>
<li>字符化运算符(<code>#@</code>)</li>
<li>标记粘贴运算符(<code>##</code>)</li>
<li>自定义的运算符</li>
</ol>
</li>
<li><p>preprocessor macros</p>
<ol>
<li><code>__DATE__</code>: 当前的编译日期</li>
<li><code>__FILE__</code>: 当前源文件名</li>
<li><code>__LINE__</code>: 当前源代码行号</li>
<li><code>__STDC__</code>: 当要求程序严格遵循ANSI C标准时该标识被赋值为1</li>
<li><code>__STDCPP_THREADS__</code>: 多个线程的执行且为C++编译时赋值为1</li>
<li><code>__TIME__</code>: 当前编译时间</li>
</ol>
</li>
<li><p>pragmas: 设定编译器的状态或指示编译器做某些特定动作, 支持多种参数</p>
</li>
</ol>
<h2 id="4-Static-Binding"><a href="#4-Static-Binding" class="headerlink" title="4. Static Binding"></a>4. Static Binding</h2><p>对于非虚成员函数, C++采用静态绑定.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Do</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Do</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D *pD = <span class="keyword">new</span> <span class="built_in">D</span>();  <span class="comment">// pD的静态类型为D*, 动态类型也为D*</span></span><br><span class="line">B *pB = pD;       <span class="comment">// pB的静态类型为B*, 动态类型为D*</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>pD-&gt;Do()</code>和<code>pB-&gt;Do()</code>调用的是各自的函数, 因为绑定的静态类型不同</li>
<li>虚函数使用<strong>dynamic binding</strong>(动态绑定)确定调用哪个函数, 所以<code>pD-&gt;vfun()</code>和<code>pB-&gt;vfun()</code>相同, 都是调用的<code>D::vfun()</code></li>
</ul>
<h2 id="5-printf"><a href="#5-printf" class="headerlink" title="5. printf"></a>5. printf</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> k = <span class="number">0.8567</span>;</span><br><span class="line"><span class="comment">/* 0代表非零数字用0填充, 6代表最少占6位, 1代表小数点后保留1位 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%06.1f%&quot;</span>, k * <span class="number">100</span>);</span><br><span class="line"><span class="comment">// output: 0085.7%</span></span><br></pre></td></tr></table></figure>


<h2 id="6-Integral-Promotion"><a href="#6-Integral-Promotion" class="headerlink" title="6. Integral Promotion"></a>6. Integral Promotion</h2><p>执行表达式计算时(包括比较运算和算术运算等), 比int类型小的类型(char, signed char, unsigned char, short, unsigned short等)首先要提升为int类型, 再执行运算. 根据原始类型进行位扩展(如果原始类型为unsigned char, 进行零扩展, 如果原始类型为signed char, 进行符号位扩展)到32位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> a = <span class="number">0xe0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = a;   <span class="comment">// b = 0xffffffe0</span></span><br><span class="line"><span class="type">short</span> i = <span class="number">65537</span>;      <span class="comment">// i = 0000 0000 0000 0001, 高两位字节丢失</span></span><br><span class="line"><span class="type">int</span> j = i + <span class="number">1</span>;        <span class="comment">// j = 1+1 = 2</span></span><br></pre></td></tr></table></figure>
<p>a为signed char, a在内存中的位储存形式是0xe0, 把a赋值给b, 所以b在内存中的位储存形式也是0xe0. 然后把a提升到int类型, 提升后会变成0xffffffe0(符号位扩展)</p>
<h2 id="7-Type-Size-in-32-bit-and-64-bit"><a href="#7-Type-Size-in-32-bit-and-64-bit" class="headerlink" title="7. Type Size in 32-bit and 64-bit"></a>7. Type Size in 32-bit and 64-bit</h2><p>32位和64位系统中字节数相同的类型:</p>
<ol>
<li>char: 1个字节</li>
<li>short int: 2个字节</li>
<li>int: 4个字节</li>
<li>unsigned int: 4个字节</li>
<li>float: 4个字节</li>
<li>double: 8个字节</li>
<li>long long: 8个字节</li>
</ol>
<p>32位和64位系统中字节数不同的类型:</p>
<ol>
<li>pointer: 32位-4字节 64位-8字节</li>
<li>long: 32位-4字节, 64位-8字节</li>
<li>unsigned long: 32位-4字节, 64位-8字节</li>
</ol>
<h2 id="8-Private-Destructor"><a href="#8-Private-Destructor" class="headerlink" title="8. Private Destructor"></a>8. Private Destructor</h2><p>为类对象分配栈空间时, 会先检查析构函数的访问性. 如果类的析构函数是private, 则编译器不会在栈空间上为类对象分配内存. 因此将析构函数设为私有, 类对象就无法建立在栈上(直接创建对象), 只能在堆上(new Class)分配类对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ~<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a1;             <span class="comment">// error</span></span><br><span class="line">A* a2 = <span class="keyword">new</span> <span class="built_in">A</span>();  <span class="comment">// compile success</span></span><br></pre></td></tr></table></figure>


<h2 id="9-const-reference"><a href="#9-const-reference" class="headerlink" title="9. const reference"></a>9. const reference</h2><ul>
<li>非const引用只能绑定到该引用同类型的对象</li>
<li>const引用可绑定到不同但相关的对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; a2 = a1;          <span class="comment">// 非const同类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span>&amp; a3 = a1;  <span class="comment">// const非同类型</span></span><br><span class="line"><span class="type">float</span>&amp; a4 = a1;        <span class="comment">// error - 非const非同类型</span></span><br></pre></td></tr></table></figure>


<h2 id="10-const-and-decltype"><a href="#10-const-and-decltype" class="headerlink" title="10. const and decltype"></a>10. const and decltype</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decltype保留const关键字</span></span><br><span class="line"><span class="keyword">decltype</span>(x) a;      <span class="comment">// a为int类型</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = <span class="number">3</span>;  <span class="comment">// b为const int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双括号将类型变为引用, 保留const</span></span><br><span class="line"><span class="keyword">decltype</span>((x)) c = x;  <span class="comment">// c为int&amp;类型</span></span><br><span class="line"><span class="keyword">decltype</span>((y)) d = b;  <span class="comment">// d为const int&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p指针是解引用操作, 所以变为引用类型</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) e = x;   <span class="comment">// e为int&amp;类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto不保留const关键字</span></span><br><span class="line"><span class="keyword">auto</span> n = x;   <span class="comment">// n为int类型</span></span><br><span class="line"><span class="keyword">auto</span> m = y;   <span class="comment">// m为int类型</span></span><br></pre></td></tr></table></figure>


<h2 id="11-pointer-of-array"><a href="#11-pointer-of-array" class="headerlink" title="11. pointer of array"></a>11. pointer of array</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> str1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> str2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, str1); <span class="comment">// f7c48a20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, str2); <span class="comment">// f7c48a30</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, p1);   <span class="comment">// 68cb6948</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, p2);   <span class="comment">// 68cb6948</span></span><br></pre></td></tr></table></figure>
<p>str1和str2都是数组指针, 存在常量区, 所以指针地址不同. p1和p2存在栈中, 虽然p1和p2的值不同, 但指向的都是同一块静态存储区.</p>
<h2 id="12-constructor-destructor-and-virtual-function"><a href="#12-constructor-destructor-and-virtual-function" class="headerlink" title="12. constructor, destructor, and virtual function"></a>12. constructor, destructor, and virtual function</h2><p>对于constructor:</p>
<ol>
<li>constructor不能声明为virtual function: virtual function需在调用constructor时创建vtable来实现动态绑定; 若constructor为virtual function时, 调用constructor时没有vtable根据类对象类型调用, 因此无法通过编译.</li>
<li>base class的constructor中不能调用virtual function: 当创建derived class的对象时, 若base class的constructor中使用virtual function, 由于derived class的构constructor的constructor还未执行完毕, 因此virtual function可能会操作还未初始化的成员.<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;virtual A&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>() &#123;</span><br><span class="line">    <span class="built_in">func</span>();   <span class="comment">// 调用A::func()</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;virtual B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A *b = <span class="keyword">new</span> <span class="built_in">B</span>(); <span class="comment">/* virtual A</span></span><br><span class="line"><span class="comment">                 * A()</span></span><br><span class="line"><span class="comment">                 * B()</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">b-&gt;<span class="built_in">func</span>();  <span class="comment">/* virtual B */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于destructor:</p>
<ol>
<li>base class的destructor中不能调用virtual function: destructor的执行顺序和constructor相反. C++会先销毁derived class, 再销毁base class. 当调用base class的virtual function时, 会先调用derived class的绑定函数, 但由于dervied class已被销毁, 因此会导致不可控结果</li>
<li>base class的destructor应声明为virtual function: 当base class的destructor声明为virtual function时, 若指向base class的指针调用<code>delete</code>, 会先销毁derived class, 再销毁base class. 当base class的destructor不为virtual function时, 若指向base class的指针调用<code>delete</code>, 只会销毁base class, 不会销毁derived class.</li>
</ol>
<h2 id="13-reference-parameter"><a href="#13-reference-parameter" class="headerlink" title="13. reference parameter"></a>13. reference parameter</h2><p>实参可以是任何类型(常量, 变量或表达式), 形参不能是表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get1</span><span class="params">(<span class="type">char</span> *p)</span> </span>&#123;        <span class="comment">// p的地址并不与str相同, 但都指向NULL</span></span><br><span class="line">  p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  <span class="comment">// p拥有内存地址(str地址不变, 仍为0x0), 指向一个新空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get2</span><span class="params">(<span class="type">char</span>*&amp; p)</span> </span>&#123;       <span class="comment">// p的地址与str相同, 也指向NULL</span></span><br><span class="line">  p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  <span class="comment">// p拥有内存地址(str地址也变为p的地址), 指向一个新空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span>* str = <span class="literal">NULL</span>; <span class="comment">// 赋值为NULL的str地址为0x0, 没有分配内存地址</span></span><br><span class="line">  <span class="built_in">get1</span>(str);        <span class="comment">// str地址未变</span></span><br><span class="line">  <span class="built_in">get2</span>(str);        <span class="comment">// str地址改变</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="14-char"><a href="#14-char" class="headerlink" title="14. char*"></a>14. char*</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s1;        <span class="comment">// s1未初始化, 所以地址不确定(野指针), 会导致错误</span></span><br><span class="line"><span class="type">char</span> *s2 = <span class="literal">NULL</span>; <span class="comment">// s2初始化过, 赋值为NULL, 所以指向0x0</span></span><br></pre></td></tr></table></figure>


<h2 id="15-volatile"><a href="#15-volatile" class="headerlink" title="15. volatile"></a>15. volatile</h2><p>多线程中, 当多个线程修改和访问同一变量时, 会导致线程读取的变量可能已经被其他线程修改. 这主要是因为多线程中, 每个CPU会将变量装入CPU register中. 这样导致某个线程修改了变量后, 另一个线程由于没有去内存中同步变量, 而是直接从CPU register中读取, 从而使得线程不安全(因为从register直接读取会加快指令的执行速度).<br>volatile关键字让编译器取消优化, 每次读取变量都会从内存重新读取到CPU register中, 而不是使用register中的原来值, 从而使得线程安全.</p>
<h2 id="16-Unary-Operator"><a href="#16-Unary-Operator" class="headerlink" title="16. Unary Operator"></a>16. Unary Operator</h2><p>由于<code>++</code>和<code>--</code>有前缀和后缀两种形式, 后缀形式需添加一个int参数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> b): <span class="built_in">a</span>(b) &#123;&#125;</span><br><span class="line">  <span class="type">int</span> <span class="keyword">operator</span>++() &#123; <span class="comment">// 前置一元运算符</span></span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">// 后置一元运算符</span></span><br><span class="line">    a--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>operator++(int)</code>中的<code>int</code>是个哑元(dummy), 是永远用不上的, 它只是用来判断运算符是prefix还是postfix. </p>
<h2 id="17-math-round"><a href="#17-math-round" class="headerlink" title="17. math.round"></a>17. math.round</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">long</span> <span class="title">round</span><span class="params">(<span class="type">double</span> a)</span></span>; <span class="comment">// 返回值为long</span></span><br></pre></td></tr></table></figure>
<p>math.round遵守四舍五入. 可以把int数值想象成数轴</p>
<ol>
<li><code>&lt; 0.5</code>: 变为0, 趋向于原点</li>
<li><code>&gt;= 0.5</code>: 变为1&#x2F;-1, 远离原点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">round</span>(<span class="number">0.4</span>) &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">round</span>(<span class="number">0.5</span>) &lt;&lt; endl;   <span class="comment">// 11</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">round</span>(<span class="number">-0.4</span>) &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">round</span>(<span class="number">-0.5</span>) &lt;&lt; endl;  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>


<h2 id="18-scanf"><a href="#18-scanf" class="headerlink" title="18. scanf"></a>18. scanf</h2><p>space(空格), newline(换行)和tab(制表符)都可以用来分割(也可以是连续的空格, 换行或制表符). 逗号不能分割</p>
<h2 id="19-Virtual-method-table"><a href="#19-Virtual-method-table" class="headerlink" title="19. Virtual method table"></a>19. Virtual method table</h2><p>虚函数表的指针位置取决于编译器, C++标准中并没有明确规定. 但对于绝大多数编译器来说, 都会放在类的头部.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;       <span class="comment">// 在类的头部放置一个4字节的虚函数表指针</span></span><br><span class="line">  <span class="built_in">Test</span>(<span class="type">int</span> temp1 = <span class="number">0</span>, <span class="type">int</span> temp2 = <span class="number">0</span>) &#123;</span><br><span class="line">    a = temp1 ;</span><br><span class="line">    b = temp2 ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Test <span class="title">obj</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="type">int</span> *pInt = (<span class="type">int</span>*)&amp;obj;</span><br><span class="line">  *(pInt<span class="number">+0</span>) = <span class="number">100</span>;  <span class="comment">// 修改了虚函数表的指针值</span></span><br><span class="line">  *(pInt<span class="number">+1</span>) = <span class="number">200</span>;  <span class="comment">// 修改了类成员变量a的值</span></span><br><span class="line">  cout &lt;&lt; obj.a;    <span class="comment">// 200</span></span><br><span class="line">  cout &lt;&lt; obj.b;    <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="20-bool"><a href="#20-bool" class="headerlink" title="20. bool"></a>20. bool</h2><p>C语言中没有bool类型, 可用int代替. C++才有bool类型</p>
<h2 id="21-Preprocessor-Directive"><a href="#21-Preprocessor-Directive" class="headerlink" title="21. Preprocessor Directive"></a>21. Preprocessor Directive</h2><p>编译预处理与函数调用无关, 所在的位置决定作用域. main函数之后的预处理不会影响到main函数, main函数前定义的预处理会作用到main函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中foo()函数没有影响a的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> a 50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;      <span class="comment">// 50</span></span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;      <span class="comment">// 50</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中foo()函数在没有调用前就改变了a的值</p>
<h2 id="22-constructor-copy-constructor-and-copy-assignment-operator"><a href="#22-constructor-copy-constructor-and-copy-assignment-operator" class="headerlink" title="22. constructor, copy constructor, and copy assignment operator"></a>22. constructor, copy constructor, and copy assignment operator</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor is called...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy Constructor is called...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy Assignment Operator is called...&quot;</span> &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A* a;</span><br><span class="line">  A* b = <span class="literal">NULL</span>;</span><br><span class="line">  A* c = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// &#x27;Constructor is called...&#x27;</span></span><br><span class="line">  A d;            <span class="comment">// &#x27;Constructor is called...&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="function">A <span class="title">e</span><span class="params">(d)</span></span>;  <span class="comment">// &#x27;Copy Constructor is called...&#x27;</span></span><br><span class="line">  d = e;   <span class="comment">// &#x27;Copy Assignment Operator is called...&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="23-Multiple-Inheritance"><a href="#23-Multiple-Inheritance" class="headerlink" title="23. Multiple Inheritance"></a>23. Multiple Inheritance</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A::f()&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::g()&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;C::g()&quot;</span>; &#125;  <span class="comment">// 覆盖B::g()</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C::h()&quot;</span>;</span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 多继承导致f()产生了二义性, error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="24-Pointer-Arithmetic-and-array-indexing"><a href="#24-Pointer-Arithmetic-and-array-indexing" class="headerlink" title="24. Pointer Arithmetic and array indexing"></a>24. Pointer Arithmetic and array indexing</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">seta</span><span class="params">(A* data, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">  data[idx].a = <span class="number">2</span>;  <span class="comment">// 由于传入的单位为A*, 所以data的长度为4, 而不是8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B data[<span class="number">4</span>];  <span class="comment">// data中单个元素的长度为8字节</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    data[i].a = <span class="number">1</span>;</span><br><span class="line">    data[i].b = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">seta</span>(data, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; data[i].a &lt;&lt; data[i].b;       <span class="comment">// 22221111</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个for循环的执行如下:</p>
<ol>
<li>赋值: [0]a&#x3D;1, [0]b&#x3D;1, seta(): [0]a&#x3D;2</li>
<li>赋值: [1]a&#x3D;1, [1]b&#x3D;1, seta(): [0]b&#x3D;2</li>
<li>赋值: [2]a&#x3D;1, [2]b&#x3D;1, seta(): [1]a&#x3D;2</li>
<li>赋值: [3]a&#x3D;1, [3]b&#x3D;1, seta(): [1]b&#x3D;2</li>
</ol>
<h2 id="25-Heap-Segment"><a href="#25-Heap-Segment" class="headerlink" title="25. Heap Segment"></a>25. Heap Segment</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, b, c);  <span class="comment">// 1 0 2</span></span><br></pre></td></tr></table></figure>
<p>a, b, c各占8个字节, 但读取a,b,c时每个元素只读取四字节, 所以先读了a低字节的32位(1), b读取的是a的高字节32位(0), c读取的是b的低字节32位(2).<br><img src="/images/C/Basic/c-cpp-2-1.png" alt="25.1"></p>
<h2 id="26-Operator-Overloading"><a href="#26-Operator-Overloading" class="headerlink" title="26. Operator Overloading"></a>26. Operator Overloading</h2><ol>
<li>单目运算符最好重载为类的成员函数, 双目运算符则最好重载为类的友元函数</li>
<li>&#x3D;、()、[]、-&gt;、new、delete, 这些操作符必须为成员函数</li>
</ol>
<h2 id="27-strcat"><a href="#27-strcat" class="headerlink" title="27. strcat"></a>27. strcat</h2><p><code>strcat()</code>要求第一个参数类型为<code>char*</code>, 且有足够的空间容纳两个字符串. 常量字符串虽然可以隐式转换为<code>char*</code>, 但字符串的内存大小固定, 无法扩充</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* p1 = <span class="string">&quot;123&quot;</span>, p2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(p1, p2);</span><br></pre></td></tr></table></figure>


<h2 id="28-cast"><a href="#28-cast" class="headerlink" title="28. cast"></a>28. cast</h2><ol>
<li>const_cast: 去除或添加指针或引用上的const或volatile关键字<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);    <span class="comment">// *a为1</span></span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(a); <span class="comment">// 将const int*转换为int*</span></span><br><span class="line">*b = <span class="number">2</span>;  <span class="comment">// *a为2</span></span><br></pre></td></tr></table></figure></li>
<li>static_cast: 执行一次显式类型转换, 可将基类指针转换为子类指针, 也可将enums转换为数值类型. 由于编译器会在运行static_cast时检查兼容性, 所以会保证类型转换是安全的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0x0001</span>;</span><br><span class="line"><span class="type">int</span>* b = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(a);  <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure></li>
<li>dynamic_cast: 只能用于多态中类的转换, 但不能用于钻石继承中的类转换, 或虚继承的类转换<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A* aa = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">  B* b = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(aa);</span><br><span class="line"></span><br><span class="line">  B* bb = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">  A* a = <span class="built_in">dynamic_cast</span>&lt;A*&gt;(bb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>reinterpret_cast<ol>
<li>任意指针或引用类型之间的转换</li>
<li>指针与足够大的整数类型之间的转换</li>
<li>从整数类型(包括枚举类型)到指针类型的转换</li>
</ol>
</li>
</ol>
<h2 id="29-strcmp-return"><a href="#29-strcmp-return" class="headerlink" title="29. strcmp return:"></a>29. strcmp return:</h2><ul>
<li><code>&lt; 0</code>: 第一个string小</li>
<li><code>&gt; 0</code>: 第二个string小</li>
<li><code>0</code>: 两个string相等</li>
</ul>
<h2 id="30-static-binding-of-default-parameter"><a href="#30-static-binding-of-default-parameter" class="headerlink" title="30. static binding of default parameter"></a>30. static binding of default parameter</h2><p>virtual function是动态绑定, 但缺省参数值是静态绑定</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val = <span class="number">1</span>)</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> val = <span class="number">0</span>)</span> </span>&#123; <span class="comment">// 虽然重写了缺省参数值, 但并不会动态绑定</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B *p = <span class="keyword">new</span> B;</span><br><span class="line">  p-&gt;<span class="built_in">test</span>();  <span class="comment">// 输出&quot;B-&gt;1&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Programming-Language/">Programming Language</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/44ce.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">C++ Basic (3)</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/24cf.html">
        <span class="next-text nav-default">C++ Basic (1)</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/d4cf.html';
  var disqus_title = "C++ Basic (2)";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
