<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="Java Basic (1)"/>




  <meta name="keywords" content="Programming Language," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/4093.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/4093.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/4093.html"/>


<meta name="description" content="1. Type Conversion以下类型转换可能导致的数据丢失:  int -&gt; float long -&gt; float long -&gt; double  以下为不丢失数据的类型转换:    被转换类型 转换类型 转换后类型    byte, short, char int int   byte, short, char, int long long   byte, short">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Basic (1)">
<meta property="og:url" content="https://zaf1ro.github.io/p/4093.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. Type Conversion以下类型转换可能导致的数据丢失:  int -&gt; float long -&gt; float long -&gt; double  以下为不丢失数据的类型转换:    被转换类型 转换类型 转换后类型    byte, short, char int int   byte, short, char, int long long   byte, short">
<meta property="og:locale">
<meta property="article:published_time" content="2017-10-22T20:00:16.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.048Z">
<meta property="article:tag" content="Programming Language">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
Java Basic (1) - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Type-Conversion"><span class="toc-text">1. Type Conversion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-String-Concatenation"><span class="toc-text">2. String Concatenation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Iterate-over-an-array"><span class="toc-text">3. Iterate over an array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Static-Block"><span class="toc-text">4. Static Block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-toString"><span class="toc-text">5. toString()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Wrapper"><span class="toc-text">6. Wrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-primitive-type-and-wrapper-class"><span class="toc-text">6.1 primitive type and wrapper class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-autoboxing-and-unboxing"><span class="toc-text">6.2 autoboxing and unboxing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Type-Erasure"><span class="toc-text">7. Type Erasure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Thread-Safe-Collections"><span class="toc-text">8. Thread-Safe Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Postfix-Increment"><span class="toc-text">9. Postfix Increment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-final"><span class="toc-text">10. final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-parameter-and-argument"><span class="toc-text">11. parameter and argument</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Round-Number"><span class="toc-text">12. Round Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Synchronizer"><span class="toc-text">13. Synchronizer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-monitor"><span class="toc-text">14. monitor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-try-catch"><span class="toc-text">15. try-catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-finally"><span class="toc-text">16. finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-ThreadLocal"><span class="toc-text">17. ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Method-Signature"><span class="toc-text">18. Method Signature</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-and"><span class="toc-text">19. &gt;&gt; and &gt;&gt;&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Implicit-Type-Casting"><span class="toc-text">20. Implicit Type Casting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Integer-and"><span class="toc-text">21. Integer and &#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-volatile"><span class="toc-text">22. volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Collection-and-Map"><span class="toc-text">23. Collection and Map</span></a></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Java Basic (1)
        
      </h1>
      <time class="post-time">
          10/22/17
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Type-Conversion"><a href="#1-Type-Conversion" class="headerlink" title="1. Type Conversion"></a>1. Type Conversion</h2><p>以下类型转换可能导致的数据丢失:</p>
<ol>
<li>int -&gt; float</li>
<li>long -&gt; float</li>
<li>long -&gt; double</li>
</ol>
<p>以下为不丢失数据的类型转换:</p>
<table>
<thead>
<tr>
<th>被转换类型</th>
<th>转换类型</th>
<th>转换后类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte, short, char</td>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>byte, short, char, int</td>
<td>long</td>
<td>long</td>
</tr>
<tr>
<td>byte, short, char, int, long</td>
<td>float</td>
<td>float</td>
</tr>
<tr>
<td>byte, short, char, int, long, float</td>
<td>double</td>
<td>double</td>
</tr>
</tbody></table>
<h2 id="2-String-Concatenation"><a href="#2-String-Concatenation" class="headerlink" title="2. String Concatenation"></a>2. String Concatenation</h2><ol>
<li>拼接静态字符串时, 尽量使用<code>+</code>, 因为编译器会自动优化为长字符串  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;this &quot;</span> + <span class="string">&quot;is &quot;</span> + <span class="string">&quot;a &quot;</span> + <span class="string">&quot;test &quot;</span> + <span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="comment">/* 编译器优化为: String test = &quot;this is a test string&quot; */</span></span><br></pre></td></tr></table></figure></li>
<li>拼接动态字符串时, 可使用<code>StrinBuilder.append()</code>, 避免使用<code>+</code>.  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">test.append(<span class="string">&quot;this &quot;</span>);</span><br><span class="line">test.append(<span class="string">&quot;is &quot;</span>);</span><br><span class="line">test.append(<span class="string">&quot;a &quot;</span>);</span><br><span class="line">test.append(<span class="string">&quot;test &quot;</span>);</span><br><span class="line">test.append(<span class="string">&quot;string&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-Iterate-over-an-array"><a href="#3-Iterate-over-an-array" class="headerlink" title="3. Iterate over an array"></a>3. Iterate over an array</h2><ol>
<li>for  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 需要知道数组大小 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>for-each  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 需要知道数组的元素类型 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> val: arr)&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>iterator  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 避免了不同Collections取出元素方式的不同 */</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> arr.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> itr.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-Static-Block"><a href="#4-Static-Block" class="headerlink" title="4. Static Block"></a>4. Static Block</h2><p>static block内的变量或语句与类对象无关, 并在加载类时初始化static block, 所有static variable和static block按照定义顺序执行, 默认初始值为0, false, 或null. static block与classloader绑定, 如果两个程序使用不同的classloader, 则他们拥有两个互相独立的静态域.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-toString"><a href="#5-toString" class="headerlink" title="5. toString()"></a>5. toString()</h2><ol>
<li>调用<code>toString()</code>可获得对象的字符串  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;  <span class="comment">/* Object中toString()的定义 */</span></span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>toString()</code>会在某些情况下隐式调用(类对象与字符串用<code>+</code>连接, 或<code>System.out.print()</code>参数为类对象)  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;     <span class="comment">/* System.out.println()的定义 */</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    print(s);</span><br><span class="line">    newLine();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span> &#123;  <span class="comment">/* String.valueOf()的定义 */</span></span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="literal">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString(); <span class="comment">/* 使用了toString() */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>对象可重载Object的<code>toString()</code>, 例如<code>StringBuilder.toString()</code>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>数组不支持toString(), 必须调用静态函数Arrays.toString()  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Arrays.toString()的定义 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] a)</span> &#123; <span class="comment">/* 通过重载实现数组的所有元素类型 */</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="comment">/* 检查null和空数组 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">iMax</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">/* 使用StringBuilder */</span></span><br><span class="line">  b.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">    b.append(a[i]); <span class="comment">/* 数组元素类型为Object时改为: b.append(String.valueOf(a[i])); */</span></span><br><span class="line">    <span class="keyword">if</span> (i == iMax)</span><br><span class="line">      <span class="keyword">return</span> b.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">    b.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-Wrapper"><a href="#6-Wrapper" class="headerlink" title="6. Wrapper"></a>6. Wrapper</h2><h3 id="6-1-primitive-type-and-wrapper-class"><a href="#6-1-primitive-type-and-wrapper-class" class="headerlink" title="6.1 primitive type and wrapper class"></a>6.1 primitive type and wrapper class</h3><table>
<thead>
<tr>
<th>Primitive Data Type</th>
<th>Wrapper Class</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h3 id="6-2-autoboxing-and-unboxing"><a href="#6-2-autoboxing-and-unboxing" class="headerlink" title="6.2 autoboxing and unboxing"></a>6.2 autoboxing and unboxing</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">/* Autoboxing: primitive to Character object conversion */</span></span><br><span class="line"><span class="type">Character</span> <span class="variable">c2</span> <span class="operator">=</span> c1;</span><br></pre></td></tr></table></figure>
<p>wrapper class不能进行<code>==</code>操作, 因为比较的是两个对象的内存地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* [-128 - 127]内的数字相同, 区间之外的数字不相同, 这与Java的内存管理有关 */</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">/* false */</span></span><br></pre></td></tr></table></figure>


<h2 id="7-Type-Erasure"><a href="#7-Type-Erasure" class="headerlink" title="7. Type Erasure"></a>7. Type Erasure</h2><p><code>List&lt;Integer&gt;</code>和<code>List&lt;String&gt;</code>编译后都会成为<code>List</code>, JVM只会看到List, 并不会看到类型信息, 因为所有元素类型都会擦除为<code>Object</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arr1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arr1.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">ArrayList&lt;Integer&gt; arr2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arr2.add(<span class="number">123</span>);</span><br><span class="line">arr1.getClass() == arr2.getClass(); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
<p>定义元素类型是为了向Collection中加入元素时检查类型. 若定义Collection时不标明元素类型, 则编译器不会进行类型检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">arr.add(<span class="string">&quot;abc&quot;</span>); <span class="comment">/* unchecked call to add(E) */</span></span><br><span class="line">arr.add(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>


<h2 id="8-Thread-Safe-Collections"><a href="#8-Thread-Safe-Collections" class="headerlink" title="8. Thread-Safe Collections"></a>8. Thread-Safe Collections</h2><ol>
<li>Vector(ArrayList线程不安全)</li>
<li>Stack</li>
<li>HashTable(HashMap线程不安全)</li>
<li>Enumeration</li>
<li>StringBuffer(StringBuilder线程不安全)</li>
<li>Properties</li>
</ol>
<h2 id="9-Postfix-Increment"><a href="#9-Postfix-Increment" class="headerlink" title="9. Postfix Increment"></a>9. Postfix Increment</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = i++;</span><br><span class="line">System.out.println(i); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>其中, <code>i = i++</code>相当于以下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> i;</span><br><span class="line">i++;</span><br><span class="line">i = tmp;</span><br></pre></td></tr></table></figure>


<h2 id="10-final"><a href="#10-final" class="headerlink" title="10. final"></a>10. final</h2><p>使用<code>final</code>关键字修饰引用时, 是指引用变量不可变, 引用所指向的对象中还是可变的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">char</span>[] a = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span>[] b = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// a = b;   // error, 引用不可改</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>; <span class="comment">// 引用指向的内容可改</span></span><br></pre></td></tr></table></figure>


<h2 id="11-parameter-and-argument"><a href="#11-parameter-and-argument" class="headerlink" title="11. parameter and argument"></a>11. parameter and argument</h2><p>函数传递的是参数的拷贝:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 形参x和y为a和b的引用拷贝 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">operate</span><span class="params">(StringBuffer x, StringBuffer y)</span> &#123;</span><br><span class="line">  x.append(y); <span class="comment">/* x指向的StringBuffer变为&quot;AB&quot; */</span></span><br><span class="line">  y = x;       <span class="comment">/* 改变了y, 未改变b */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">operate(a, b);</span><br><span class="line"><span class="comment">// a: AB, b: B</span></span><br></pre></td></tr></table></figure>


<h2 id="12-Round-Number"><a href="#12-Round-Number" class="headerlink" title="12. Round Number"></a>12. Round Number</h2><p>Java有三种取整方式:</p>
<ul>
<li><code>Math.floor(double d)</code>: 小于或等于d的最大整数</li>
<li><code>Math.ceil(double d)</code>: 大于或等于d的最小整数</li>
<li><code>Math.round(double d)</code>: 最接近d的整数</li>
</ul>
<p><code>round()</code>需注意正负值:</p>
<ul>
<li><code>d &gt; 0</code>: <ul>
<li>小数点后一位的值为<code>[0, 4]</code>, d向下取整</li>
<li>小数点后一位的值为<code>[5, 9]</code>, d向上取整</li>
</ul>
</li>
<li><code>d &lt; 0</code>: <ul>
<li>小数点后一位的值为<code>[0, 5]</code>, d向上取整</li>
<li>小数点后一位的值为<code>[6, 9]</code>, d向下取整</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.floor(-<span class="number">4.2</span>);   <span class="comment">// -5.0</span></span><br><span class="line">Math.floor(<span class="number">4.6</span>);    <span class="comment">// 4.0</span></span><br><span class="line">Math.ceil(-<span class="number">4.6</span>);    <span class="comment">// -4.0</span></span><br><span class="line">Math.ceil(<span class="number">4.2</span>);     <span class="comment">// 5.0</span></span><br><span class="line">Math.round(<span class="number">0.4</span>);    <span class="comment">// 0</span></span><br><span class="line">Math.round(<span class="number">0.5</span>);    <span class="comment">// 1</span></span><br><span class="line">Math.round(-<span class="number">0.5</span>);   <span class="comment">// 0</span></span><br><span class="line">Math.round(-<span class="number">0.6</span>);   <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>


<h2 id="13-Synchronizer"><a href="#13-Synchronizer" class="headerlink" title="13. Synchronizer"></a>13. Synchronizer</h2><ul>
<li>Semaphore: 完成信号量控制, 可控制某个资源同事被访问的个数, 并通过<code>acquire()</code>获得一个访问许可. 如果没有则等待, <code>release()</code>释放许可</li>
<li>CyclicBarrier: 只有<code>await()</code>方法, 每调用一次计数则减1, 并阻塞当前进程. 当计数器归0时阻塞解除, 所有阻塞的线程都开始运行.</li>
<li>CountDown: 在<code>CountDown.await()</code>归0之前阻塞当前线程</li>
</ul>
<h2 id="14-monitor"><a href="#14-monitor" class="headerlink" title="14. monitor"></a>14. monitor</h2><ul>
<li>Java使用monitor来保证同一时间只有一个线程可以访问一段代码或数据</li>
<li>同时只能有一个线程获得某个对象的monitor</li>
<li>只有拥有了该对象的monitor才能调用对象的<code>notify()</code>和<code>notifyAll()</code>, 否则会抛出<code>java.lang.IllegalMonitorStateException</code></li>
<li>一个线程想拥有一个对象的monitor的方法有三种:<ul>
<li><code>public synchronize a()&#123;&#125;</code></li>
<li><code>synchronize(obj)&#123;&#125;</code></li>
<li><code>public static synchronize b()&#123;&#125;</code></li>
</ul>
</li>
</ul>
<h2 id="15-try-catch"><a href="#15-try-catch" class="headerlink" title="15. try-catch"></a>15. try-catch</h2><p>try可以对应多个catch, 但只会匹配第一个相符的catch. 且从上向下依次匹配, 所以应将异常范围小的放在前面.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">/* 由于IOException extends Exception, 所以覆盖了IOException */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123; <span class="comment">/* compile error, IOException has already be caught */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="16-finally"><a href="#16-finally" class="headerlink" title="16. finally"></a>16. finally</h2><p>finally块内的语句会在try结束前被执行, 所以finally中不应return. try-catch-finally的执行流程如下:</p>
<ul>
<li>try中出现的异常catch能捕获到, 转由catch处理</li>
<li>try中出现的异常catch无法捕获, 转到finally</li>
<li>catch中无论是否出现异常, 都会结束后转到finally</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">returnTest</span><span class="params">()</span> <span class="comment">/* return false */</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="17-ThreadLocal"><a href="#17-ThreadLocal" class="headerlink" title="17. ThreadLocal"></a>17. ThreadLocal</h2><p>ThreadLocal的作用是为线程提供一个可共享的局部变量. &quot;可共享&quot;是因为该线程的所有函数都可以访问该变量; &quot;局部变量&quot;是因为其他线程无法访问和修改该变量. 所以ThreadLocal避免了全局变量的一个缺点: 所有线程都可访问. 并且减少了同一个线程内多个函数使用公共变量传递的不便.</p>
<h2 id="18-Method-Signature"><a href="#18-Method-Signature" class="headerlink" title="18. Method Signature"></a>18. Method Signature</h2><p>当同一类中两个函数同名时, 会出现重载问题. Java通过<strong>方法签名</strong>保证函数唯一. 由于重载只与参数类型, 参数个数, 和参数顺序有关, 因此签名必须包含这些信息.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;&#125;       <span class="comment">// test1()V</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(String str)</span> <span class="comment">// test2(Ljava/lang/String;)V</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test3</span><span class="params">()</span>&#123;&#125;        <span class="comment">// test3()I</span></span><br></pre></td></tr></table></figure>
<p>以下是方法签名中特殊字符的含义</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>数据类型</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td>V</td>
<td>void</td>
<td>一般用于表示方法的返回值</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td></td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td></td>
</tr>
<tr>
<td>[</td>
<td>数组</td>
<td>以<code>[</code>开头, 配合其他的特殊字符, 表示对应数据类型的数组, 几个<code>[</code>表示几维数组</td>
</tr>
<tr>
<td>L</td>
<td>引用类型</td>
<td>以<code>L</code>开头 以<code>;</code>结尾, 中间是引用类型的全类名</td>
</tr>
</tbody></table>
<h2 id="19-and"><a href="#19-and" class="headerlink" title="19. &gt;&gt; and &gt;&gt;&gt;"></a>19. &gt;&gt; and &gt;&gt;&gt;</h2><p><code>&gt;&gt;</code>表示符号右移, <code>&gt;&gt;&gt;</code>表示无符号右移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d 0x%x\n&quot;</span>, a, a); <span class="comment">// -1         0xffffffff </span></span><br><span class="line">System.out.printf(<span class="string">&quot;%d 0x%x\n&quot;</span>, b, b); <span class="comment">// 1073741823 0x3fffffff</span></span><br></pre></td></tr></table></figure>


<h2 id="20-Implicit-Type-Casting"><a href="#20-Implicit-Type-Casting" class="headerlink" title="20. Implicit Type Casting"></a>20. Implicit Type Casting</h2><p>从小到大, 可隐式转换, 数据类型自动提升: byte, short, char -&gt; int -&gt; long -&gt; float -&gt; double. Java在以下情况下会进行隐式转换:</p>
<ul>
<li>算数运算</li>
<li>赋值表达式</li>
<li>函数调用中参数传递</li>
<li>返回表达式类型</li>
</ul>
<p>但从大到小只能强制转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">// byte c = a+b; // error, a+b返回int类型, 与c类型不符</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">byte</span>)(a + b);</span><br></pre></td></tr></table></figure>
<p>final修饰的变量不能自动隐式转换</p>
<h2 id="21-Integer-and"><a href="#21-Integer-and" class="headerlink" title="21. Integer and &#x3D;&#x3D;"></a>21. Integer and &#x3D;&#x3D;</h2><p>当赋予Integer一个整数值时, 会调用<code>Integer.valueOf()</code>来将int转换为Integer. 但<code>valueOf()</code>会将<code>[-128, 127]</code>之间的int数字放入IntegerCache中, 而范围之外的int数字会赋予一个新的内存空间.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">100</span>, f2 = <span class="number">100</span>, f3 = <span class="number">150</span>, f4 = <span class="number">150</span>;</span><br><span class="line">System.out.println( f1 == f2); <span class="comment">// 地址相同, 输出true</span></span><br><span class="line">System.out.println( f3 == f4); <span class="comment">// 地址不同, 输出false</span></span><br></pre></td></tr></table></figure>


<h2 id="22-volatile"><a href="#22-volatile" class="headerlink" title="22. volatile"></a>22. volatile</h2><p>Java内存模型规定, 所有变量都要存在主存(物理内存)当中. 每个线程都有自己的工作内存(类似于告诉告诉缓存). 线程对变量的所有操作都必须在工作内存中进行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上述语句需要先将10写入工作内存中, 然后再写入主存中. 这样就会导致各个线程中的工作内存放置的数据不相同. volatile用来修饰被不同线程访问和修改的变量, 能保证共享变量能立即刷新到主存中. 当其他线程需要读取时, 会从主存中读取新值.<br>volatile也能禁止指令重排序优化. 因为编译器对指令顺序的重新排序可能导致程序错误.<br>Volatile 变量具有synchronized的可见性特性, 但是不具备原子特性</p>
<h2 id="23-Collection-and-Map"><a href="#23-Collection-and-Map" class="headerlink" title="23. Collection and Map"></a>23. Collection and Map</h2><p>Collection:</p>
<ul>
<li>List:<ul>
<li>ArrayList</li>
<li>Vector</li>
<li>LinkedList</li>
</ul>
</li>
<li>Set</li>
<li>Queue</li>
<li>sortedSet</li>
</ul>
<p>Map:</p>
<ul>
<li>HashMap</li>
<li>HashTable</li>
<li>TreeMap</li>
<li>IdentityHashMap</li>
<li>WeakHashMap</li>
</ul>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Programming-Language/">Programming Language</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/b093.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">Java Basic (2)</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/9f80.html">
        <span class="next-text nav-default">C++ vs. Java</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/4093.html';
  var disqus_title = "Java Basic (1)";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
