<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="Binary Search Tree"/>




  <meta name="keywords" content="Algorithm," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/c984.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/c984.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/c984.html"/>


<meta name="description" content="1. IntroductionBinary search tree(BST, 二叉搜索树)是一种binary tree(二叉树)的树型数据结构, 定义如下:  若BST的左子树不为空, 则其左子树上所有节点的权值均小于其根节点的权值 若BST的右子树不为空, 则其右子树上所有节点的权值均小于其根节点的权值 BST的左右子树均为BST 空树也是BST  1.1 BST TraversalBST的in">
<meta property="og:type" content="article">
<meta property="og:title" content="Binary Search Tree">
<meta property="og:url" content="https://zaf1ro.github.io/p/c984.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. IntroductionBinary search tree(BST, 二叉搜索树)是一种binary tree(二叉树)的树型数据结构, 定义如下:  若BST的左子树不为空, 则其左子树上所有节点的权值均小于其根节点的权值 若BST的右子树不为空, 则其右子树上所有节点的权值均小于其根节点的权值 BST的左右子树均为BST 空树也是BST  1.1 BST TraversalBST的in">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/unique_bst.jpg">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/validate_bst.jpg">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/trim_bst.jpg">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/lowest_common_ancestor_in_bst.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/delete_node.jpg">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/validate_bst.jpg">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/max_sum_bst.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Algorithm/BST/closest_bst_value.jpg">
<meta property="article:published_time" content="2023-09-01T17:04:10.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.028Z">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/Algorithm/BST/unique_bst.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
Binary Search Tree - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Introduction"><span class="toc-text">1. Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-BST-Traversal"><span class="toc-text">1.1 BST Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Minimum-and-Maximum"><span class="toc-text">1.2 Minimum and Maximum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Insert-an-Element"><span class="toc-text">1.3 Insert an Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Delete-an-Element"><span class="toc-text">1.4 Delete an Element</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Implementation"><span class="toc-text">2. Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Query-Element"><span class="toc-text">2.1 Query Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Insert-Element"><span class="toc-text">2.2 Insert Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Delete-Element"><span class="toc-text">2.3 Delete Element</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Leetcode"><span class="toc-text">3. Leetcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#95-Unique-Binary-Search-Trees-II"><span class="toc-text">95. Unique Binary Search Trees II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-Validate-Binary-Search-Tree"><span class="toc-text">98. Validate Binary Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-1"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-1"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#669-Trim-a-Binary-Search-Tree"><span class="toc-text">669. Trim a Binary Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-2"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-2"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-text">235. Lowest Common Ancestor of a Binary Search Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-3"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-3"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-Delete-Node-in-a-BST"><span class="toc-text">450. Delete Node in a BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-4"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-4"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#230-Kth-Smallest-Element-in-a-BST"><span class="toc-text">230. Kth Smallest Element in a BST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-5"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-5"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1373-Maximum-Sum-BST-in-Binary-Tree"><span class="toc-text">1373. Maximum Sum BST in Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-6"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-6"><span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#272-Closest-Binary-Search-Tree-Value-II"><span class="toc-text">272. Closest Binary Search Tree Value II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Description-7"><span class="toc-text">Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Solution-7"><span class="toc-text">Solution</span></a></li></ol></li></ol></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Binary Search Tree
        
      </h1>
      <time class="post-time">
          09/01/23
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Binary search tree(BST, 二叉搜索树)是一种binary tree(二叉树)的树型数据结构, 定义如下:</p>
<ul>
<li>若BST的左子树不为空, 则其左子树上所有节点的权值均小于其根节点的权值</li>
<li>若BST的右子树不为空, 则其右子树上所有节点的权值均小于其根节点的权值</li>
<li>BST的左右子树均为BST</li>
<li>空树也是BST</li>
</ul>
<h3 id="1-1-BST-Traversal"><a href="#1-1-BST-Traversal" class="headerlink" title="1.1 BST Traversal"></a>1.1 BST Traversal</h3><p>BST的inorder traversal(中序遍历)的序列为非降序序列, 时间复杂度为<code>$O(n)$</code>(BST的节点数为n)</p>
<h3 id="1-2-Minimum-and-Maximum"><a href="#1-2-Minimum-and-Maximum" class="headerlink" title="1.2 Minimum and Maximum"></a>1.2 Minimum and Maximum</h3><p>由BST的性质可得, BST左链的顶点为最小值, 右链的顶点为最大值, 时间复杂度为<code>$O(n)$</code>(BST的节点数为n)</p>
<h3 id="1-3-Insert-an-Element"><a href="#1-3-Insert-an-Element" class="headerlink" title="1.3 Insert an Element"></a>1.3 Insert an Element</h3><p>假设BST的根节点为<code>o</code>, 插入的新节点值为<code>v</code>, 则插入元素时分为以下几种情况:</p>
<ul>
<li>若<code>o</code>为空, 直接返回值为<code>v</code>的新节点</li>
<li>若<code>o</code>的权值等于<code>v</code>, 则不添加新的节点</li>
<li>若<code>o</code>的权值大于<code>v</code>, 则在<code>o</code>的左子树插入权值为<code>v</code>的节点</li>
<li>若<code>o</code>的权值小于<code>v</code>, 则在<code>o</code>的右子树插入权值为<code>v</code>的节点</li>
</ul>
<h3 id="1-4-Delete-an-Element"><a href="#1-4-Delete-an-Element" class="headerlink" title="1.4 Delete an Element"></a>1.4 Delete an Element</h3><p>假设BST的根节点为<code>o</code>, 删除一个值为<code>v</code>的节点, 首先需要在BST中找到权值为<code>v</code>的节点:</p>
<ul>
<li>若<code>o</code>为空, 则BST中不存在权值为<code>v</code>的节点, 无需删除</li>
<li>若<code>o</code>的权值等于<code>v</code>, 则删除当前节点<code>o</code></li>
<li>若<code>o</code>的权值大于<code>v</code>, 则在<code>o</code>的左子树删除权值为<code>v</code>的节点</li>
<li>若<code>o</code>的权值小于<code>v</code>, 则在<code>o</code>的右子树删除权值为<code>v</code>的节点</li>
</ul>
<h2 id="2-Implementation"><a href="#2-Implementation" class="headerlink" title="2. Implementation"></a>2. Implementation</h2><h3 id="2-1-Query-Element"><a href="#2-1-Query-Element" class="headerlink" title="2.1 Query Element"></a>2.1 Query Element</h3><p>查找元素时, 只需根据情况判断需向左子树或右子树走, 每次判断都会缩小查找范围, 从而提高查找效率. 假设目标值为<code>val</code>, 从根节点出发:</p>
<ol>
<li>若当前节点为空, 则查找失败</li>
<li>若当前节点不为空, 对比节点值与目标值<ul>
<li>若$val &#x3D; node.val$, 则查找成功</li>
<li>若$val &lt; node.val$, 则查找左子树</li>
<li>若$val &gt; node.val$, 则查找右子树</li>
</ul>
</li>
</ol>
<p>最好的情况下, BST与二分查找类似, 从根节点到叶子节点的高度为$\log_2 n$, 因此时间复杂度为$O(\log_2 n)$; 最坏情况下, BST会变为一个链表, 即只有左子树或右子树, 退化为顺序查找, 因此时间复杂度为$O(n)$.</p>
<h3 id="2-2-Insert-Element"><a href="#2-2-Insert-Element" class="headerlink" title="2.2 Insert Element"></a>2.2 Insert Element</h3><p>插入操作与查找操作的步骤类似, 假设插入值为<code>val</code>, 从根节点出发:</p>
<ol>
<li>若当前节点为空, 则创建一个值为<code>val</code>的节点</li>
<li>若当前节点不为空, 比较节点值和插入值:<ul>
<li>若$val &lt; node.val$, 则插入左子树</li>
<li>若$val &gt; node.val$, 则插入右子树</li>
</ul>
</li>
</ol>
<p>由于BST不允许重复节点, 因此若插入值已存在于BST中, 则直接返回.</p>
<h3 id="2-3-Delete-Element"><a href="#2-3-Delete-Element" class="headerlink" title="2.3 Delete Element"></a>2.3 Delete Element</h3><p>在BST中删除元素需先找到被删除节点, 再执行删除操作. 被删除节点可分为三种情况:</p>
<ol>
<li>被删除节点的左子树为空, 则让右子树代替被删除节点</li>
<li>被删除节点的右子树为空, 则让左子树代替被删除节点</li>
<li>被删除节点的左右子树均不为空, 则让<strong>immediate  predecessor&#x2F;successor</strong>(直接前驱或直接后继, 也就是小于被删除节点值的最大值, 或大于被删除节点值的最小值)代替被删除节点</li>
</ol>
<p>BST删除元素的步骤如下, 从根节点出发:</p>
<ol>
<li>若当前元素为空, 则返回空</li>
<li>若$val &lt; node.val$, 则从左子树搜索并删除, 之后更新<code>node.left</code></li>
<li>若$val &gt; node.val$, 则从右子树搜索并删除, 之后更新<code>node.right</code></li>
<li>若$val &#x3D; node.val$, 则当前节点为被删除节点:<ul>
<li>若当前节点的左子树为空, 则让右子树代替当前节点, 返回右子树</li>
<li>若当前节点的右子树为空, 则让右子树代替当前节点, 返回左子树</li>
<li>若当前节点的左右子树均不为空, 则将左子树转移到右子树最左侧叶子节点的位置上, 并让右子树代替当前节点, 返回右子树</li>
</ul>
</li>
</ol>
<h2 id="3-Leetcode"><a href="#3-Leetcode" class="headerlink" title="3. Leetcode"></a>3. Leetcode</h2><h3 id="95-Unique-Binary-Search-Trees-II"><a href="#95-Unique-Binary-Search-Trees-II" class="headerlink" title="95. Unique Binary Search Trees II"></a>95. Unique Binary Search Trees II</h3><h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given an integer <code>n</code>, return all the structurally unique <strong>BST</strong>&#39;s (binary search trees), which has exactly n nodes of unique values from <code>1</code> to <code>n</code>. Return the answer in <strong>any order</strong>.</p>
<p>Example 1:<br><img src="/images/Algorithm/BST/unique_bst.jpg" alt="Unique Binary Search Trees II"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure>

<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">helper</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            res.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; ls = helper(l, i-<span class="number">1</span>), rs = helper(i+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">for</span> (TreeNode left: ls) &#123;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode right: rs) &#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    res.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h3><h4 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given the <code>root</code> of a binary tree, determine if it is a valid binary search tree (BST).<br>A <strong>valid BST</strong> is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Example 1:<br><img src="/images/Algorithm/BST/validate_bst.jpg" alt="Validate Binary Search Tree"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&#x27;s value is 5 but its right child&#x27;s value is 4.</span><br></pre></td></tr></table></figure>

<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">helper</span><span class="params">(TreeNode root, <span class="type">long</span> min, <span class="type">long</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; min || root.val &gt; max) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, min, (<span class="type">long</span>)root.val-<span class="number">1</span>) &amp;&amp; helper(root.right, (<span class="type">long</span>)root.val+<span class="number">1</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="669-Trim-a-Binary-Search-Tree"><a href="#669-Trim-a-Binary-Search-Tree" class="headerlink" title="669. Trim a Binary Search Tree"></a>669. Trim a Binary Search Tree</h3><h4 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p>
<p>Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.</p>
<p>Example 1:<br><img src="/images/Algorithm/BST/trim_bst.jpg" alt="Trim a Binary Search Tree"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,0,2], low = 1, high = 2</span><br><span class="line">Output: [1,null,2]</span><br></pre></td></tr></table></figure>

<h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> trimBST(root.left, low, high), r = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low || root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> l == <span class="literal">null</span> ? r : l;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = l;</span><br><span class="line">        root.right = r;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree"></a>235. Lowest Common Ancestor of a Binary Search Tree</h3><h4 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: &quot;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).&quot;</p>
<p>Example 1:<br><img src="/images/Algorithm/BST/lowest_common_ancestor_in_bst.png" alt="Lowest Common Ancestor of a Binary Search Tree"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>

<h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="450-Delete-Node-in-a-BST"><a href="#450-Delete-Node-in-a-BST" class="headerlink" title="450. Delete Node in a BST"></a>450. Delete Node in a BST</h3><h4 id="Problem-Description-4"><a href="#Problem-Description-4" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the <strong>root node reference</strong> (possibly updated) of the BST.<br>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.</li>
</ol>
<p>Example 1:<br><img src="/images/Algorithm/BST/delete_node.jpg" alt="Delete Node in a BST"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">Output: [5,4,6,2,null,null,7]</span><br><span class="line">Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.</span><br><span class="line">One valid answer is [5,4,6,2,null,null,7], shown in the above BST.</span><br><span class="line">Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#x27;s also accepted.</span><br></pre></td></tr></table></figure>

<h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root.right;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">while</span> (l.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                l = l.left;</span><br><span class="line">            &#125;</span><br><span class="line">            l.left = root.left;</span><br><span class="line">            <span class="keyword">return</span> root.right; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h3><h4 id="Problem-Description-5"><a href="#Problem-Description-5" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return the <code>$k^&#123;th&#125;$</code> smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree.</p>
<p>Example 1:<br><img src="/images/Algorithm/BST/validate_bst.jpg" alt="Kth Smallest Element in a BST"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h4 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1373-Maximum-Sum-BST-in-Binary-Tree"><a href="#1373-Maximum-Sum-BST-in-Binary-Tree" class="headerlink" title="1373. Maximum Sum BST in Binary Tree"></a>1373. Maximum Sum BST in Binary Tree</h3><h4 id="Problem-Description-6"><a href="#Problem-Description-6" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given a <strong>binary tree</strong> root, return the maximum sum of all keys of <strong>any</strong> sub-tree which is also a Binary Search Tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Example 1:<br><img src="/images/Algorithm/BST/max_sum_bst.png" alt="Maximum Sum BST in Binary Tree"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.</span><br></pre></td></tr></table></figure>

<h4 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> min, max, sum;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">            <span class="built_in">this</span>.sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        postorder(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">postorder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">l</span> <span class="operator">=</span> postorder(node.left), r = postorder(node.right);</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span> || r == <span class="literal">null</span> || node.val &lt;= l.max || node.val &gt;= r.min) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> node.val + l.sum + r.sum;</span><br><span class="line">        res = Math.max(res, sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Math.min(l.min, node.val), Math.max(r.max, node.val), sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="272-Closest-Binary-Search-Tree-Value-II"><a href="#272-Closest-Binary-Search-Tree-Value-II" class="headerlink" title="272. Closest Binary Search Tree Value II"></a>272. Closest Binary Search Tree Value II</h3><h4 id="Problem-Description-7"><a href="#Problem-Description-7" class="headerlink" title="Problem Description"></a>Problem Description</h4><p>Given the <code>root</code> of a binary search tree, a <code>target</code> value, and an integer <code>k</code>, return the <code>k</code> values in the BST that are closest to the <code>target</code>. You may return the answer in <strong>any order</strong>.<br>You are <strong>guaranteed</strong> to have only one unique set of <code>k</code> values in the BST that are closest to the <code>target</code>.</p>
<p>Example 1:<br><img src="/images/Algorithm/BST/closest_bst_value.jpg" alt="Closest Binary Search Tree Value"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: root = [4,2,5,1,3], target = 3.714286, k = 2</span><br><span class="line">Output: [4,3]</span><br></pre></td></tr></table></figure>

<h4 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">closestKValues</span><span class="params">(TreeNode root, <span class="type">double</span> target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        inorder(root, target, k);</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            res.add(deque.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, <span class="type">double</span> target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left, target, k);</span><br><span class="line">        <span class="type">double</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(node.val - target);</span><br><span class="line">        <span class="keyword">if</span> (deque.size() == k) &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> Math.abs(deque.peekFirst() - target), d2 = Math.abs(deque.peekLast() - target);</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; d1 || diff &lt; d2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d1 &lt; d2) deque.pollLast();</span><br><span class="line">                <span class="keyword">else</span> deque.pollFirst();</span><br><span class="line">                deque.offerLast(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deque.offerLast(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.right, target, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Algorithm/">Algorithm</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/b357.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">Segment Tree</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/9055.html">
        <span class="next-text nav-default">Trie</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/c984.html';
  var disqus_title = "Binary Search Tree";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
