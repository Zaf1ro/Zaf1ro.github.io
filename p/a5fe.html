<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="DP - Memoization Search"/>




  <meta name="keywords" content="Algorithm," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/a5fe.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/a5fe.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/a5fe.html"/>


<meta name="description" content="1. Introduction记忆化搜索通过存储已遍历的状态, 可避免对同一状态的重复遍历. 换句话说, 当计算某个子问题时, 首先应检查该子问题是否曾经计算过:  若已计算过, 则直接返回存储的结果 若未计算过, 则继续计算, 并在执行后保存结果  动态规划最重要的是得到状态定义和状态转移方程, 可以先将题目当作backtracking题目, 也就是, 将一个大问题拆分为一个小问题, 并思考以下">
<meta property="og:type" content="article">
<meta property="og:title" content="DP - Memoization Search">
<meta property="og:url" content="https://zaf1ro.github.io/p/a5fe.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. Introduction记忆化搜索通过存储已遍历的状态, 可避免对同一状态的重复遍历. 换句话说, 当计算某个子问题时, 首先应检查该子问题是否曾经计算过:  若已计算过, 则直接返回存储的结果 若未计算过, 则继续计算, 并在执行后保存结果  动态规划最重要的是得到状态定义和状态转移方程, 可以先将题目当作backtracking题目, 也就是, 将一个大问题拆分为一个小问题, 并思考以下">
<meta property="og:locale">
<meta property="article:published_time" content="2024-04-06T16:53:17.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.025Z">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
DP - Memoization Search - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Introduction"><span class="toc-text">1. Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Steps"><span class="toc-text">2. Steps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Leetcode"><span class="toc-text">2. Leetcode</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#198-House-Robber"><span class="toc-text">198. House Robber</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Problem-Description"><span class="toc-text">1. Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Solution"><span class="toc-text">2. Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#377-Combination-Sum-IV"><span class="toc-text">377. Combination Sum IV</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Problem-Description-1"><span class="toc-text">1. Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Solution-1"><span class="toc-text">2. Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2466-Count-Ways-To-Build-Good-Strings"><span class="toc-text">2466. Count Ways To Build Good Strings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Problem-Description-2"><span class="toc-text">1. Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Solution-2"><span class="toc-text">2. Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#740-Delete-and-Earn"><span class="toc-text">740. Delete and Earn</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Problem-Description-3"><span class="toc-text">1. Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Solution-3"><span class="toc-text">2. Solution</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2320-Count-Number-of-Ways-to-Place-Houses"><span class="toc-text">2320. Count Number of Ways to Place Houses</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Problem-Description-4"><span class="toc-text">1. Problem Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Solution-4"><span class="toc-text">2. Solution</span></a></li></ol></li></ol></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          DP - Memoization Search
        
      </h1>
      <time class="post-time">
          04/06/24
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>记忆化搜索通过存储已遍历的状态, 可避免对同一状态的重复遍历. 换句话说, 当计算某个子问题时, 首先应检查该子问题是否曾经计算过:</p>
<ul>
<li>若已计算过, 则直接返回存储的结果</li>
<li>若未计算过, 则继续计算, 并在执行后保存结果</li>
</ul>
<p>动态规划最重要的是得到<strong>状态定义</strong>和<strong>状态转移方程</strong>, 可以先将题目当作backtracking题目, 也就是, 将一个大问题拆分为一个小问题, 并思考以下三个问题:</p>
<ul>
<li>当前操作</li>
<li>子问题</li>
<li>边界条件</li>
</ul>
<p>记忆化搜索则通过记录已经遍历过的状态, 从而避免对同一状态重复遍历, 降低时间复杂度.</p>
<h2 id="2-Steps"><a href="#2-Steps" class="headerlink" title="2. Steps"></a>2. Steps</h2><p>记忆化搜索作为动态规划的一种实现, 使用前需考虑动态规划最重要的两个部分:</p>
<ul>
<li>状态定义</li>
<li>状态转移方程</li>
</ul>
<p>知道问题对应的状态定义和转移方程后, 可定义一个缓存(通常为数组或哈希表)用于保存子问题的解, 并定义一个递归函数用于解决问题. 在递归函数中, 需先检查当前问题是否已计算过(能否在缓存中找到结果), 若不能则执行计算, 并在返回前将结果保存到缓存中.</p>
<h2 id="2-Leetcode"><a href="#2-Leetcode" class="headerlink" title="2. Leetcode"></a>2. Leetcode</h2><h3 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h3><h4 id="1-Problem-Description"><a href="#1-Problem-Description" class="headerlink" title="1. Problem Description"></a>1. Problem Description</h4><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.<br>Given an integer array <code>nums</code> representing the amount of money of each house, return the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>

<h4 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2. Solution"></a>2. Solution</h4><p>用回溯的思路, 可分为三个问题:</p>
<ul>
<li>当前操作: 选或不选当前房子</li>
<li>子问题:<ul>
<li>若选择当前房子(<code>nums[i]</code>), 则查找第i+2个房子及其后面的房子的最大金额</li>
<li>若不选择当前房子, 则查找第i+1房子及其后面的房子的最大金额</li>
</ul>
</li>
<li>边界条件: 坐标超出数组边界</li>
</ul>
<p>状态转换方程: dfs(i) &#x3D; max(dfs(i+1), dfs(i-2)+nums[i])</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backtracking(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(backtracking(nums, i+<span class="number">1</span>), backtracking(nums, i+<span class="number">2</span>)+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法虽然思路上正确, 但时间复杂度很高, 因为递归会对nums的很多元素进行多次选与不选的判断, 可通过记忆化搜索将递归中的结果保存下来, 下次遇到时可直接返回结果.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> backtracking(nums, <span class="number">0</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        memo[i] = Math.max(backtracking(nums, i+<span class="number">1</span>, memo), backtracking(nums, i+<span class="number">2</span>, memo)+nums[i]);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h3><h4 id="1-Problem-Description-1"><a href="#1-Problem-Description-1" class="headerlink" title="1. Problem Description"></a>1. Problem Description</h4><p>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return the number of possible combinations that add up to <code>target</code>.<br>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,3], target = 4</span><br><span class="line">Output: 7</span><br><span class="line">Explanation:</span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">Note that different sequences are counted as different combinations.</span><br></pre></td></tr></table></figure>

<h4 id="2-Solution-1"><a href="#2-Solution-1" class="headerlink" title="2. Solution"></a>2. Solution</h4><p>该问题的要求为:</p>
<ul>
<li>数组中的元素可重复使用: Combination Sum</li>
<li>组合可重复: 与上述所有题都不同</li>
<li>组合长度没有要求, 但要求组合的总和: Combination Sum</li>
</ul>
<p>模板一: 跳过元素与之前题目相同; 但选择元素时需注意: 由于题目允许重复的组合(元素顺序不同), 因此每次递归都要从第一个元素开始.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length || nums[i] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// skip</span></span><br><span class="line">        backtracking(nums, i+<span class="number">1</span>, target);</span><br><span class="line">        <span class="comment">// pick up</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>, target-nums[i]); <span class="comment">// 0 instead of i or i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述解法虽然可得到正确结果, 但当target的数值较大时, 时间复杂度会非常高, 原因在于很多重复递归. 假设<code>backtracking(i)</code>表示target为i时的组合数量, 假设数组为<code>[1,2]</code>, 则<code>backtracking(i) = backtracking(i-1) = backtracking(i-2)</code>; 假设数组中有n个元素, 则$backtracking(i) &#x3D; \sum^{n-1}_{j&#x3D;0}{backtracking(i-nums[j])}$, 因此可按照<strong>记忆化搜索</strong>来优化:</p>
<ul>
<li>若状态为第一次遇到, 则将结果放入memo数组中</li>
<li>若状态不是第一次遇到, 则直接返回memo数组中的结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> backtracking(nums, target, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[target] != -<span class="number">1</span>) <span class="keyword">return</span> memo[target];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">            res += backtracking(nums, target-num, memo);</span><br><span class="line">        &#125;</span><br><span class="line">        memo[target] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2466-Count-Ways-To-Build-Good-Strings"><a href="#2466-Count-Ways-To-Build-Good-Strings" class="headerlink" title="2466. Count Ways To Build Good Strings"></a>2466. Count Ways To Build Good Strings</h3><h4 id="1-Problem-Description-2"><a href="#1-Problem-Description-2" class="headerlink" title="1. Problem Description"></a>1. Problem Description</h4><p>Given the integers <code>zero</code>, <code>one</code>, <code>low</code>, and <code>high</code>, we can construct a string by starting with an empty string, and then at each step perform either of the following:</p>
<ul>
<li>Append the character <code>&#39;0&#39;</code> <code>zero</code> times.</li>
<li>Append the character <code>&#39;1&#39;</code> <code>one</code> times.</li>
</ul>
<p>This can be performed any number of times.<br>A <strong>good</strong> string is a string constructed by the above process having a <strong>length</strong> between <code>low</code> and <code>high</code> (<strong>inclusive</strong>).<br>Return the number of <strong>different</strong> good strings that can be constructed satisfying these properties. Since the answer can be large, return it <strong>modulo</strong> <code>$&#123;10&#125;^9 + 7$</code>.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: </span><br><span class="line">One possible valid good string is &quot;011&quot;. </span><br><span class="line">It can be constructed as follows: &quot;&quot; -&gt; &quot;0&quot; -&gt; &quot;01&quot; -&gt; &quot;011&quot;. </span><br><span class="line">All binary strings from &quot;000&quot; to &quot;111&quot; are good strings in this example.</span><br></pre></td></tr></table></figure>

<h4 id="2-Solution-2"><a href="#2-Solution-2" class="headerlink" title="2. Solution"></a>2. Solution</h4><p>依然套用回溯三要素:</p>
<ul>
<li>当前操作: 向当前字符串添加zero次0, 或添加one次1</li>
<li>子操作: 返回剩余字符长度的情况下, 长度满足<code>[low, high]</code>的组合数</li>
<li>边界条件:<ul>
<li>字符串长度超过high, 返回0</li>
<li>字符串长度位于<code>[low, high]</code>之间, 组合数+1</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> backtracking(low, high, zero, one, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= low &amp;&amp; i &lt;= high) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += backtracking(low, high, zero, one, i+zero) + backtracking(low, high, zero, one, i+one);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记忆化搜索: 用<code>memo</code>数组记录所有长度下的组合数, 减少重复回溯:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[high+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> backtracking(low, high, zero, one, <span class="number">0</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one, <span class="type">int</span> i, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; high) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= low &amp;&amp; i &lt;= high) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        res += backtracking(low, high, zero, one, i+zero, memo) + backtracking(low, high, zero, one, i+one, memo);</span><br><span class="line">        memo[i] = (<span class="type">int</span>)(res % <span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改为DP:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[high+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>), res = <span class="number">0</span>;</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) memo[i] = (memo[i] + memo[i-zero]) % MOD;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one) memo[i] = (memo[i] + memo[i-one]) % MOD;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= low) res = (res + memo[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h3><h4 id="1-Problem-Description-3"><a href="#1-Problem-Description-3" class="headerlink" title="1. Problem Description"></a>1. Problem Description</h4><p>You are given an integer array <code>nums</code>. You want to maximize the number of points you get by performing the following operation any number of times:</p>
<ul>
<li>Pick any <code>nums[i]</code> and delete it to earn <code>nums[i]</code> points. Afterwards, you must delete <strong>every</strong> element equal to <code>nums[i] - 1</code> and <strong>every</strong> element equal to <code>nums[i] + 1</code>.<br>Return the <strong>maximum number of points</strong> you can earn by applying the above operation some number of times.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: You can perform the following operations:</span><br><span class="line">- Delete <span class="number">4</span> to earn <span class="number">4</span> points. Consequently, <span class="number">3</span> is also deleted. nums = [<span class="number">2</span>].</span><br><span class="line">- Delete <span class="number">2</span> to earn <span class="number">2</span> points. nums = [].</span><br><span class="line">You earn a total of <span class="number">6</span> points.</span><br></pre></td></tr></table></figure>

<h4 id="2-Solution-3"><a href="#2-Solution-3" class="headerlink" title="2. Solution"></a>2. Solution</h4><p>题目其实与House Robber相同: 将所有points映射到一个数组上, 若选择<code>nums[i]</code>, 则必须跳过<code>nums[i] + 1</code>, 因此回溯三要素为:</p>
<ul>
<li>当前操作: 选或不选当前元素</li>
<li>子问题:<ul>
<li>若选择该元素: 获取第i+2个元素及其之后的最大point之和</li>
<li>若不选择该元素: 获取第i+1个元素及其之后的最大point之和</li>
</ul>
</li>
<li>边界条件:<ul>
<li>递归超出最大元素</li>
<li>当前枚举元素不存在于<code>nums</code>中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++count[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backtracking(<span class="number">0</span>, maxVal, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> max, <span class="type">int</span>[] count)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count[i] == <span class="number">0</span>) <span class="keyword">return</span> backtracking(i+<span class="number">1</span>, max, count);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> backtracking(i+<span class="number">1</span>, max, count);</span><br><span class="line">        res = Math.max(res, i * count[i] + backtracking(i+<span class="number">2</span>, max, count));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记忆化搜索优化后:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            maxVal = Math.max(maxVal, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[maxVal+<span class="number">1</span>], memo = <span class="keyword">new</span> <span class="title class_">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++count[num];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> backtracking(<span class="number">0</span>, maxVal, count, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> max, <span class="type">int</span>[] count, <span class="type">int</span>[] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; max) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (count[i] == <span class="number">0</span>) <span class="keyword">return</span> backtracking(i+<span class="number">1</span>, max, count, memo);</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i];</span><br><span class="line">        memo[i] = Math.max(backtracking(i+<span class="number">1</span>, max, count, memo), i*count[i]+backtracking(i+<span class="number">2</span>, max, count, memo));</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2320-Count-Number-of-Ways-to-Place-Houses"><a href="#2320-Count-Number-of-Ways-to-Place-Houses" class="headerlink" title="2320. Count Number of Ways to Place Houses"></a>2320. Count Number of Ways to Place Houses</h3><h4 id="1-Problem-Description-4"><a href="#1-Problem-Description-4" class="headerlink" title="1. Problem Description"></a>1. Problem Description</h4><p>There is a street with <code>n * 2</code> <strong>plots</strong>, where there are <code>n</code> plots on each side of the street. The plots on each side are numbered from <code>1</code> to <code>n</code>. On each plot, a house can be placed.<br>Return the number of ways houses can be placed such that no two houses are adjacent to each other on the same side of the street. Since the answer may be very large, return it <strong>modulo</strong> <code>$&#123;10&#125;^9 + 7$</code>.<br>Note that if a house is placed on the <code>$i^&#123;th&#125;$</code> plot on one side of the street, a house can also be placed on the <code>$i^&#123;th&#125;$</code> plot on the other side of the street.</p>
<p>Example 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">Possible arrangements:</span><br><span class="line">1. All plots are empty.</span><br><span class="line">2. A house is placed on one side of the street.</span><br><span class="line">3. A house is placed on the other side of the street.</span><br><span class="line">4. Two houses are placed, one on each side of the street.</span><br></pre></td></tr></table></figure>

<h4 id="2-Solution-4"><a href="#2-Solution-4" class="headerlink" title="2. Solution"></a>2. Solution</h4><p>由于街道的两侧是相互独立的, 因此只需算一侧街道的组合数即可. 回溯三要素:</p>
<ul>
<li>当前操作: 选或不选当前plot(第i个元素)</li>
<li>子问题: 若选择当前plot, 则需获取第i+2个元素及其之后元素的组合数; 若不选择当前plot, 则需获取第i+1个元素及其之后元素的组合数.</li>
<li>边界条件:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countHousePlacements</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> backtracking(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(((<span class="type">long</span>)res * res) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (backtracking(i+<span class="number">1</span>, n) + backtracking(i+<span class="number">2</span>, n)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设f[i]表示前i个plot的放置数, 对于第i个plot:</p>
<ul>
<li>若不放置房屋, 则第i-1个plot可放可不放, 则<code>f[i] = f[i-1]</code></li>
<li>若放置房屋, 则第i-2个plot可放可不放, 则<code>f[i] = f[i-2]</code></li>
</ul>
<p>由于放置或不放置是两个不可能同时发生的事件, 根据加法原则, <code>f[i] = f[i-1] + f[i-2]</code>.<br>边界条件:</p>
<ul>
<li>f[0] &#x3D; 1, 不放置任何房屋: 一种情况</li>
<li>f[1] &#x3D; 2, 放或不放置房屋: 两种情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countHousePlacements</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)((dp[n] * dp[n]) % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Algorithm/">Algorithm</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/539a.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">DP - 0/1 Knapsack Problem</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/1614.html">
        <span class="next-text nav-default">DP (Dynamic Programming)</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/a5fe.html';
  var disqus_title = "DP - Memoization Search";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
