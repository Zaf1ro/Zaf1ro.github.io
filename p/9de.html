<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="React.js"/>




  <meta name="keywords" content="Full Stack," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/9de.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/9de.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/9de.html"/>


<meta name="description" content="1. DOMThe Document Object Model (DOM) is the data representation of the objects that comprise the structure and content of a document on the web.A web page is a document that can be either displayed i">
<meta property="og:type" content="article">
<meta property="og:title" content="React.js">
<meta property="og:url" content="https://zaf1ro.github.io/p/9de.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. DOMThe Document Object Model (DOM) is the data representation of the objects that comprise the structure and content of a document on the web.A web page is a document that can be either displayed i">
<meta property="og:locale">
<meta property="article:published_time" content="2024-05-01T16:42:10.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.040Z">
<meta property="article:tag" content="Full Stack">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
React.js - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-DOM"><span class="toc-text">1. DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Virtual-DOM"><span class="toc-text">2. Virtual DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Why-use-virtual-DOM"><span class="toc-text">2.1 Why use virtual DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Pros-of-Virtual-DOM"><span class="toc-text">2.2 Pros of Virtual DOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-React-Component"><span class="toc-text">3. React Component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Bubbling-and-Capturing"><span class="toc-text">4. Bubbling and Capturing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Event"><span class="toc-text">5. Event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Fragments"><span class="toc-text">6. Fragments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-createPortal"><span class="toc-text">7. createPortal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Error-Boundaries"><span class="toc-text">8. Error Boundaries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Context"><span class="toc-text">9. Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Render-Props"><span class="toc-text">10. Render Props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Refs-and-the-DOM"><span class="toc-text">11. Refs and the DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-Pass-ref-to-component"><span class="toc-text">11.1 Pass ref to component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Ref-Callback"><span class="toc-text">11.2 Ref Callback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Hooks"><span class="toc-text">12. Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-State-Hook"><span class="toc-text">12.2 State Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-Effect-Hook"><span class="toc-text">12.3 Effect Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-Memo-Hook"><span class="toc-text">12.4 Memo Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-Context-Hook"><span class="toc-text">12.5 Context Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-Ref-Hook"><span class="toc-text">12.6 Ref Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-Reducer-Hook"><span class="toc-text">12.7 Reducer Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-Layout-Hook"><span class="toc-text">12.8 Layout Hook</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-Strict-Mode"><span class="toc-text">13. Strict Mode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Rules-of-React"><span class="toc-text">14. Rules of React</span></a></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          React.js
        
      </h1>
      <time class="post-time">
          05/01/24
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-DOM"><a href="#1-DOM" class="headerlink" title="1. DOM"></a>1. DOM</h2><p>The Document Object Model (DOM) is the data representation of the objects that comprise the structure and content of a document on the web.<br>A web page is a document that can be either displayed in the browser window or as the HTML source. In both cases, it is the same document but the Document Object Model (DOM) representation allows it to be manipulated. As an object-oriented representation of the web page, it can be modified with a scripting language such as JavaScript.<br>The DOM is not part of the JavaScript language, but is instead a Web API used to build websites.</p>
<h2 id="2-Virtual-DOM"><a href="#2-Virtual-DOM" class="headerlink" title="2. Virtual DOM"></a>2. Virtual DOM</h2><ul>
<li>Virtual DOM 并不是真实的 DOM，它跟原生 DOM 本质上没什么关系</li>
<li>本质上 Virtual DOM 对应的是一个 JavaScript 对象，它描述的是视图和应用状态之间的一种映射关系，是某一时刻真实 DOM 状态的内存映射。</li>
<li>在视图显示方面，Virtual DOM 对象的节点跟真实 DOM Tree 每个位置的属性一一对应</li>
<li>我们不再需要直接的操作 DOM，只需要关注应用的状态即可，操作 DOM 的事情有框架替我们做了</li>
</ul>
<h3 id="2-1-Why-use-virtual-DOM"><a href="#2-1-Why-use-virtual-DOM" class="headerlink" title="2.1 Why use virtual DOM"></a>2.1 Why use virtual DOM</h3><p>Manipulating the DOM is slow. Manipulating the virtual DOM is much faster because nothing gets drawn onscreen.</p>
<ul>
<li>操作 DOM 时，任何DOM API调用都要先将JS数据结构转为DOM数据结构，再挂起JS引擎线程并启动渲染引擎线程，执行过后再把可能的返回值反转数据结构，重启 JS 引擎继续执行。这种两个线程之间的上下文切换势必会很耗性能. 另外很多 DOM API 的读写都涉及页面布局的 重绘（repaint）和回流（reflow），这会更加的耗费性能。</li>
<li>React相对于直接操作原生DOM最大的优势在于 <strong>batching</strong> 和 <strong>diff</strong>。为了尽量减少不必要的 DOM 操作， Virtual DOM 在执行 DOM 的更新操作后，不会直接操作真实 DOM，而是根据当前应用状态的数据，生成一个全新的 Virtual DOM，然后跟上一次生成 的 Virtual DOM 去 diff，得到一个 Patch，这样就可以找到变化了的 DOM 节点，只对变化的部分进行 DOM 更新，而不是重新渲染整个 DOM 树，这个过程就是 diff</li>
</ul>
<h3 id="2-2-Pros-of-Virtual-DOM"><a href="#2-2-Pros-of-Virtual-DOM" class="headerlink" title="2.2 Pros of Virtual DOM"></a>2.2 Pros of Virtual DOM</h3><ul>
<li>No need to directly manipulate the DOM</li>
<li>improve rendering efficiency by reducing the number of page renders</li>
<li>provides better cross-platform capabilities because the virtual DOM is based on JavaScript objects rather than relying on specific platform environments. Therefore, it can be used on other platforms, such as Node.js</li>
</ul>
<p>The React element is actually just a regular JavaScript object, which is used to describe a DOM node or an instance of a component. When we use the Button component in JSX, it&#39;s like calling the <code>React.createElement()</code> method to instantiate the component. Since components can reference other components, when we build a component, it forms a tree-like structure of components. React recursively converts it into React elements, layer by layer. When encountering a type that starts with a capital letter, React knows it&#39;s a custom component element, then it executes the <code>render</code> method of the component or executes the function of that component (depending on whether it&#39;s a class component or a function component), finally returning an element.</p>
<h2 id="3-React-Component"><a href="#3-React-Component" class="headerlink" title="3. React Component"></a>3. React Component</h2><ul>
<li>React elements are the smallest building blocks of React applications. They are plain objects that describe the structure and content of the user interface. Elements are immutable, meaning once created, they cannot be changed.</li>
<li>React components are more complex constructs that contain multiple elements and other components. They encapsulate the structure, behavior, and state of a component.</li>
</ul>
<p>In summary, React components are reusable pieces of code that encapsulate the structure, behavior, and state of a UI element. React elements are the smallest building blocks of a React application and are created by calling the React.createElement() function.</p>
<p>Types of component:</p>
<ul>
<li>Stateless component: The most basic form of a component, without any state. consists of properties (props) along with a rendering function (render).</li>
<li>Stateful component: contains state, state changes when there&#39;s any new event or parameter. Stateful components typically come with lifecycles to trigger state updates at different moments. Different scenarios requiring different states and lifecycles.</li>
</ul>
<h2 id="4-Bubbling-and-Capturing"><a href="#4-Bubbling-and-Capturing" class="headerlink" title="4. Bubbling and Capturing"></a>4. Bubbling and Capturing</h2><p>The standard DOM Events describes 3 phases of event propagation:</p>
<ol>
<li>Capturing: the event goes down to the element.</li>
<li>Target: the event reached the target element.</li>
<li>Bubbling: the event bubbles up from the element.</li>
</ol>
<p>Capturing: this phase was invisible unless set the handler <code>capture</code> option to <code>true</code>. (For example: <code>HTML -&gt; BODY -&gt; FORM -&gt; DIV -&gt; P</code>)<br>Bubbling: When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors. Almost all events bubble. (For example: <code>P -&gt; DIV -&gt; FORM -&gt; BODY -&gt; HTML</code>)</p>
<h2 id="5-Event"><a href="#5-Event" class="headerlink" title="5. Event"></a>5. Event</h2><ul>
<li>event.target: the deepest element that originated the event</li>
<li>event.currentTarget (this): the current element that handles the event (the one that has the handler on it)</li>
<li>event.eventPhase: the current phase (capturing&#x3D;1, target&#x3D;2, bubbling&#x3D;3)</li>
</ul>
<p>Stop Events:</p>
<ul>
<li>event.stopPropagation(): prevents further propagation of the current event in the <strong>capturing</strong> and <strong>bubbling</strong> phases</li>
<li>event.stopImmediatePropagation(): prevents other listeners of the same event from being called</li>
<li>event.preventDefault(): don&#39;t take default action if the event doesn&#39;t get handled</li>
</ul>
<h2 id="6-Fragments"><a href="#6-Fragments" class="headerlink" title="6. Fragments"></a>6. Fragments</h2><p>A common pattern in React is for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM. <code>key</code> is the only attribute that can be passed to Fragment. </p>
<h2 id="7-createPortal"><a href="#7-createPortal" class="headerlink" title="7. createPortal"></a>7. createPortal</h2><p>Allow developer to render an element in another location in the DOM: This lets position or style an element correctly. A typical use case for portals is when a parent component has an <code>overflow: hidden</code> or <code>z-index</code> style.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    * children: Anything that can be rendered with React (JSX, Fragment, string, number </span></span><br><span class="line"><span class="comment"> *      or an array)</span></span><br><span class="line"><span class="comment"> *    * domNode: a DOM node (returned by document.getElementById)</span></span><br><span class="line"><span class="comment"> *    * key (optional): </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">createPortal</span>(children, domNode, key?) </span><br></pre></td></tr></table></figure>

<p>Event bubbling and context work as normal since the portal still exists in the React tree regardless of position in the DOM tree.</p>
<h2 id="8-Error-Boundaries"><a href="#8-Error-Boundaries" class="headerlink" title="8. Error Boundaries"></a>8. Error Boundaries</h2><p>Error boundaries are React components that catch JavaScript errors in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed.<br>A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static <code>getDerivedStateFromError()</code> or <code>componentDidCatch()</code>.<br><code>try / catch</code> only works for imperative code; However, React components are declarative. Error boundaries preserve the declarative nature of React, and behave as you would expect.<br>Error boundaries don&#39;t catch the following errors:</p>
<ul>
<li>Event handlers (learn more)</li>
<li>Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks)</li>
<li>Server side rendering</li>
<li>Errors thrown in the error boundary itself</li>
</ul>
<h2 id="9-Context"><a href="#9-Context" class="headerlink" title="9. Context"></a>9. Context</h2><p>Context provides a way to pass data through the component tree without having to pass props down manually at every level.<br>In a typical React application, data is passed top-down (parent to child) via props, but such usage can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</p>
<h2 id="10-Render-Props"><a href="#10-Render-Props" class="headerlink" title="10. Render Props"></a>10. Render Props</h2><p>Render prop refers to a technique for sharing code between React components using a prop whose value is a function. </p>
<ul>
<li>Problem: Components are the primary unit of code reuse in React, but it&#39;s not always obvious how to share the state or behavior that one component encapsulates to other components that need that same state.</li>
<li>Solution: render prop is a function prop that a component uses to know what to render. For example, component A wants to pass its state to component B: In A, call <code>this.props.render(this.state)</code>; when use A, pass function with B to A <code>&lt;A render=&#123; info =&gt; (&lt;B info=&#123;info&#125; /&gt;) &#125;/&gt;</code>; So B can use A&#39;s state directly, <code>const info = this.props.info;</code></li>
<li>Render props have been replaced by custom Hooks</li>
</ul>
<h2 id="11-Refs-and-the-DOM"><a href="#11-Refs-and-the-DOM" class="headerlink" title="11. Refs and the DOM"></a>11. Refs and the DOM</h2><p>React automatically updates the DOM to match the render output, so components don&#39;t need to manipulate it.<br>However, sometimes you might need access to the DOM elements managed by React:</p>
<ul>
<li>Managing focus, text selection, or media playback.</li>
<li>Measure its size and position</li>
<li>Triggering imperative animations (ex. scroll).</li>
<li>Integrating with third-party DOM libraries.</li>
</ul>
<p>Refs provide a way to access DOM nodes or React elements. Accessing Refs:</p>
<ul>
<li>When the <code>ref</code> attribute is used on an HTML element, the <code>ref</code> created in the constructor with <code>React.createRef()</code> receives the underlying DOM element as its <code>current</code> property.</li>
<li>When the <code>ref</code> attribute is used on a <strong>class</strong> component, the <code>ref</code> object receives the mounted instance of the component as its <code>current</code> property.</li>
</ul>
<h3 id="11-1-Pass-ref-to-component"><a href="#11-1-Pass-ref-to-component" class="headerlink" title="11.1 Pass ref to component"></a>11.1 Pass ref to component</h3><p>When you put a ref on a built-in component like <code>&lt;input /&gt;</code>, React will set current property to the corresponding DOM node:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;myRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// You can use any browser APIs, for example:</span></span><br><span class="line"><span class="language-xml">myRef.current.scrollIntoView();</span></span><br></pre></td></tr></table></figure>
<p>When you put a ref on your own component, by default you will get <code>null</code>. Instead, your component should forwards the ref from props to one of its built-in component.</p>
<h3 id="11-2-Ref-Callback"><a href="#11-2-Ref-Callback" class="headerlink" title="11.2 Ref Callback"></a>11.2 Ref Callback</h3><p>Since hooks must only be called at the top-level of component. You can&#39;t call <code>useRef</code> in a loop, in a condition, or inside a <code>map()</code> call. The solution is to pass a function to the <code>ref</code> attribute. React will call your <code>ref callback</code> with the DOM node when it’s time to set the ref, and with null when it’s time to clear it.</p>
<h2 id="12-Hooks"><a href="#12-Hooks" class="headerlink" title="12. Hooks"></a>12. Hooks</h2><p>Problem:</p>
<ul>
<li>hard to reuse stateful logic between components: render props and higher-order components needs to restructure your components, and causes wrapper hell. Hooks allow you to reuse stateful logic without changing your component hierarchy.</li>
<li>Complex components become hard to understand: Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in <code>componentDidMount</code> and <code>componentDidUpdate</code>. However, the same <code>componentDidMount</code> method might also contain some unrelated logic that sets up event listeners, with cleanup performed in <code>componentWillUnmount</code>. Hooks split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data)</li>
</ul>
<h3 id="12-2-State-Hook"><a href="#12-2-State-Hook" class="headerlink" title="12.2 State Hook"></a>12.2 State Hook</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    initialState: The value you want the state to be initially</span></span><br><span class="line"><span class="comment"> * return:</span></span><br><span class="line"><span class="comment"> *    state: During the first render, it will match the initialState you have passed</span></span><br><span class="line"><span class="comment"> *    setState: lets you update the state to a different value and trigger a re-render</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = <span class="title function_">useState</span>(initialState);</span><br></pre></td></tr></table></figure>
<p>Returns a stateful value, and a function to update it(<code>setState</code>). During the initial render, the returned state (<code>state</code>) is the same as the value passed as the first argument (<code>initialState</code>).<br>The <code>setState</code> function is used to update the state:</p>
<ul>
<li>accept a new state value and enqueues a re-render of the component.</li>
<li>accept a function which will receive the previous value, and return an updated value</li>
</ul>
<p>Others:</p>
<ul>
<li>Lazy initial state: If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render.</li>
<li>If you update a state to the same value as the current state, React will not re-render the children or trigger effects</li>
</ul>
<h3 id="12-3-Effect-Hook"><a href="#12-3-Effect-Hook" class="headerlink" title="12.3 Effect Hook"></a>12.3 Effect Hook</h3><p>In React class components, the <code>render</code> method itself shouldn&#39;t cause side effects. We typically want to perform our effects after React has updated the DOM. This is why React class puts side effects into <code>componentDidMount</code> and <code>componentDidUpdate</code>.<br>Problem:</p>
<ul>
<li><code>componentDidMount</code> and <code>componentDidUpdate</code> may have the same code</li>
<li><code>componentDidMount</code> and <code>componentWillUnmount</code> need to mirror each other</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    * setup: When component is added to the DOM, React will run your setup function. After</span></span><br><span class="line"><span class="comment"> *      every re-render with changed dependencies, React will first run the cleanup function</span></span><br><span class="line"><span class="comment"> *      with old value (if provided), then run the setup function with the new values.</span></span><br><span class="line"><span class="comment"> *    * dependencies (optional): The list of all reactive values referenced inside of the</span></span><br><span class="line"><span class="comment"> *      setup code. Reactive values include props, state, and all the variables and </span></span><br><span class="line"><span class="comment"> *      functions declared directly inside your component body. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">useEffect</span>(setup, dependencies?);</span><br></pre></td></tr></table></figure>
<p>So we can place all code related with re-render in <code>useEffect</code>, instead of three places:</p>
<ul>
<li>Skip second argument: <code>useEffect</code> runs both after the first render and after every update. Instead of thinking in terms of &quot;mounting&quot; and &quot;updating&quot;, you might find it easier to think that effects happen &quot;after render&quot;.</li>
<li>Pass an array as second argument: React will re-run the effect if one of values in array is updated, usually using props and state</li>
<li>empty array as second argument: React will only run the effect when mount and unmount component</li>
</ul>
<h3 id="12-4-Memo-Hook"><a href="#12-4-Memo-Hook" class="headerlink" title="12.4 Memo Hook"></a>12.4 Memo Hook</h3><p><code>useMemo</code> will only recompute the memoized value when one of the dependencies has changed. <code>useMemo</code> is a tool for optimizing rendering performance.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    * calculateValue: The function calculating the value that you want to cache. It should</span></span><br><span class="line"><span class="comment"> *      take no arguments, and should return a value of any type. React will call your</span></span><br><span class="line"><span class="comment"> *      function during the initial render. On next renders, React will return the same </span></span><br><span class="line"><span class="comment"> *      value again if the dependencies have not changed since the last render.</span></span><br><span class="line"><span class="comment"> *    * dependencies: The list of all reactive values. Reactive values include props, state,</span></span><br><span class="line"><span class="comment"> *      and all the variables and functions declared directly inside your component body.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> cachedValue = <span class="title function_">useMemo</span>(calculateValue, dependencies)</span><br></pre></td></tr></table></figure>
<p>Usage:</p>
<ul>
<li>Skipping expensive recalculations: For example, component A has two child components, B and C. When A&#39; state changes, triggering a re-render. At this point, both B and C also re-render. By employing <code>useMemo</code>, only when the props used by B change, B will be re-rendered, while C will remain unaffected.</li>
<li>Skipping re-rendering of components: For example, component A passes prop to its child component. By default, when a component re-renders, React re-renders all of its children recursively. If re-render is slow, you can put calculation in <code>useMemo</code> to ensure that it has the same value between the re-renders (until dependencies change).</li>
</ul>
<h3 id="12-5-Context-Hook"><a href="#12-5-Context-Hook" class="headerlink" title="12.5 Context Hook"></a>12.5 Context Hook</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    * SomeContext: The context that you’ve previously created with React.createContext</span></span><br><span class="line"><span class="comment"> * return: the context value for the calling component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="title function_">useContext</span>(<span class="title class_">SomeContext</span>);</span><br></pre></td></tr></table></figure>
<p>The current context value is determined by the <code>value</code> prop of the nearest <code>&lt;MyContext.Provider&gt;</code> above the calling component in the tree.<br>When the nearest <code>&lt;MyContext.Provider&gt;</code> above the component updates, this Hook will trigger a rerender with the latest context <code>value</code> passed to that <code>MyContext</code> provider.</p>
<p>Usage:</p>
<ul>
<li>Passing data deeply into the tree</li>
<li>Updating data passed via context: pass the current state as the context value to the provider.</li>
<li>Specifying a fallback default value</li>
<li>Overriding context for a part of the tree</li>
<li>Optimizing re-renders when passing objects and functions</li>
</ul>
<h3 id="12-6-Ref-Hook"><a href="#12-6-Ref-Hook" class="headerlink" title="12.6 Ref Hook"></a>12.6 Ref Hook</h3><p><code>useRef</code> is a React Hook that lets you reference a value that&#39;s not needed for rendering.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    initialValue: The value you want the ref object&#x27;s current property to be initially.</span></span><br><span class="line"><span class="comment"> *    current: Initially, it&#x27;s set to the initialValue you have passed</span></span><br><span class="line"><span class="comment"> * return: returns an object, will persist for the full lifetime of the component.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> ref = <span class="title function_">useRef</span>(initialValue)</span><br></pre></td></tr></table></figure>
<p>Differences between refs and other variable:</p>
<ul>
<li>Regular variable will reset on every render; ref will be the same between each re-renders</li>
<li>chaninge state variable will trigger a re-render; changing ref does not trigger a re-render</li>
<li>outside variable are shared by all components; ref is local to each copy of your component</li>
</ul>
<p>Caveats: you can modify and update the <code>current</code> value outside of the rendering process, but shouldn&#39;t read or write the <code>current</code> value during rendering.</p>
<p>When to use refs:</p>
<ul>
<li>Storing timeout ID (setTimeout)</li>
<li>Storing and manipulating DOM elements</li>
<li>Storing other objects that aren’t necessary to calculate the JSX</li>
</ul>
<h3 id="12-7-Reducer-Hook"><a href="#12-7-Reducer-Hook" class="headerlink" title="12.7 Reducer Hook"></a>12.7 Reducer Hook</h3><p><code>useReducer</code> is an alternative to <code>useState</code>. Accepts a reducer of type <code>(state, action) =&gt; newState</code>, and returns the current state paired with a <code>dispatch</code> method.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<p><code>useReducer</code> is preferable to <code>useState</code> when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>  (<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-8-Layout-Hook"><a href="#12-8-Layout-Hook" class="headerlink" title="12.8 Layout Hook"></a>12.8 Layout Hook</h3><p><code>useLayoutEffect</code> is a version of <code>useEffect</code> that fires before the browser repaints the screen.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * params:</span></span><br><span class="line"><span class="comment"> *    setup: The function with your Effect&#x27;s logic.</span></span><br><span class="line"><span class="comment"> *    dependencies (optional): The list of all reactive values referenced inside of the `setup` code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">useLayoutEffect</span>(setup, dependencies?)</span><br></pre></td></tr></table></figure>
<p><code>useLayoutEffect</code> vs <code>useEffect</code>:</p>
<ul>
<li><code>useLayoutEffect</code> blocks the browser from repainting</li>
<li><code>useEffect</code> does not block the browser</li>
</ul>
<p>Caveats:</p>
<ul>
<li><code>useLayoutEffect</code> is a Hook, so you can only call it at the top level of your component or your own Hooks</li>
<li>Effects only run on the client. They don’t run during server rendering.</li>
</ul>
<p>Usage: Measuring layout before the browser repaints the screen</p>
<h2 id="13-Strict-Mode"><a href="#13-Strict-Mode" class="headerlink" title="13. Strict Mode"></a>13. Strict Mode</h2><p><code>StrictMode</code> is a tool for highlighting potential problems:</p>
<ul>
<li>Identify unsafe lifecycles: certain legacy lifecycle methods(e.g. <code>componentWillMount</code>, <code>componentWillReceiveProps</code>, <code>componentWillUpdate</code>) are unsafe, if your application uses third party libraries, it can be difficult to ensure that these lifecycles aren&#39;t being used</li>
<li>Warning about legacy string ref API usage</li>
<li>Warning about deprecated findDOMNode usage: you can attach a ref directly to a DOM node</li>
<li>Detecting unexpected side effects: </li>
<li>Detecting legacy context API</li>
<li>Ensuring reusable state</li>
</ul>
<h2 id="14-Rules-of-React"><a href="#14-Rules-of-React" class="headerlink" title="14. Rules of React"></a>14. Rules of React</h2><ul>
<li>Components and Hooks must be pure: A component or hook should follow the rules:<ul>
<li>Idempotent: always get the same result when run it with the same inputs (props, state, context amd hook input)</li>
<li>No side effects in render: Code with side effects should run in event handler or useEffect</li>
<li>Does not change non-local values</li>
</ul>
</li>
<li>React calls Components and Hooks:<ul>
<li>Never call component functions directly<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BlogPost</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span>&#123;Article()&#125;<span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span>; <span class="comment">// Wrong: Never call them directly</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Never pass around Hooks as regular values</li>
</ul>
</li>
<li>Only call Hooks at the top level</li>
<li>Only call Hooks from React functions</li>
</ul>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Full-Stack/">Full Stack</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/46eb.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">Spring Transaction</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/2f11.html">
        <span class="next-text nav-default">DP - Multidimensional Knapsack Problem</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/9de.html';
  var disqus_title = "React.js";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
