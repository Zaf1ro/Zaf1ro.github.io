<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="Name and Address Conversions"/>




  <meta name="keywords" content="Network," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/2b71.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/2b71.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/2b71.html"/>


<meta name="description" content="1. Domain Name Syste (DNS)DNS用于映射hostname和IP address. hostname可以是简单的solaris或freebsd, 或FQDN(fully qualified domain name), 例如solaris.unpbook.com.FQDN也称为absolute name, 必须以句号结尾(punctuation mark), DNA用户通常会">
<meta property="og:type" content="article">
<meta property="og:title" content="Name and Address Conversions">
<meta property="og:url" content="https://zaf1ro.github.io/p/2b71.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. Domain Name Syste (DNS)DNS用于映射hostname和IP address. hostname可以是简单的solaris或freebsd, 或FQDN(fully qualified domain name), 例如solaris.unpbook.com.FQDN也称为absolute name, 必须以句号结尾(punctuation mark), DNA用户通常会">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/Network/UNP/11-1-cli-resolver-and-name-svr.gif">
<meta property="og:image" content="https://zaf1ro.github.io/images/Network/UNP/11-2-hostent-struct.gif">
<meta property="og:image" content="https://zaf1ro.github.io/images/Network/UNP/11-2-return-of-getaddrinfo.jpg">
<meta property="og:image" content="https://zaf1ro.github.io/images/Network/UNP/11-2-summary-of-getaddrinfo.jpg">
<meta property="article:published_time" content="2019-12-22T15:03:42.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.041Z">
<meta property="article:tag" content="Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/Network/UNP/11-1-cli-resolver-and-name-svr.gif">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
Name and Address Conversions - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Domain-Name-Syste-DNS"><span class="toc-text">1. Domain Name Syste (DNS)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Resource-Records"><span class="toc-text">1.1 Resource Records</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Resolvers-and-Name-Server"><span class="toc-text">1.2 Resolvers and Name Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-DNS-Alternatives"><span class="toc-text">1.3 DNS Alternatives</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-gethostbyname-Function"><span class="toc-text">2. gethostbyname Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-gethostbyaddr-Function"><span class="toc-text">3. gethostbyaddr Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-getservbyname-and-getservbyport-Functions"><span class="toc-text">4. getservbyname and getservbyport Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-getaddrinfo-Function"><span class="toc-text">5. getaddrinfo Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-gai-strerror-Function"><span class="toc-text">6. gai_strerror Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-freeaddrinfo-Function"><span class="toc-text">7. freeaddrinfo Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-getaddrinfo-Function-IPv6"><span class="toc-text">8. getaddrinfo Function: IPv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-getaddrinfo-Function-Examples"><span class="toc-text">9. getaddrinfo Function: Examples</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-host-serv-Function"><span class="toc-text">10. host_serv Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-tcp-connect-Function"><span class="toc-text">11. tcp_connect Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-tcp-listen-Function"><span class="toc-text">12. tcp_listen Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-udp-client-Function"><span class="toc-text">13. udp_client Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-udp-connect-Function"><span class="toc-text">14. udp_connect Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-udp-server-Function"><span class="toc-text">15. udp_server Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-getnameinfo-Function"><span class="toc-text">16. getnameinfo Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Re-entrant-Functions"><span class="toc-text">17. Re-entrant Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-gethostbyname-r-and-gethostbyaddr-r-Functions"><span class="toc-text">18. gethostbyname_r and gethostbyaddr_r Functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Obsolete-IPv6-Address-Lookup-Functions"><span class="toc-text">19. Obsolete IPv6 Address Lookup Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-1-RES-USE-INET6-Constant"><span class="toc-text">19.1 RES_USE_INET6 Constant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-gethostbyname2-Function"><span class="toc-text">19.2 gethostbyname2 Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-getipnodebyname-Function"><span class="toc-text">19.3 getipnodebyname Function</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Other-Networking-Information"><span class="toc-text">20. Other Networking Information</span></a></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Name and Address Conversions
        
      </h1>
      <time class="post-time">
          12/22/19
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Domain-Name-Syste-DNS"><a href="#1-Domain-Name-Syste-DNS" class="headerlink" title="1. Domain Name Syste (DNS)"></a>1. Domain Name Syste (DNS)</h2><p>DNS用于映射hostname和IP address. hostname可以是简单的solaris或freebsd, 或<strong>FQDN</strong>(fully qualified domain name), 例如solaris.unpbook.com.<br>FQDN也称为absolute name, 必须以句号结尾(punctuation mark), DNA用户通常会忽略最后的句号. 最后的句号用于通知resolver这是一个FQDN, 无需搜索可能的所有domain.</p>
<h3 id="1-1-Resource-Records"><a href="#1-1-Resource-Records" class="headerlink" title="1.1 Resource Records"></a>1.1 Resource Records</h3><p>DNS中的entry被称为resource record(RR), 以下是几种常见的RR:</p>
<ol>
<li>A: A record将hostname映射为32-bit IPv4 address. 对于host为freebsd, domain为unpbook.com, 其A record为: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">freebsd IN A    12.106.32.254</span><br><span class="line">        IN AAAA 3ffe:b80:1f8d:1:a00:20ff:fea7:686b</span><br><span class="line">        IN MX   5 freebsd.unpbook.com.</span><br><span class="line">        IN MX   10 mailhost.unpbook.com.</span><br></pre></td></tr></table></figure></li>
<li>AAAA: AAAA record将hostname映射为128-bit IPv6 address. <strong>AAAA</strong>表示4倍的32-bit address, 也就是128-bit address</li>
<li>PTR: PTR record将IP address映射为hostname. 例如: 对于freebsd host, 其两个PTR为<code>254.32.106.12.in-addr.arpa</code>和<code>b.6.8.6.7.a.e.f.f.f.0.2.0.0.a.0.1.0.0.0.d.8.f.1.0.8.b.0.e.f.f.3.ip6.arpa</code></li>
<li>MX: MX record标注某个host作为mail exchanger. 一个host可有多个MX record, 每个MX record有不同preference value, 按照从小到大排序.</li>
<li>CNAME: canonical name, 将一个hostname映射为另一个hostname.</li>
</ol>
<h3 id="1-2-Resolvers-and-Name-Server"><a href="#1-2-Resolvers-and-Name-Server" class="headerlink" title="1.2 Resolvers and Name Server"></a>1.2 Resolvers and Name Server</h3><p><strong>Name server</strong>会运行network service, 保存DNS record, 并回应请求. 而被client和server用于与name server通信的工具称为<strong>resolver</strong>, 通常为<code>gethostbyname()</code>和<code>gethostbyaddr()</code>, 前者用于将hostname映射为IPv4 address, 后者用于将IPv4 address映射为hostname.<br><img src="/images/Network/UNP/11-1-cli-resolver-and-name-svr.gif" alt="Typical arrangement of clients, resolvers, and name servers"></p>
<p>上图表示application, resolver和name server之间的关系. 对于用户来说, 只需要在application code中调用resolver APIs即可. Resolver code会读取系统中的configuration file决定从哪个name server获取record, local name server的IP address通常保存在<code>/etc/resolv.conf</code>文件中. Local name server接收到请求后, 如果回复准确答案, 则向更高级的name serber发送请求. 通常情况下, DNS请求和回复为UDP, 如果数据过大, 会自动切换为TCP.</p>
<h3 id="1-3-DNS-Alternatives"><a href="#1-3-DNS-Alternatives" class="headerlink" title="1.3 DNS Alternatives"></a>1.3 DNS Alternatives</h3><p>在不使用DNS的情况, 也可以通过<strong>static host file</strong>(通常为<code>/etc/hosts</code>文件), <strong>NIS</strong>(Network Information System)或<strong>LDAP</strong>(Lightweight Directory Access Protocol)获取hostname和IP address. 但尤其每个系统实现不用, 使用的方法也有所不同, 因此需要通过resolver functions作为统一解决方案.</p>
<h2 id="2-gethostbyname-Function"><a href="#2-gethostbyname-Function" class="headerlink" title="2. gethostbyname Function"></a>2. gethostbyname Function</h2><p>无论调用<code>connect()</code>还是<code>sendto()</code>, 都需要知道对端的IP address, 但IP address不好记忆, 尤其是IPv6 address, 且随时可能更改, 因此需要通过将hostname映射为对应的IP address.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line"> <span class="type">char</span> *h_name;       <span class="comment">/* canonical name of host */</span></span><br><span class="line"> <span class="type">char</span> **h_aliases;   <span class="comment">/* ptr to array of ptrs to alias names */</span></span><br><span class="line"> <span class="type">int</span> h_addrtype;     <span class="comment">/* host address type: AF_INET */</span></span><br><span class="line"> <span class="type">int</span> h_length;       <span class="comment">/* length of address: 4 */</span></span><br><span class="line"> <span class="type">char</span> **h_addr_list; <span class="comment">/* ptr to array of ptrs with IPv4 addrs */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief return a structure of hostent for the given hostname</span></span><br><span class="line"><span class="comment"> * @param name: a hostname or an IPv4 address.</span></span><br><span class="line"><span class="comment"> *        1. If name ia an IPv4 address, just copy name into </span></span><br><span class="line"><span class="comment"> *           the h_name field and h_addr_list[0] field of hostent</span></span><br><span class="line"><span class="comment"> *        2. If name doesn&#x27;t end in a dot, the current domain </span></span><br><span class="line"><span class="comment"> *           and its parent will be searched</span></span><br><span class="line"><span class="comment"> *        3. If name ends in a dot, only the current domain will</span></span><br><span class="line"><span class="comment"> *           be searched</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p><code>gethostbyname()</code>只返回IPv4 address, 因此该函数会随着IPv6的普及而逐渐消失, 推荐使用<code>getaddrinfo()</code>代替. 以下是<strong>hostent</strong>的结构图:<br><img src="/images/Network/UNP/11-2-hostent-struct.gif" alt="hostent structure and the information it contains"></p>
<p>其中, <code>h_name</code>表示host的canonical name. 例如: 当对<code>solaris</code>调用<code>gethostbyname()</code>时, 其FQDN为<code>solaris.unpbook.com</code>, 也就是其canonical name. 不同于其他socket function, 出错时<code>gethostbyname()</code>不会设置errno, 而是在h_errno上设置以下常量:</p>
<ul>
<li>HOST_NOT_FOUND: 找不到host</li>
<li>TRY_AGAIN: name server发生临时错误, 需要重新发送请求</li>
<li>NO_RECOVERY: name server发生不可恢复的错误</li>
<li>NO_DATA: host存在, 但name server中没有对应的IP address, 例如hostname只有MX record</li>
</ul>
<h2 id="3-gethostbyaddr-Function"><a href="#3-gethostbyaddr-Function" class="headerlink" title="3. gethostbyaddr Function"></a>3. gethostbyaddr Function</h2><p><code>gethostbyaddr()</code>用于将IPv4 address映射为hostname, 与<code>gethostbyname()</code>功能相反.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief return a structure of hostent for the  </span></span><br><span class="line"><span class="comment"> *        given host address `addr` of lengh `len`</span></span><br><span class="line"><span class="comment"> *        and address type `type`</span></span><br><span class="line"><span class="comment"> * @param addr a pointer to an in_addr structure </span></span><br><span class="line"><span class="comment"> *        containing IPv4 address</span></span><br><span class="line"><span class="comment"> * @param len the size of in_addr structure</span></span><br><span class="line"><span class="comment"> * @param type AF_INET</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">socklen_t</span> len, </span></span><br><span class="line"><span class="params">                              <span class="type">int</span> type)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="4-getservbyname-and-getservbyport-Functions"><a href="#4-getservbyname-and-getservbyport-Functions" class="headerlink" title="4. getservbyname and getservbyport Functions"></a>4. getservbyname and getservbyport Functions</h2><p>Service和host一样, 都可以通过name标记, 每个service都有自己的name和port number, 因此查找一个service即可通过其name, 也可以通过port number.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *s_name;     <span class="comment">/* official service name */</span></span><br><span class="line">  <span class="type">char</span> **s_aliases; <span class="comment">/* alias list */</span></span><br><span class="line">  <span class="type">int</span> s-port;       <span class="comment">/* port number, network-byte order */</span></span><br><span class="line">  <span class="type">char</span> *s_proto;    <span class="comment">/* protocol to use */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief return a servent structure that matches </span></span><br><span class="line"><span class="comment"> *        the service name and protocol type</span></span><br><span class="line"><span class="comment"> * @param name service name</span></span><br><span class="line"><span class="comment"> * @param proto If proto is NULL, any protocol will</span></span><br><span class="line"><span class="comment"> *        be matched</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief return a servent structure that matches </span></span><br><span class="line"><span class="comment"> *        the port number and protocol type</span></span><br><span class="line"><span class="comment"> * @param port: port number</span></span><br><span class="line"><span class="comment"> * @param proto: same as proto in getservbyname()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br></pre></td></tr></table></figure>
<p>以下程序使用<code>gethostbyname()</code>和<code>getservbyname()</code>来实现一个简易client:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* first command-line argument: hostname </span></span><br><span class="line"><span class="comment"> * second command-line argument: service name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>                sockfd, n;</span><br><span class="line">  <span class="type">char</span>               recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>     **<span class="title">pptr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>     *<span class="title">inetaddrp</span>[2];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>     <span class="title">inetaddr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>     *<span class="title">hp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">servent</span>     *<span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;usage: daytimetcpcli1 &lt;hostname&gt; &lt;service&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* list all IP addresses for the hostname */</span></span><br><span class="line">  <span class="keyword">if</span> ( (hp = gethostbyname(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inet_aton(argv[<span class="number">1</span>], &amp;inetaddr) == <span class="number">0</span>) &#123;</span><br><span class="line">      err_quit(<span class="string">&quot;hostname error for %s: %s&quot;</span>, argv[<span class="number">1</span>], </span><br><span class="line">               hstrerror(h_errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inetaddrp[<span class="number">0</span>] = &amp;inetaddr;</span><br><span class="line">      inetaddrp[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">      pptr = inetaddrp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pptr = (<span class="keyword">struct</span> in_addr **) hp-&gt;h_addr_list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get the port number of the server */</span></span><br><span class="line">  <span class="keyword">if</span> ( (sp = getservbyname(argv[<span class="number">2</span>], <span class="string">&quot;tcp&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;getservbyname error for %s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( ; *pptr != <span class="literal">NULL</span>; pptr++) &#123;</span><br><span class="line">    sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = sp-&gt;s_port;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;servaddr.sin_addr, *pptr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;trying %s\n&quot;</span>, Sock_ntop((SA *) &amp;servaddr, </span><br><span class="line">           <span class="keyword">sizeof</span>(servaddr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if connect succeeds, terminate the loop */</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (SA *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* success */</span></span><br><span class="line">    err_ret(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">    close(sockfd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* no call to connect succeeded */</span></span><br><span class="line">  <span class="keyword">if</span> (*pptr == <span class="literal">NULL</span>) err_quit(<span class="string">&quot;unable to connect&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( (n = Read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    recvline[n] = <span class="number">0</span>;  <span class="comment">/* null terminate */</span></span><br><span class="line">    Fputs(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-getaddrinfo-Function"><a href="#5-getaddrinfo-Function" class="headerlink" title="5. getaddrinfo Function"></a>5. getaddrinfo Function</h2><p><code>gethostbyname()</code>和<code>gethostbyaddr()</code>不支持IPv4, 如果需要解析IPv6 address, 需要使用<code>getaddrinfo()</code>实现name-to-address和service-to-port, 定义于POSIX specification.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>             ai_flags;      <span class="comment">/* additional options using OR */</span></span><br><span class="line">  <span class="type">int</span>             ai_family;     <span class="comment">/* AF_xxx */</span></span><br><span class="line">  <span class="type">int</span>             ai_socktype;   <span class="comment">/* SOCK_xxx */</span></span><br><span class="line">  <span class="type">int</span>             ai_protocol;   <span class="comment">/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class="line">  <span class="type">socklen_t</span>       ai_addrlen;    <span class="comment">/* length of ai_addr */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>      <span class="comment">/* ptr to socket address structure */</span></span><br><span class="line">  <span class="type">char</span>            *ai_canonname; <span class="comment">/* ptr to canonical name for host */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span>      <span class="comment">/* ptr to next structure in linked list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief return one or more addrinfo structures, </span></span><br><span class="line"><span class="comment"> *        each of which contains an Internet </span></span><br><span class="line"><span class="comment"> *        address pointed to by `result`</span></span><br><span class="line"><span class="comment"> * @param hostname a hostname or an address string</span></span><br><span class="line"><span class="comment"> *        (dotted-decimal for IPv4 or a hex string </span></span><br><span class="line"><span class="comment"> *        for IPv6)</span></span><br><span class="line"><span class="comment"> * @param service a service name or a decimal port </span></span><br><span class="line"><span class="comment"> *        number string</span></span><br><span class="line"><span class="comment"> * @param hints a null pointer or a pointer to an </span></span><br><span class="line"><span class="comment"> *        addrinfo structure that the caller fills </span></span><br><span class="line"><span class="comment"> *        in with hints about the types of </span></span><br><span class="line"><span class="comment"> *        information the caller wants returned</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints, </span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo **result)</span>;</span><br></pre></td></tr></table></figure>
<p>其中, <code>ai_flags</code>的可选项如下:</p>
<ul>
<li>AI_PASSIVE: 若设置该flag, 则result返回的address应能用于<code>bin()</code>, <code>listen()</code>, 或<code>accept()</code>, 也就是说, 该address用于passive socket.</li>
<li>AI_NUMERICHOST: 让<code>getaddrinfo()</code>返回canonical name</li>
<li>AI_NUMERICSERV: hostname参数必须为address string, 不能为hostname</li>
<li>AI_V4MAPPED: 该option一般与<code>ai_family</code>设置为AF_INET6一同使用, 保证AAAA record无法找到时返回A record. </li>
<li>AI_ALL: 与AI_V4MAPPED一同使用, 返回hostname下的A record和AAAA record.</li>
<li>AI_ADDRCONFIG: 若存在多个端口, 只返回给定IP version的IP address.</li>
</ul>
<p><code>hints</code>参数中除了ai_flags, 还可修改其他属性:</p>
<ul>
<li>ai_family</li>
<li>ai_socktype</li>
<li>ai_protocol</li>
</ul>
<p>若<code>hints</code>为NULL, 则ai_flags, ai_socktype, ai_protocol都为0, 且ai_family为AF_UNSPEC.<br><code>getaddrinfo()</code>返回一个链表, 其中每个node都表示一个addrinfo structure, 以下两种情况会导致返回多个nodes:</p>
<ol>
<li>hostname下存在多个addresses, 每个addrinfo structure包含一个address</li>
<li>service下存在多个socket type, 每个addrinfo strcuture包含一种socket type</li>
</ol>
<p>假设某一host下有两个IP address, 有4个addrinfo structures返回:</p>
<ul>
<li>第一个IP address且socket type为<code>SOCK_STREAM</code></li>
<li>第一个IP address且socket type为<code>SOCK_DGRAM</code></li>
<li>第二个IP address且socket type为<code>SOCK_STREAM</code></li>
<li>第二个IP address且socket type为<code>SOCK_DGRAM</code></li>
</ul>
<p><img src="/images/Network/UNP/11-2-return-of-getaddrinfo.jpg" alt="Example of information returned by getaddrinfo"></p>
<p>若hints参数中设置了AI_CANONNAME flag, 返回的第一个addrinfo中的<code>ai_canonname</code>会返回host的canonical name. hints参数中的ai_protocol可选项如下:</p>
<ul>
<li>IPPROTO_IP: 0</li>
<li>IPPROTO_IPV4: 4</li>
<li>IPPROTO_IPV6: 41</li>
<li>IPPROTO_UDP: 17</li>
<li>IPPROTO_TCP: 6</li>
</ul>
<p>ai_socktype的可选项如下:</p>
<ul>
<li>0: any type of socket type can be returned</li>
<li>SOCK_STREAM: connection-based byte stream</li>
<li>SOCK_DGRAM: connectionless, unreliable datagram</li>
</ul>
<p>以下是不同service和ai_socktype下addrinfo structure的返回数量:</p>
<table>
<thead>
<tr>
<th align="center">ai_socktype</th>
<th align="center">TCP only</th>
<th align="center">UDP only</th>
<th align="center">TCP and UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">SOCK_STREAM</td>
<td align="center">1</td>
<td align="center">error</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">SOCK_DGRAM</td>
<td align="center">error</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p><code>getaddrinfo()</code>主要用于以下方法:</p>
<ul>
<li>可被TCP或UDP client用于解析hostname和service. TCP client会调用<code>socket()</code>和<code>connect()</code>遍历所有IP addresses, 直到成功连接某个IP address; UDP client也可以使用<code>sendto()</code>或<code>connect()</code>尝试向多个IP address发送请求.</li>
<li>若client只需要处理特定socket type, 则可以通过hint参数中的ai_socktype标记socket type</li>
<li>server一般会指定service, 并将hostname置为NULL, 且在hints参数中标记<code>AI_PASSIVE</code> flag, 返回的socket address structure应该包含<code>INADDR_ANY</code>(Ipv4)或<code>IN6ADDR_ANY_INIT</code>(IPv6)</li>
<li>若server调用<code>recvfrom()</code>获得client的socket address structure, 其中ai_addrlen表示大小</li>
<li>若server只处理特定socket type, 可使用hints参数中的ai_socktype指定socket type</li>
<li>TCP和UDP server可使用<code>select()</code>或<code>poll()</code>对<code>getaddrinfo()</code>返回的每个IP address分别创建listening socket</li>
</ul>
<h2 id="6-gai-strerror-Function"><a href="#6-gai-strerror-Function" class="headerlink" title="6. gai_strerror Function"></a>6. gai_strerror Function</h2><p><code>gai_strerror()</code>可将<code>getaddrinfo()</code>返回的错误值转换为响应字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief address and name information error description</span></span><br><span class="line"><span class="comment"> * @param error shall be one of the following values:</span></span><br><span class="line"><span class="comment"> *        * EAI_AGAIN: Temporary failure in name resolution</span></span><br><span class="line"><span class="comment"> *        * EAI_BADFLAGS: Invalid value for ai_flags</span></span><br><span class="line"><span class="comment"> *        * EAI_FAIL: Unrecoverable failure in name resolution</span></span><br><span class="line"><span class="comment"> *        * EAI_FAMILY: ai_family not supported</span></span><br><span class="line"><span class="comment"> *        * EAI_MEMORY: Memory allocation failure</span></span><br><span class="line"><span class="comment"> *        * EAI_NONAME: hostname or service not provided, </span></span><br><span class="line"><span class="comment"> *          or not known</span></span><br><span class="line"><span class="comment"> *        * EAI_OVERFLOW: User argument buffer overflowed</span></span><br><span class="line"><span class="comment"> *        * EAI_SERVICE: service not supported for ai_socktype</span></span><br><span class="line"><span class="comment"> *        * EAI_SOCKTYPE: ai_socktype not supported</span></span><br><span class="line"><span class="comment"> *        * EAI_SYSTEM: System error returned in errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span> <span class="params">(<span class="type">int</span> error)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="7-freeaddrinfo-Function"><a href="#7-freeaddrinfo-Function" class="headerlink" title="7. freeaddrinfo Function"></a>7. freeaddrinfo Function</h2><p><code>getaddrinfo()</code>中的addrinfo structure是动态分配的, 这时需要调用<code>freeaddrinfo()</code>释放内存.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief free the memory that was allocated for </span></span><br><span class="line"><span class="comment"> *        the dynamically allocated linked list</span></span><br><span class="line"><span class="comment"> * @param ai point to the first addrindfo structure </span></span><br><span class="line"><span class="comment"> *        returned by getaddrinfo(). All the structures</span></span><br><span class="line"><span class="comment"> *        in the linked list are freed, along with any </span></span><br><span class="line"><span class="comment"> *        dynamic storaged pointed to by other structures</span></span><br><span class="line"><span class="comment"> *        (socket address structure and canonical hostname)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span> <span class="params">(<span class="keyword">struct</span> addrinfo *ai)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="8-getaddrinfo-Function-IPv6"><a href="#8-getaddrinfo-Function-IPv6" class="headerlink" title="8. getaddrinfo Function: IPv6"></a>8. getaddrinfo Function: IPv6</h2><p><img src="/images/Network/UNP/11-2-summary-of-getaddrinfo.jpg" alt="Summary of getaddrinfo and its actions and results"></p>
<ul>
<li><code>getaddrinfo()</code>主要应对两种输入: socket address structure的类型, 需要从DNS或其他数据库中搜索的record类型</li>
<li><code>hints</code>参数中的ai_family表示返回的socket address structure类型. 若ai_family为AF_INET, 则返回的addrinfo structure中的ai_addr不能为sockaddr_in6; 同理, 若ai_family为AF_INET6, 则不能返回sockaddr_in.</li>
<li>若<code>hints</code>参数中的ai_family为<code>AF_UNSPEC</code>, 则返回所有查到的protocol family</li>
<li>若ai_flags设置了AI_PASSIVE且没有设置hostname, 则在sockaddr_in6中返回IPv6 wildcard address(IN6ADDR_ANY_INIT), sockaddr_in structure中返回 IPv4 wildcard address(INADDR_ANY)</li>
<li>hints参数中的ai_family和ai_flags用于标识搜索DNS中的record类型和返回的地址类型, 如上图表格所示.</li>
<li>hostname可谓IPv6 hex string或IPv4 dotted-decimal string, 但必须与ai_family匹配: IPv6 hex string不能与AF_INET一起输入, IPv4 dotted-decimal string和AF_INET6不能一起输入, 但AF_UNSPEC可以与任何IP address组合.</li>
</ul>
<h2 id="9-getaddrinfo-Function-Examples"><a href="#9-getaddrinfo-Function-Examples" class="headerlink" title="9. getaddrinfo Function: Examples"></a>9. getaddrinfo Function: Examples</h2><p>假设某程序使用<code>getaddrinfo()</code>, 并可接收以下参数: hostname, service name, address family, socket type, AI_CANONNAME flag. 其中, <code>-f</code>表示address family, <code>-c</code>表示canonical name, <code>-h</code>表示hostname, <code>-s</code>表示service name, <code>-t</code>表示socket type.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">% testga -f inet -c -h freebsd4 -s domain</span><br><span class="line">socket (AF_INET, SOCK_DGRAM, 17), ai_canonname = freebsd4.unpbook.com</span><br><span class="line">       address: 135.197.17.100:53</span><br><span class="line">socket (AF_INET, SOCK_DGRAM, 17)</span><br><span class="line">       address: 172.24.37.94:53</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6), ai_canonname = freebsd4.unpbook.com</span><br><span class="line">       address: 135.197.17.100:53</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6)</span><br><span class="line">       address: 172.24.37.94:53</span><br></pre></td></tr></table></figure>
<p>也可以指定socket type来获取host上的所有IPv4 addresses:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">% testga -f inet -t stream -h gateway.tuc.noao.edu -s daytime</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6)</span><br><span class="line">       address: 140.252.108.1:13</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6)</span><br><span class="line">       address: 140.252.1.4:13</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6)</span><br><span class="line">       address: 140.252.104.1:13</span><br></pre></td></tr></table></figure>
<p>通过不指定address family, 可获取host上的所有IPv4和IPv6 address:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">freebsd % testga -h aix -s ftp -t stream</span><br><span class="line">socket (AF_INET6, SOCK_STREAM, 6)</span><br><span class="line">       address: [3ffe:b80:1f8d:2:204:acff:fe17:bf38]:21</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6)</span><br><span class="line">       address: 192.168.42.2:21</span><br></pre></td></tr></table></figure>
<p>通过设置AI_PASSIVE flag可获取wildcard address:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">% testga -p -s 8888 -t stream</span><br><span class="line">socket (AF_INET6, SOCK_STREAM, 6)</span><br><span class="line">       address: [: :]: 8888</span><br><span class="line">socket (AF_INET, SOCK_STREAM, 6)</span><br><span class="line">       address: 0.0.0.0:8888</span><br></pre></td></tr></table></figure>


<h2 id="10-host-serv-Function"><a href="#10-host-serv-Function" class="headerlink" title="10. host_serv Function"></a>10. host_serv Function</h2><p><code>host_serv()</code>可让调用者在不必生成hints structure的前提下调用<code>getaddrinfo()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> addrinfo *<span class="title function_">host_serv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *serv, </span></span><br><span class="line"><span class="params">                           <span class="type">int</span> family, <span class="type">int</span> socktype)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>    n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">  bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">  hints.ai_flags = AI_CANONNAME;  <span class="comment">/* always return canonical name */</span></span><br><span class="line">  hints.ai_family = family; <span class="comment">/* AF_UNSPEC, AF_INET, AF_INET6, etc. */</span></span><br><span class="line">  hints.ai_socktype = socktype; <span class="comment">/* 0, SOCK_STREAM, SOCK_DGRAM, etc. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(res);  <span class="comment">/* return pointer to first on linked list */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="11-tcp-connect-Function"><a href="#11-tcp-connect-Function" class="headerlink" title="11. tcp_connect Function"></a>11. tcp_connect Function</h2><p>tcp_connect()可通过hostname获取server IP address并建立连接.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *serv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>             sockfd, n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line"></span><br><span class="line">  bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">  hints.ai_family = AF_UNSPEC;</span><br><span class="line">  hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;tcp_connect error for %s, %s: %s&quot;</span>, host, serv, </span><br><span class="line">              gai_strerror(n));</span><br><span class="line">  ressave = res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">/* ignore this one */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* success */</span></span><br><span class="line"></span><br><span class="line">    Close(sockfd);  <span class="comment">/* ignore this one */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( (res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == <span class="literal">NULL</span>)  <span class="comment">/* errno set from final connect() */</span></span><br><span class="line">    err_sys(<span class="string">&quot;tcp_connect error for %s, %s&quot;</span>, host, serv);</span><br><span class="line"></span><br><span class="line">  freeaddrinfo(ressave);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="12-tcp-listen-Function"><a href="#12-tcp-listen-Function" class="headerlink" title="12. tcp_listen Function"></a>12. tcp_listen Function</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_listen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *serv, </span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *addrlenp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>       listenfd, n;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>  <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line"></span><br><span class="line">  bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">  hints.ai_flags = AI_PASSIVE;</span><br><span class="line">  hints.ai_family = AF_UNSPEC;</span><br><span class="line">  hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;tcp_listen error for %s, %s: %s&quot;</span>, host, serv, </span><br><span class="line">              gai_strerror(n));</span><br><span class="line">  ressave = res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    listenfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">/* error, try next one */</span></span><br><span class="line"></span><br><span class="line">    Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* success */</span></span><br><span class="line"></span><br><span class="line">    Close(listenfd);  <span class="comment">/* bind error, close and try next one */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( (res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == <span class="literal">NULL</span>)  <span class="comment">/* errno from final socket() or bind() */</span></span><br><span class="line">    err_sys(<span class="string">&quot;tcp_listen error for %s, %s&quot;</span>, host, serv);</span><br><span class="line"></span><br><span class="line">  Listen(listenfd, LISTENQ);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addrlenp)</span><br><span class="line">    *addrlenp = res-&gt;ai_addrlen;  <span class="comment">/* return size of protocol address */</span></span><br><span class="line"></span><br><span class="line">  freeaddrinfo(ressave);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(listenfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="13-udp-client-Function"><a href="#13-udp-client-Function" class="headerlink" title="13. udp_client Function"></a>13. udp_client Function</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">udp_client</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *serv, SA **saptr, </span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> *lenp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span>    sockfd, n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>  <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line"></span><br><span class="line">  bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">  hints.ai_family = AF_UNSPEC;</span><br><span class="line">  hints.ai_socktype = SOCK_DGRAM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;udp_client error for %s, %s: %s&quot;</span>, host, serv, </span><br><span class="line">             gai_strerror(n));</span><br><span class="line">  ressave = res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* success */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( (res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == <span class="literal">NULL</span>)  <span class="comment">/* errno set from final socket() */</span></span><br><span class="line">    err_sys(<span class="string">&quot;udp_client error for %s, %s&quot;</span>, host, serv);</span><br><span class="line"></span><br><span class="line">  *saptr = Malloc(res-&gt;ai_addrlen);</span><br><span class="line">  <span class="built_in">memcpy</span>(*saptr, res-&gt;ai_addr, res-&gt;ai_addrlen);</span><br><span class="line">  *lenp = res-&gt;ai_addrlen;</span><br><span class="line"></span><br><span class="line">  freeaddrinfo(ressave);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="14-udp-connect-Function"><a href="#14-udp-connect-Function" class="headerlink" title="14. udp_connect Function"></a>14. udp_connect Function</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">udp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *serv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sockfd, n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line"></span><br><span class="line">  bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">  hints.ai_family = AF_UNSPEC;</span><br><span class="line">  hints.ai_socktype = SOCK_DGRAM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;udp_connect error for %s, %s: %s&quot;</span>, host, serv, </span><br><span class="line">              gai_strerror(n));</span><br><span class="line">  ressave = res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">/* ignore this one */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* success */</span></span><br><span class="line"></span><br><span class="line">    Close(sockfd);  <span class="comment">/* ignore this one */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( (res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == <span class="literal">NULL</span>)  <span class="comment">/* errno set from final connect() */</span></span><br><span class="line">    err_sys(<span class="string">&quot;udp_connect error for %s, %s&quot;</span>, host, serv);</span><br><span class="line"></span><br><span class="line">  freeaddrinfo(ressave);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="15-udp-server-Function"><a href="#15-udp-server-Function" class="headerlink" title="15. udp_server Function"></a>15. udp_server Function</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">udp_server</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *serv, <span class="type">socklen_t</span> *addrlenp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sockfd, n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">res</span>, *<span class="title">ressave</span>;</span></span><br><span class="line"></span><br><span class="line">  bzero(&amp;hints, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> addrinfo));</span><br><span class="line">  hints.ai_flags = AI_PASSIVE;</span><br><span class="line">  hints.ai_family = AF_UNSPEC;</span><br><span class="line">  hints.ai_socktype = SOCK_DGRAM;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (n = getaddrinfo(host, serv, &amp;hints, &amp;res)) != <span class="number">0</span>)</span><br><span class="line">    err_quit(<span class="string">&quot;udp_server error for %s, %s: %s&quot;</span>, host, serv, </span><br><span class="line">              gai_strerror(n));</span><br><span class="line">  ressave = res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">/* error - try next one */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;  <span class="comment">/* success */</span></span><br><span class="line"></span><br><span class="line">    Close(sockfd);  <span class="comment">/* bind error - close and try next one */</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ( (res = res-&gt;ai_next) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res == <span class="literal">NULL</span>)  <span class="comment">/* errno from final socket() or bind() */</span></span><br><span class="line">    err_sys(<span class="string">&quot;udp_server error for %s, %s&quot;</span>, host, serv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addrlenp) <span class="comment">/* return size of protocol address */</span></span><br><span class="line">    *addrlenp = res-&gt;ai_addrlen;</span><br><span class="line"></span><br><span class="line">  freeaddrinfo(ressave);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="16-getnameinfo-Function"><a href="#16-getnameinfo-Function" class="headerlink" title="16. getnameinfo Function"></a>16. getnameinfo Function</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief inverse of getaddrinfo(), convert a socket </span></span><br><span class="line"><span class="comment"> *        address to a corresponding host and service</span></span><br><span class="line"><span class="comment"> * @param addr pointer to a socket address structure</span></span><br><span class="line"><span class="comment"> * @param addrlen size of addr</span></span><br><span class="line"><span class="comment"> * @param host pointer to caller-allocated buffer, </span></span><br><span class="line"><span class="comment"> *        NULL for no hostname</span></span><br><span class="line"><span class="comment"> * @param serv pointer to caller-allocated buffer, </span></span><br><span class="line"><span class="comment"> *        NULL for no service name</span></span><br><span class="line"><span class="comment"> * @param flags modify the behavior of getnameinfo():</span></span><br><span class="line"><span class="comment"> *        * NI_NAMEREQD: an error is returned if the </span></span><br><span class="line"><span class="comment"> *          hostname cannot be determined</span></span><br><span class="line"><span class="comment"> *        * NI_DGRAM: the service is datagram based </span></span><br><span class="line"><span class="comment"> *          rather than stream based</span></span><br><span class="line"><span class="comment"> *        * NI_NOFQDN: only return the hostname part</span></span><br><span class="line"><span class="comment"> *          of the fully qualified domain name for </span></span><br><span class="line"><span class="comment"> *          local hosts</span></span><br><span class="line"><span class="comment"> *        * NI_NUMERICHOST: return the numeric form </span></span><br><span class="line"><span class="comment"> *          of hostname</span></span><br><span class="line"><span class="comment"> *        * NI_NUMERICSERV: return the numeric form </span></span><br><span class="line"><span class="comment"> *          of service address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, </span></span><br><span class="line"><span class="params">      <span class="type">socklen_t</span> addrlen, <span class="type">char</span> *host, <span class="type">socklen_t</span> hostlen,</span></span><br><span class="line"><span class="params">      <span class="type">char</span> *serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="17-Re-entrant-Functions"><a href="#17-Re-entrant-Functions" class="headerlink" title="17. Re-entrant Functions"></a>17. Re-entrant Functions</h2><p>Reentrant function意味着函数运行中途被打断后不会影响之前的程序运转. reentrant需要遵循以下几个原则:</p>
<ol>
<li>尽量不要使用global和static变量. 尽管有方法防止global和static变量影响程序, 但有时也会造成不可知的影响</li>
<li>运行时不可修改代码</li>
<li>程序内不可运行non-reentrant function</li>
</ol>
<p><code>gethostbyname()</code>和<code>gethostbyaddr()</code>都不是re-entrant functions, 因为这两个函数共享static variable:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> <span class="title">host</span>;</span>  <span class="comment">/* result stored here */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *</span><br><span class="line"><span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* call DNS functions for A record */</span></span><br><span class="line">  <span class="comment">/* fill in host structure */</span></span><br><span class="line">  <span class="keyword">return</span> (&amp;host) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *</span><br><span class="line"><span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* call DNS functions for PTR query in in-addr.arpa domain */</span></span><br><span class="line">  <span class="comment">/* fill in host structure */</span></span><br><span class="line">  <span class="keyword">return</span> (&amp;host);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设进程运行<code>gethostbyname()</code>时被signal打断, signal handler中运行<code>gethostbyaddr()</code>导致<code>host</code>变量被覆盖, 造成reentrancy problem. 关于reentrant function的总结如下:</p>
<ul>
<li><code>gethostbyname()</code>, <code>gethostbyaddr()</code>, <code>getservbyname()</code>, <code>getservbyport()</code>为non-renentrant function, 因为使用static structure.</li>
<li>部分系统为以上4个函数提供了reentrant functions, 以<code>_r</code>为后缀</li>
<li><code>inet_pton()</code>和<code>inet_ntop()</code>为reentrant functions</li>
<li><code>inet_ntoa()</code>为non-reentrant function, 部分UNIX系统会提供reentrant version</li>
<li><code>getnameinfo()</code>只有在调用reentrant function时才可能为reentrant function</li>
<li><code>errno</code>是一个线程共享的global variable, 因此需要在signal handler开始时保存errno, 退出时恢复errno</li>
</ul>
<h2 id="18-gethostbyname-r-and-gethostbyaddr-r-Functions"><a href="#18-gethostbyname-r-and-gethostbyaddr-r-Functions" class="headerlink" title="18. gethostbyname_r and gethostbyaddr_r Functions"></a>18. gethostbyname_r and gethostbyaddr_r Functions</h2><p>Linux和Solaris都提供了name-to-address和address-toname的reentrant functions:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gethostbyname_r</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname, <span class="keyword">struct</span> hostent *result, </span></span><br><span class="line"><span class="params">                    <span class="type">char</span> *buf, <span class="type">size_t</span> buflen, <span class="type">int</span> *h_errnop)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gethostbyaddr_r</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> hostent *result, <span class="type">char</span> *buf, </span></span><br><span class="line"><span class="params">                    <span class="type">size_t</span> buflen, <span class="type">int</span> *h_errnop)</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到, 这两个functions都多了很多参数. <code>buf</code>由调用者申请空间, 用于保存canonical hostname, <code>buflen</code>为buf的大小. 虽然没有规定buf应为多少, 但通常设置为8192 bytes可满足绝大多数hostname; 当发生错误时, 错误码保存在<code>h_errnop</code>. 需要注意的是, 并不是所有系统支持reentrancy的<code>gethostbyname()</code>和<code>gethostbyaddr()</code>, UNIX 98和POSIX specification中这两个function不需要thread-safe或reentrant. </p>
<h2 id="19-Obsolete-IPv6-Address-Lookup-Functions"><a href="#19-Obsolete-IPv6-Address-Lookup-Functions" class="headerlink" title="19. Obsolete IPv6 Address Lookup Functions"></a>19. Obsolete IPv6 Address Lookup Functions</h2><h3 id="19-1-RES-USE-INET6-Constant"><a href="#19-1-RES-USE-INET6-Constant" class="headerlink" title="19.1 RES_USE_INET6 Constant"></a>19.1 RES_USE_INET6 Constant</h3><p>由于<code>gethostbyname()</code>无法指定address family, 所以引入<strong>RES_USE_INET6</strong> constant来指定address family. 开启RES_USE_INET6后, <code>gethostbyname()</code>会优先搜索AAAA record, 若没有AAAA record, 再查看A record. 由于<code>hostent</code>只有一个address length, 所以<code>gethostbyname()</code>只能返回IPv6或IPv4 address. RES_USE_INET6也可以返回IPv4-mapped IPv6 adddress.</p>
<h3 id="19-2-gethostbyname2-Function"><a href="#19-2-gethostbyname2-Function" class="headerlink" title="19.2 gethostbyname2 Function"></a>19.2 gethostbyname2 Function</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief same as gethostbyname(), but permit to</span></span><br><span class="line"><span class="comment"> *        specify address family</span></span><br><span class="line"><span class="comment"> * @param af address family, AF_INET or AF_INET6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> af)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="19-3-getipnodebyname-Function"><a href="#19-3-getipnodebyname-Function" class="headerlink" title="19.3 getipnodebyname Function"></a>19.3 getipnodebyname Function</h3><p>RES_USE_INET6和<code>gethostbyname2()</code>已在RFC 2553废弃, 因为RES_USE_INET6是一个global constant. 因此引入<code>getipnodebyname()</code>解决IPv6 address问题.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief return a pointer to the hostent structure</span></span><br><span class="line"><span class="comment"> * @param af: same as hints.ai_family in getaddrinfo()</span></span><br><span class="line"><span class="comment"> * @param flags: same as hints.ai_flags in getaddrinfo()</span></span><br><span class="line"><span class="comment"> * @return the return value is dynamically allocated, must be </span></span><br><span class="line"><span class="comment"> *         freed with freehostent()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">getipnodebyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> af,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> flags, <span class="type">int</span> *error_num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">getipnodebyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> len,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> af, <span class="type">int</span> *error_num)</span>;</span><br></pre></td></tr></table></figure>
<p><code>getipnodebyname()</code>和<code>getipnodebyaddr()</code>已在RFC 3493废弃.</p>
<h2 id="20-Other-Networking-Information"><a href="#20-Other-Networking-Information" class="headerlink" title="20. Other Networking Information"></a>20. Other Networking Information</h2><p>上述所有函数主要围绕4类信息: host. network, protocol, service. 这4类信息都保存在各自文件中, 可通过以下函数获取:</p>
<ol>
<li>getXXXent functions: 打开并读取文件中的一个entry</li>
<li>setXXXent functions: 打开并回到文件头部</li>
<li>endXXXent functions: 关闭文件</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sethostent</span><span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endhostent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setservent</span><span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endservent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> netent *<span class="title function_">getnetent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setnetent</span><span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endnetent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> protoent *<span class="title function_">getprotoent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setprotoent</span><span class="params">(<span class="type">int</span> stayopen)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">endprotoent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>每个函数都定义了自己的structure: hostent, netent, protoent, servent. 除了get, set, end functions, 还有一类函数称为keyed lookup functions, 其名字一般为<code>getXXXbyYYY</code>, keyed lookup function不会返回文件中的每个entry, 而是根据参数的要求匹配相应的entry.</p>
<p>| Information | Data file | Structure | Keyed lookup functions |<br>| Hosts | &#x2F;etc&#x2F;hosts | hostent | gethostbyaddr, gethostbyname |<br>| Networks | &#x2F;etc&#x2F;networks | netent | getnetbyaddr, getnetbyname |<br>| Protocols | &#x2F;etc&#x2F;protocols | protoent | getprotobyname, getprotobynumber |<br>| Services | &#x2F;etc&#x2F;services | servent | getservbyname, getservbyport |</p>
<p>使用DNS的条件如下:</p>
<ol>
<li>host和network需要通过网络发送DNS请求获取, protocl和service则需要通过本机文件获取. </li>
<li>当需要获取host和network时, 只能通过keyed lookup function查询. 而不能用<code>gethostent()</code>获取</li>
</ol>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Network/">Network</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/b4e.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">IPv4 and IPv6 Interoperability</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/80a7.html">
        <span class="next-text nav-default">Elementary UDP Sockets</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/2b71.html';
  var disqus_title = "Name and Address Conversions";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
