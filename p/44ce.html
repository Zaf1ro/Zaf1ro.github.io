<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="C++ Basic (3)"/>




  <meta name="keywords" content="Programming Language," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/44ce.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/44ce.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/44ce.html"/>


<meta name="description" content="1. Scope and Lifespan of Variable 全局变量: 所有源代码, 程序运行结束时销毁 全局静态变量: 单个源文件, 程序运行结束时销毁 局部变量: 所在函数, 函数运行完毕时销毁 静态局部变量: 所在函数, 但会在调用函数前初始化, 程序运行结束时销毁 静态成员变量: 所在class内, 所有对象共享该成员, 因此该成员会在生成对象前初始化, 程序运行结束时销毁  2.">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Basic (3)">
<meta property="og:url" content="https://zaf1ro.github.io/p/44ce.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. Scope and Lifespan of Variable 全局变量: 所有源代码, 程序运行结束时销毁 全局静态变量: 单个源文件, 程序运行结束时销毁 局部变量: 所在函数, 函数运行完毕时销毁 静态局部变量: 所在函数, 但会在调用函数前初始化, 程序运行结束时销毁 静态成员变量: 所在class内, 所有对象共享该成员, 因此该成员会在生成对象前初始化, 程序运行结束时销毁  2.">
<meta property="og:locale">
<meta property="article:published_time" content="2017-09-15T18:50:17.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.048Z">
<meta property="article:tag" content="Programming Language">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
C++ Basic (3) - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Scope-and-Lifespan-of-Variable"><span class="toc-text">1. Scope and Lifespan of Variable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-const-and-define"><span class="toc-text">2. const and #define</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-struct-in-C"><span class="toc-text">3. struct in C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SOLID-Principles-in-OOP"><span class="toc-text">4. SOLID Principles in OOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Class-Inheritance"><span class="toc-text">5. Class Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Initialization-List"><span class="toc-text">6. Initialization List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Function-Pointer"><span class="toc-text">7. Function Pointer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Object-on-the-stack-heap"><span class="toc-text">8. Object on the stack&#x2F;heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-private-member-in-inheritance"><span class="toc-text">9. private member in inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-default-value-in-arrray"><span class="toc-text">10. default value in arrray</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-clone-and-fork"><span class="toc-text">11. clone and fork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-abs"><span class="toc-text">12. abs()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-malloc-and-new"><span class="toc-text">13. malloc and new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Polymorphism"><span class="toc-text">14. Polymorphism</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-convert-pointer-to-const"><span class="toc-text">15. convert pointer to const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Value-Assignment-in-For-Loop"><span class="toc-text">16. Value Assignment in For Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Functions-in-Empty-Class"><span class="toc-text">17. Functions in Empty Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Initialize-Two-Dimensional-Array"><span class="toc-text">18. Initialize Two Dimensional Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-Zero-Argument-Constructor"><span class="toc-text">19. Zero Argument Constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Sequence-Point"><span class="toc-text">20. Sequence Point</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-Order-of-Execution-of-Destructor"><span class="toc-text">21. Order of Execution of Destructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-cin-unsigned-integer"><span class="toc-text">22. cin &gt;&gt; unsigned integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-order-of-struct-member-in-memory"><span class="toc-text">23 order of struct member in memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Initialization-of-Character-Array"><span class="toc-text">24. Initialization of Character Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-Implicit-Type-Conversion"><span class="toc-text">25. Implicit Type Conversion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Double-Free-and-Bitwise-Copy"><span class="toc-text">26. Double Free and Bitwise Copy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-Stack-Memory-Allocation"><span class="toc-text">27. Stack Memory Allocation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Formatting-String"><span class="toc-text">28. Formatting String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Base-class-pointer-pointing-to-derived-class-object"><span class="toc-text">29. Base class pointer pointing to derived class object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-condition-of-switch"><span class="toc-text">30. condition of switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-Copy-Constructor"><span class="toc-text">31. Copy Constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-Access-Specifiers"><span class="toc-text">32. Access Specifiers</span></a></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          C++ Basic (3)
        
      </h1>
      <time class="post-time">
          09/15/17
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Scope-and-Lifespan-of-Variable"><a href="#1-Scope-and-Lifespan-of-Variable" class="headerlink" title="1. Scope and Lifespan of Variable"></a>1. Scope and Lifespan of Variable</h2><ul>
<li>全局变量: 所有源代码, 程序运行结束时销毁</li>
<li>全局静态变量: 单个源文件, 程序运行结束时销毁</li>
<li>局部变量: 所在函数, 函数运行完毕时销毁</li>
<li>静态局部变量: 所在函数, 但会在调用函数前初始化, 程序运行结束时销毁</li>
<li>静态成员变量: 所在class内, 所有对象共享该成员, 因此该成员会在生成对象前初始化, 程序运行结束时销毁</li>
</ul>
<h2 id="2-const-and-define"><a href="#2-const-and-define" class="headerlink" title="2. const and #define"></a>2. const and #define</h2><p>相比于define, 使用const有以下好处: </p>
<ol>
<li>const会检查数据类型, define不会</li>
<li>const效率更高. const定义的常量不会保存在内存中, 而是在符号表(symbol table)中, 每次访问const数据不必从内存中读取和存储, 因此效率高</li>
</ol>
<h2 id="3-struct-in-C"><a href="#3-struct-in-C" class="headerlink" title="3. struct in C++"></a>3. struct in C++</h2><p>C++的struct与C的struct完全不同, C++中的struct十分接近class, 其具备继承(inheritance)和多态(polymorphism), 但无法设置访问权限.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> x);</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">default_func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">  a = x;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::default_func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;default function&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;function A&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>: A &#123;  <span class="comment">// 默认为public继承</span></span><br><span class="line">  <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::<span class="built_in">B</span>(<span class="type">int</span> x, <span class="type">int</span> y): <span class="built_in">A</span>(x) &#123;</span><br><span class="line">  b = y;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::func</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;function B&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;           <span class="comment">// A()</span></span><br><span class="line">  a.<span class="built_in">func</span>();         <span class="comment">// function A</span></span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;        <span class="comment">// A()</span></span><br><span class="line">                    <span class="comment">// B()</span></span><br><span class="line">  b.<span class="built_in">func</span>();         <span class="comment">// function B</span></span><br><span class="line">  b.<span class="built_in">default_func</span>(); <span class="comment">// default function</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-SOLID-Principles-in-OOP"><a href="#4-SOLID-Principles-in-OOP" class="headerlink" title="4. SOLID Principles in OOP"></a>4. SOLID Principles in OOP</h2><ol>
<li>SRP(Single-Resposibility Principle, 单一职责原则): 每个模块, 类, 或函数只承担一个职责, 并且封装实现.</li>
<li>OCP(Open-Close Principle, 开放封闭原则): 实体应该对拓展开放, 对修改封闭.</li>
<li>LSP(Liskov Substituion Principle, 里式替换原则): 子类应能够替换它的基类. 例如, class B是class A的子类, 以class A为参数的函数也能接受class B的对象, 且不会导致任何异常, 这么做能保证子类继承了父类的一切.</li>
<li>ISP(Interface Segregation Principle, 接口隔离原则): 保持接口的独立, 也就是说, 很多个客户端特定的接口, 优于一个多用途的接口.</li>
<li>DIP(Dependecy Inversion Principle, 依赖倒置原则): class应依赖接口和抽象类, 而不是具体的class或函数.</li>
</ol>
<h2 id="5-Class-Inheritance"><a href="#5-Class-Inheritance" class="headerlink" title="5. Class Inheritance"></a>5. Class Inheritance</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::display&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::display&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(A ptr)</span> </span>&#123; <span class="comment">// 不是用的地址传递, 所以直接转化为基类对象, 所以只调用基类成员函数</span></span><br><span class="line">  ptr.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="built_in">fun</span>(a); <span class="comment">// A::display</span></span><br><span class="line">  <span class="built_in">fun</span>(b); <span class="comment">// A::display</span></span><br><span class="line"></span><br><span class="line">  B* b2 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">  A* a2 = (A*)b2;</span><br><span class="line">  a2-&gt;<span class="built_in">display</span>();  <span class="comment">// B::display 地址转换, 所以保留多态特性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-Initialization-List"><a href="#6-Initialization-List" class="headerlink" title="6. Initialization List"></a>6. Initialization List</h2><p>使用初始化列表可少调用一次default constructor,从而提高效率, 减少错误. 以下三种情况必须使用初始化列表:</p>
<ol>
<li>成员所在的类没有默认构造函数</li>
<li>const修饰的类成员或引用成员数据</li>
<li>子类初始化父类的私有成员</li>
</ol>
<p>static成员变量不属于某个对象, 所以不能在constructor内初始化</p>
<h2 id="7-Function-Pointer"><a href="#7-Function-Pointer" class="headerlink" title="7. Function Pointer"></a>7. Function Pointer</h2><p>函数指针有两种方法: <code>pf=f1</code>和<code>pf=&amp;f1</code>, 但必须保证参数类型和返回值类型匹配.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(<span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">float</span>);</span><br><span class="line"></span><br><span class="line">pf=f1;  <span class="comment">// OK</span></span><br><span class="line">pf=&amp;f1; <span class="comment">// OK</span></span><br><span class="line">pf=f2;  <span class="comment">// error, 参数类型不匹配</span></span><br></pre></td></tr></table></figure>


<h2 id="8-Object-on-the-stack-heap"><a href="#8-Object-on-the-stack-heap" class="headerlink" title="8. Object on the stack&#x2F;heap"></a>8. Object on the stack&#x2F;heap</h2><p>调用<code>Class obj</code>不能保证类对象分配到栈中, 因为C++遵循<strong>自动存储</strong>(automatic storage), 会根据context决定存储位置.</p>
<ol>
<li>Object obj存储在栈中  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">  Object obj; <span class="comment">// 在函数中创建类对象会直接分配到栈中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Object obj存储在堆中  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object2</span> &#123;</span><br><span class="line">  Object obj;     </span><br><span class="line">&#125;</span><br><span class="line">Object2 *pObj2 = <span class="keyword">new</span> <span class="built_in">Object2</span>(); <span class="comment">// 由于pObj2所指向的对象在堆上分配空间, 所以obj也在堆上分配空间</span></span><br></pre></td></tr></table></figure></li>
<li>Object Obj在静态存储区  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Object obj; <span class="comment">// 将obj存为全局变量</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>Stack与Heap上创建对象的区别:</p>
<ol>
<li>性能</li>
</ol>
<ul>
<li>heap上分配对象的时间为常量</li>
<li>stack上分配对象的时间不定, 因为操作系统需追踪内存的可用区域</li>
</ul>
<ol start="2">
<li>生存周期</li>
</ol>
<ul>
<li>heap上对象的生存周期与上下文有关</li>
<li>stack上的对象拥有更长的生存周期</li>
</ul>
<h2 id="9-private-member-in-inheritance"><a href="#9-private-member-in-inheritance" class="headerlink" title="9. private member in inheritance"></a>9. private member in inheritance</h2><p>父类的私有变量仍在子类的内存中, 但由于编译器的限制所以无法访问.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="built_in">A</span>():<span class="built_in">a</span>(<span class="number">1</span>),<span class="built_in">b</span>(<span class="number">2</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  cout &lt;&lt; *(<span class="type">int</span>*)&amp;b &lt;&lt; endl;      <span class="comment">// 1</span></span><br><span class="line">  cout &lt;&lt; *((<span class="type">int</span>*)&amp;b<span class="number">+1</span>) &lt;&lt; endl;  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="10-default-value-in-arrray"><a href="#10-default-value-in-arrray" class="headerlink" title="10. default value in arrray"></a>10. default value in arrray</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>] = &#123;<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">char</span> c[<span class="number">2</span>] = &#123;<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="type">float</span> d[<span class="number">2</span>] = &#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">cout &lt;&lt; a[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;   <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; b[<span class="number">2</span>] &lt;&lt; endl;      <span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)c[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// 0, char类型默认为&#x27;\0&#x27;</span></span><br><span class="line">cout &lt;&lt; d[<span class="number">1</span>] &lt;&lt; endl;      <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>


<h2 id="11-clone-and-fork"><a href="#11-clone-and-fork" class="headerlink" title="11. clone and fork"></a>11. clone and fork</h2><ul>
<li><code>fork()</code>: 复制父进程的所有资源, 因此无需携带参数.</li>
<li><code>clone()</code>: 复制父进程的部分资源, 复制哪些资源可通过参数设定, 所以<code>clone()</code>携带参数, 没有复制的资源可以通过指针共享给子进程</li>
</ul>
<h2 id="12-abs"><a href="#12-abs" class="headerlink" title="12. abs()"></a>12. abs()</h2><ul>
<li>输入为非负整数, 返回非负整数</li>
<li>输入为负数, 且不为最小负数, 返回其绝对值</li>
<li>输入为最小负数(<code>INT_MIN</code>), 还是返回最小负数</li>
</ul>
<h2 id="13-malloc-and-new"><a href="#13-malloc-and-new" class="headerlink" title="13. malloc and new"></a>13. malloc and new</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A *p1 = <span class="keyword">new</span> A;                 <span class="comment">// 调用了构造函数</span></span><br><span class="line">A *p2 = (A*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A)); <span class="comment">// 没有调用构造函数, 只是分配了一块A类大小的内存</span></span><br></pre></td></tr></table></figure>


<h2 id="14-Polymorphism"><a href="#14-Polymorphism" class="headerlink" title="14. Polymorphism"></a>14. Polymorphism</h2><ul>
<li>编译时多态性(override): 通过静态联编完成, 例如函数重载, 运算符重载</li>
<li>运行时多态性(overload): 通过动态联编完成, 主要通过虚函数来实现；</li>
</ul>
<h2 id="15-convert-pointer-to-const"><a href="#15-convert-pointer-to-const" class="headerlink" title="15. convert pointer to const"></a>15. convert pointer to const</h2><p>允许<code>int*</code>转为<code>const int*</code>, 但不允许转换多级指针(如<code>int**</code>转为<code>const int**</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *a = &amp;x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *b = &amp;x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **p = &amp;a; <span class="comment">// error: invalid conversion from &#x27;int**&#x27; to &#x27;const int**&#x27;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> **q = &amp;b;</span><br></pre></td></tr></table></figure>


<h2 id="16-Value-Assignment-in-For-Loop"><a href="#16-Value-Assignment-in-For-Loop" class="headerlink" title="16. Value Assignment in For Loop"></a>16. Value Assignment in For Loop</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i = <span class="number">0</span>; ++i) &#123;&#125;; <span class="comment">// 由于i为0, 逻辑为假, 不进入循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i = <span class="number">1</span>; ++i) &#123;&#125;; <span class="comment">// 由于i一直为1, 逻辑为真, 陷入死循环</span></span><br></pre></td></tr></table></figure>


<h2 id="17-Functions-in-Empty-Class"><a href="#17-Functions-in-Empty-Class" class="headerlink" title="17. Functions in Empty Class"></a>17. Functions in Empty Class</h2><p>以下是空类含有的函数:</p>
<ul>
<li>copy constructor</li>
<li>copy assignment operator</li>
<li>destructor</li>
<li>default constructor</li>
</ul>
<p>以上函数都是public且inline的</p>
<h2 id="18-Initialize-Two-Dimensional-Array"><a href="#18-Initialize-Two-Dimensional-Array" class="headerlink" title="18. Initialize Two Dimensional Array"></a>18. Initialize Two Dimensional Array</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// OK, a[2][3]=&#123;&#123;1,2,3&#125;,&#123;0,0,0&#125;&#125;</span></span><br><span class="line">a[][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;   <span class="comment">// OK, a[][2]=&#123;&#123;1,2&#125;,&#123;3,0&#125;&#125;</span></span><br><span class="line">a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>&#125;&#125;; <span class="comment">// error, 等号右边为3个元素的数组, a为两个元素的数组</span></span><br></pre></td></tr></table></figure>


<h2 id="19-Zero-Argument-Constructor"><a href="#19-Zero-Argument-Constructor" class="headerlink" title="19. Zero Argument Constructor"></a>19. Zero Argument Constructor</h2><p>无参构造函数创建对象时, 不应该在对象名后加括号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">()</span></span>;  <span class="comment">// error, 这样会声明一个名为a的函数</span></span><br><span class="line">A a;    <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>


<h2 id="20-Sequence-Point"><a href="#20-Sequence-Point" class="headerlink" title="20. Sequence Point"></a>20. Sequence Point</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>逗号表达式是一组由逗号分隔的表达式, 从左向右计算, 结果为表达式最右边的值; 若最后边的操作数是左值, 则逗号表达式的值也是左值. 此类表达式通常用于for循环.</p>
<h2 id="21-Order-of-Execution-of-Destructor"><a href="#21-Order-of-Execution-of-Destructor" class="headerlink" title="21. Order of Execution of Destructor"></a>21. Order of Execution of Destructor</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="built_in">A</span>() &#123;&#125;  </span><br><span class="line">  ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A&quot;</span> &lt;&lt; endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">  A _a;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  <span class="built_in">B</span>(A &amp;a):_a(a) &#123;&#125;  </span><br><span class="line">  ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B&quot;</span> &lt;&lt; endl; &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;  </span><br><span class="line">  A a; </span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">  <span class="comment">// 先调用b所在的子类B的析构函数 &#x27;~B&#x27;</span></span><br><span class="line">  <span class="comment">// 再调用b的成员变量_a的析构函数, &#x27;~A&#x27;</span></span><br><span class="line">  <span class="comment">// 接着调用b的父类析构函数, &#x27;~A&#x27;</span></span><br><span class="line">  <span class="comment">// 最后调用a的析构函数, &#x27;~A&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="22-cin-unsigned-integer"><a href="#22-cin-unsigned-integer" class="headerlink" title="22. cin &gt;&gt; unsigned integer"></a>22. cin &gt;&gt; unsigned integer</h2><ul>
<li><code>%u</code>&#x2F;<code>%o</code>&#x2F;<code>%x</code>代表10&#x2F;8&#x2F;16进制的无符号数</li>
<li><code>%n</code>接受一个uint数, 代表到<code>%n</code>之前所输入的字符数</li>
</ul>
<h2 id="23-order-of-struct-member-in-memory"><a href="#23-order-of-struct-member-in-memory" class="headerlink" title="23 order of struct member in memory"></a>23 order of struct member in memory</h2><p>对于struct, 每个成员的内存从低到高依次排序.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mybitfields</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> a: <span class="number">4</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> b: <span class="number">5</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> c: <span class="number">7</span>;</span><br><span class="line">&#125; <span class="function">test</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  test.a = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line">  test.b = <span class="number">3</span>; <span class="comment">// 0 0011</span></span><br><span class="line">  test.c = <span class="number">0</span>; <span class="comment">// 000 0000</span></span><br><span class="line"></span><br><span class="line">  i = *((<span class="type">short</span> *)&amp;test);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 0000 0000 0011 0010 =&gt; 2+16+32=50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于class, 若没有交叉的access specifier(如private和public交叉使用), 则成员变量在内存上从低到高依次排序; 若存在交叉的access specifier, 则依据不同compiler的实现而定.</p>
<h2 id="24-Initialization-of-Character-Array"><a href="#24-Initialization-of-Character-Array" class="headerlink" title="24. Initialization of Character Array"></a>24. Initialization of Character Array</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> s3[] = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> s4[] = &#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* s5 = <span class="literal">NULL</span>;</span><br><span class="line">s5 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span>* s6 = <span class="literal">NULL</span>;</span><br><span class="line">s6 = &#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="25-Implicit-Type-Conversion"><a href="#25-Implicit-Type-Conversion" class="headerlink" title="25. Implicit Type Conversion"></a>25. Implicit Type Conversion</h2><p>如果表达式中同时存在signed int和unsigned int, 会将signed int转换为unsigned int</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="type">unsigned</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j &gt; i)          <span class="comment">// i转换为unsigned类型</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; (j&gt;i)成立\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot; (j&gt;i)不成立\n&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="26-Double-Free-and-Bitwise-Copy"><a href="#26-Double-Free-and-Bitwise-Copy" class="headerlink" title="26. Double Free and Bitwise Copy"></a>26. Double Free and Bitwise Copy</h2><p>默认copy constructor使用bitwise copy, </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  A *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; p = <span class="keyword">new</span> A; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; <span class="keyword">delete</span> p; cout &lt;&lt; <span class="string">&quot;~B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">(B b)</span> </span>&#123;&#125; <span class="comment">// call default constructor, and call destructor at the end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// 程序一共输出两次~B()</span></span><br><span class="line">   B b;</span><br><span class="line">   <span class="built_in">sayHello</span>(b); <span class="comment">// 输出~B()</span></span><br><span class="line">   <span class="comment">// 最后会再调用一次~B()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="27-Stack-Memory-Allocation"><a href="#27-Stack-Memory-Allocation" class="headerlink" title="27. Stack Memory Allocation"></a>27. Stack Memory Allocation</h2><ul>
<li><code>void* malloc(unsigned int size)</code><ul>
<li>在stack中分配一段长度为size的连续空间</li>
<li>成功时返回首地址, 失败时返回NULL</li>
<li>不会初始化内存</li>
</ul>
</li>
<li><code>void* calloc(unsigned int num, unsigned int size)</code><ul>
<li>根据数据个数和数据类型所占字节数, 分配size*num大小的连续空间</li>
<li>成功时返回首地址, 失败时返回NULL</li>
<li>会自动初始化内存为0</li>
</ul>
</li>
<li><code>void* realloc(void *ptr, unsigned int size)</code><ul>
<li>分配一段长为size的内存空间, 并把内存空间的首地址赋值给ptr</li>
<li>内存分配失败则返回NULL</li>
<li>不会初始化内存</li>
</ul>
</li>
<li><code>void* operator new (std::size_t size)</code><ul>
<li>自动计算需要分配的内存空间大小, 并调用类的构造函数</li>
<li>成功时返回首地址, 失败时抛出bad_alloc异常</li>
<li>不对类中的内置类型变量进行初始化</li>
</ul>
</li>
</ul>
<h2 id="28-Formatting-String"><a href="#28-Formatting-String" class="headerlink" title="28. Formatting String"></a>28. Formatting String</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s , %5.3s\n&quot;</span>,<span class="string">&quot;computer&quot;</span>,<span class="string">&quot;computer&quot;</span>);</span><br><span class="line"><span class="comment">// %m.ns输出占m列, 但只取字符串中左端n个字符. 这n个字符输出在m列的右侧, 左补空格</span></span><br></pre></td></tr></table></figure>


<h2 id="29-Base-class-pointer-pointing-to-derived-class-object"><a href="#29-Base-class-pointer-pointing-to-derived-class-object" class="headerlink" title="29. Base class pointer pointing to derived class object"></a>29. Base class pointer pointing to derived class object</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123; <span class="built_in">echo</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>() &#123; <span class="built_in">echo</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">echo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 执行Derived的构造函数时, 先调用父类Base的构造函数, 此时还没有动态绑定, 输出Base</span></span><br><span class="line">  <span class="comment">// 之后再调用子类Derived的构造函数, 输出Derived</span></span><br><span class="line">  <span class="comment">// 最后完成dynamic binding</span></span><br><span class="line">  Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>(); </span><br><span class="line">  </span><br><span class="line">  base-&gt;<span class="built_in">echo</span>(); <span class="comment">// 由于完成了动态绑定, 所以调用Derived的echo, 输出Derived</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="30-condition-of-switch"><a href="#30-condition-of-switch" class="headerlink" title="30. condition of switch"></a>30. condition of switch</h2><p><code>switch</code>的condition应为integral(整数), enumeration(枚举), 或可以隐式转换为整数或整数的class. 整数有以下几种:</p>
<ul>
<li>short</li>
<li>char</li>
<li>int</li>
<li>long</li>
<li>bool</li>
</ul>
<p>非整数类型包含float和double</p>
<h2 id="31-Copy-Constructor"><a href="#31-Copy-Constructor" class="headerlink" title="31. Copy Constructor"></a>31. Copy Constructor</h2><p>声明copy constructor时需注意以下几点:</p>
<ul>
<li>返回值的类型是否应为类型引用(否则无法连续赋值)</li>
<li>传入参数的类型是否应为引用(否则导致递归调用)</li>
<li>是否释放内存空间</li>
<li>是否判断传入参数和当前实例为同一实例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; objA) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;objA) </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;data;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;data, objA.data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="32-Access-Specifiers"><a href="#32-Access-Specifiers" class="headerlink" title="32. Access Specifiers"></a>32. Access Specifiers</h2><ul>
<li>member declarations<ul>
<li>public: <ul>
<li>类内: public和protected成员可访问</li>
<li>类外: 可在类外访问</li>
</ul>
</li>
<li>protected:<ul>
<li>类内: public和protected成员可访问</li>
<li>类外: 不可访问</li>
</ul>
</li>
<li>private:<ul>
<li>类内: public和protected成员可访问</li>
<li>类外: 不可访问</li>
</ul>
</li>
</ul>
</li>
<li>base-specifier<ul>
<li>public: base class中public和protected的访问权限不变</li>
<li>protected: base class中public变为protected, protected变为private</li>
<li>private: base class中public和protected变为private</li>
</ul>
</li>
</ul>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/Programming-Language/">Programming Language</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/9f80.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">C++ vs. Java</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/d4cf.html">
        <span class="next-text nav-default">C++ Basic (2)</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/44ce.html';
  var disqus_title = "C++ Basic (3)";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
