<!DOCTYPE html>
<html lang="zh">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



  <meta name="description" content="Volumes"/>




  <meta name="keywords" content="K8s," />


<meta name="google-site-verification" content="qy4gf0StWj627u-7aIP3WDCLBi3jPYXhm57UC7TUcok" />
<meta name="baidu-site-verification" content="XJoPG7ad2Z" />

<link rel="alternate" hreflang="x-default" href="https://zaf1ro.github.io/p/f56f.html" />
<link rel="alternate" hreflang="zh" href="https://zaf1ro.github.io/p/f56f.html" />




  <link rel="alternate" href="/default" title="Zaf1ro" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.jpeg?v=1.1" />



<link rel="canonical" href="https://zaf1ro.github.io/p/f56f.html"/>


<meta name="description" content="1. IntroductionVolume并不是Kubernetes的一种resource, 而是作为Pod specification中的一个组成部分. Volume无法用单独的YAML创建, 且只有volume被mount到特定的container上才可以被其访问.例如: Pod中有三个container, 分别为:  WebServer: 利用**&#x2F;var&#x2F;htdocs&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Volumes">
<meta property="og:url" content="https://zaf1ro.github.io/p/f56f.html">
<meta property="og:site_name" content="Zaf1ro">
<meta property="og:description" content="1. IntroductionVolume并不是Kubernetes的一种resource, 而是作为Pod specification中的一个组成部分. Volume无法用单独的YAML创建, 且只有volume被mount到特定的container上才可以被其访问.例如: Pod中有三个container, 分别为:  WebServer: 利用**&#x2F;var&#x2F;htdocs&amp;">
<meta property="og:locale">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-1.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-2.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-3.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-4.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-5.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-6.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-7.png">
<meta property="og:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-8.png">
<meta property="article:published_time" content="2019-10-24T16:57:55.000Z">
<meta property="article:modified_time" content="2024-08-20T16:43:04.031Z">
<meta property="article:tag" content="K8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zaf1ro.github.io/images/Kubernetes/vol-1.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />




    <title>
Volumes - Zaf1ro
</title>
  <meta name="generator" content="Hexo 6.3.0"></head>

  <body>
  <nav id="sidebar" class="active on-post">
    <div id="third">
      <div id="sidebar-title">
        <h1 id="sidebar-title-text">
            <a href="/." class="logo">Home</a>
        </h1>
      </div>
      <div id="google-search">
  <script async src="https://cse.google.com/cse.js?cx=009060789867951546370:v3hkcobeuh9"></script>
  <div class="gcse-search"></div>
</div>
      
  <div id="toc">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Introduction"><span class="toc-text">1. Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Use-Volumes-to-Share-Data-between-Containers"><span class="toc-text">2. Use Volumes to Share Data between Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-emptyDir-Volume"><span class="toc-text">2.1 emptyDir Volume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-gitRepo-Volume"><span class="toc-text">2.2 gitRepo Volume</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Access-Files-on-the-Worker-Node-s-Filesystem"><span class="toc-text">3. Access Files on the Worker Node&#39;s Filesystem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Persistent-Storage"><span class="toc-text">4. Persistent Storage</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-GCP-Persistent-Disk"><span class="toc-text">4.1 GCP Persistent Disk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-AWS-Persistent-Data"><span class="toc-text">4.2 AWS Persistent Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-NFS-Volume"><span class="toc-text">4.3 NFS Volume</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Decouple-Pods-from-the-Underlying-Storage-Technology"><span class="toc-text">5. Decouple Pods from the Underlying Storage Technology</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Claim-a-PersistentVolume"><span class="toc-text">5.1 Claim a PersistentVolume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Claim-a-PersistentVolumeClaim"><span class="toc-text">5.2 Claim a PersistentVolumeClaim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Use-a-PersistentVolumeClaim"><span class="toc-text">5.3 Use a PersistentVolumeClaim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Recycle-PersistentVolume"><span class="toc-text">5.4 Recycle PersistentVolume</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Dynamic-Provisioning-of-PersistentVolume"><span class="toc-text">6. Dynamic Provisioning of PersistentVolume</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Define-a-StorageClass"><span class="toc-text">6.1 Define a StorageClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Request-the-StorageClass-in-a-PersistentVolumeClaim"><span class="toc-text">6.2 Request the StorageClass in a PersistentVolumeClaim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Dynamic-provisioning-without-specifying-a-StorageClass"><span class="toc-text">6.3 Dynamic provisioning without specifying a StorageClass</span></a></li></ol></li></ol>
  </div>

    </div>
  </nav>

    <div id="page">
      <header id="masthead"><div class="site-header-inner">
  
  <button class="nav-mobile-button on-post" id="sidebarCollapse">
  
    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path d="M24 6h-24v-4h24v4zm0 4h-24v4h24v-4zm0 8h-24v4h24v-4z"/></svg>
  </button>
  
  


  <nav id="nav-top">
    
      
      <ul id="menu-top" class="nav-top-items on-post">
      
        
          <li class="menu-item">
            <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Zaf1ro">
              
              
                Github
              
            </a>
          </li>
        
      </ul>
    
  </nav>
</div>

      </header>
      <div id="content">
        
  <div class="primary">
    
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Volumes
        
      </h1>
      <time class="post-time">
          10/24/19
      </time>
    </header>

    <div class="post-content">
      <h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>Volume并不是Kubernetes的一种resource, 而是作为Pod specification中的一个组成部分. Volume无法用单独的YAML创建, 且只有volume被mount到特定的container上才可以被其访问.<br>例如: Pod中有三个container, 分别为:</p>
<ol>
<li>WebServer: 利用**&#x2F;var&#x2F;htdocs&#x2F;<strong>下的HTML文件生成网页, 将log放入</strong>&#x2F;var&#x2F;logs&#x2F;**中</li>
<li>ContentAgent: 生成HTML文件并保存到**&#x2F;var&#x2F;html&#x2F;**中</li>
<li>LogRotator: 处理**&#x2F;var&#x2F;logs&#x2F;**下的日志文件</li>
</ol>
<p>若不使用volume, 则每个container所拥有的filesystem各自独立, 如下:<br><img src="/images/Kubernetes/vol-1.png" alt="Three containers of the same pod without shared storage"></p>
<p>但当使用volume后, container可以通过volume互通filesystem, 如下:<br><img src="/images/Kubernetes/vol-2.png" alt="Three containers sharing two volumes mounted at various mount paths"></p>
<p>Kubernetes提供了多种volume类型, 以下是所有可用的volume类型:</p>
<ul>
<li>emptyDir: 生成一个空文件夹用于存放临时数据</li>
<li>hostPath: mount到Pod所处的worker node的filesystem上</li>
<li>gitRepo: 利用Git repository初始化volume</li>
<li>nfs: mount到一个NFS(Network File System)上</li>
<li>gcePersistentDisk, awsElasticBlockStore, azureDisk: mount到云服务提供商特定的存储服务</li>
<li>cinder, cephfs, iscsi, flocker, glusterfs, quobyte, rbd, flexVolume, vsphereVolume, photonPersistentDisk, scaleIO: mount到其他类型的网络存储服务</li>
<li>configMap, secret, downwardAPI: 特殊类型的volume, 用于提供Kubernetes和cluster所拥有的的信息</li>
<li>persistentVolumeClaim: 使用pre-provisioned或dynamically provisioned persistent stroage</li>
</ul>
<h2 id="2-Use-Volumes-to-Share-Data-between-Containers"><a href="#2-Use-Volumes-to-Share-Data-between-Containers" class="headerlink" title="2. Use Volumes to Share Data between Containers"></a>2. Use Volumes to Share Data between Containers</h2><h3 id="2-1-emptyDir-Volume"><a href="#2-1-emptyDir-Volume" class="headerlink" title="2.1 emptyDir Volume"></a>2.1 emptyDir Volume</h3><p>emptyDir是最简单的volume类型, container可通过emptyDir来共享文件. 但缺陷也很多: emptyDir生存周期与Pod相同, Pod被删除后emptyDir也会消失. 以下是emptyDir的例子, mountPath为container需要mount的文件目录:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/fortune</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">html-generator</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/htdocs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125; </span><br></pre></td></tr></table></figure>
<p>上述YAML文件创建了一个Pod, 共包含:</p>
<ul>
<li>两个container: html-generator用于创建HTML文件并保存到**&#x2F;var&#x2F;htdocs**, web-server用于从**&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html**目录中读取HTML文件并生成网页.</li>
<li>一个volume: 名为html, 用于连接html-generator的**&#x2F;var&#x2F;htdocs<strong>与web-server的</strong>&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html**</li>
</ul>
<p>emptyDir默认将数据保存在worker node的filesystem, Kubernetes让用户可以修改emptyDir的存储媒介:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">emptyDir:</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">Memory</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-gitRepo-Volume"><a href="#2-2-gitRepo-Volume" class="headerlink" title="2.2 gitRepo Volume"></a>2.2 gitRepo Volume</h3><p>gitRepo作为emptyDir的增强版, 会先创建一个空volume, 则从Git repository复制数据, 整个流程如下:<br><img src="/images/Kubernetes/vol-3.png" alt="A gitRepo volume is an emptyDir volume initially populated with the contents of a Git repository"></p>
<p>gitRepo volume被创建后, volume会断开与Git repository的同步. 即使远程Git repository被修改, volume中的数据也不会修改. 以下gitRepo volume的例子:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gitrepo-volume-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web-server</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">gitRepo:</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">https://github.com/luksa/kubia-website-example.git</span></span><br><span class="line">      <span class="attr">revision:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">directory:</span> <span class="string">.</span> </span><br></pre></td></tr></table></figure>
<p>上述YAML文件创建了一个Pod, 共包含:</p>
<ul>
<li>一个container: web-server用于从**&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html**中读取HTML文件并生成网页</li>
<li>一个volume: 名为html的gitRepo volume用于从Git repository复制数据</li>
</ul>
<p>虽然gitRepo volume不提供同步功能, 但Docker Hub上有很多container image来实现该功能. 这种container也被称为sidecar container, 虽然与web-server container处于同一Pod, 但却为辅助web-server运行而存在.<br>gitRepo还存在一个缺陷: 不支持从private Git repository中复制数据, 因为private Git repository需要SSH protocol和其他配置文件. 如果需要从private Gitrepository复制数据, 还需要其他sidebar container的帮助. 生存周期方面, gitRepo与emptyDir, 都无法实现数据持久化.</p>
<h2 id="3-Access-Files-on-the-Worker-Node-s-Filesystem"><a href="#3-Access-Files-on-the-Worker-Node-s-Filesystem" class="headerlink" title="3. Access Files on the Worker Node&#39;s Filesystem"></a>3. Access Files on the Worker Node&#39;s Filesystem</h2><p>大部分Pod游离在多个worker node中运行, 所以将Pod的数据不应保存在worker node的file system上. 但有些Pod(例如: DaemonSet)会绑定在worker node上, 因此可以将数据保存在worker node的file system. Kubernetes提供了hostPath volume将container的文件目录mount到worker node上的filesystem, 如下:<br><img src="/images/Kubernetes/vol-4.png" alt="A hostPath volume mounts a file or directory on the worker node into the container’s filesystem"></p>
<p>下面YAML文件创造了一个Pod, 其中test-container会将**&#x2F;test-pd** mount到worker node的**&#x2F;data<strong>文件夹. 添加修改或删除container中</strong>&#x2F;test-pd<strong>内文件都会同步到worker node上的</strong>&#x2F;data**, 反之同理.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">k8s.gcr.io/test-webserver</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pd</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure>
<p>hostPath相对于emptyDir和gitRepo提供了persistent storage. 当Pod被移除后数据不会消失, 只要Pod再次被部署到该worker node, 就可以恢复数据. 缺陷也很明显, Pod一旦被重新部署到其他worker node, 则数据全部丢失.</p>
<h2 id="4-Persistent-Storage"><a href="#4-Persistent-Storage" class="headerlink" title="4. Persistent Storage"></a>4. Persistent Storage</h2><p>若Pod需要persistent data, 但又随时会被重新分配到不同的worker node上, 则以上所有Volume都不可用. . 不同的cloud infrastructure platform提供了不同的NAS(network-attached sotrage)方法来解决该问题. 以下会在GCP(Google Cloud Platform)和AWS(Amazon Web Services)上分别部署mongoDB.</p>
<h3 id="4-1-GCP-Persistent-Disk"><a href="#4-1-GCP-Persistent-Disk" class="headerlink" title="4.1 GCP Persistent Disk"></a>4.1 GCP Persistent Disk</h3><p>GCP提供自家的persistent disk. NAS不属于某个namespace, 也不与cluster绑定, 只属于某个zone. cluster与NAS必须处于某个zone, 可运行gcloud命令来查看当前所有cluster所在的zone:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gcloud container clusters list</span><br><span class="line">NAME  ZONE           MASTER_VERSION MASTER_IP ...</span><br><span class="line">kubia europe-west1-b 1.2.5          104.155.84.137 ...</span><br></pre></td></tr></table></figure>
<p>从上述命令可知, kubia位于europe-west1-b:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ gcloud compute disks create --size=1GiB --zone=europe-west1-b mongodb</span><br><span class="line">NAME    ZONE           SIZE_GB TYPE        STATUS</span><br><span class="line">mongodb europe-west1-b 1       pd-standard READY</span><br></pre></td></tr></table></figure>
<p>上述命令在europe-west1-b zone创造了一个1Gb空间的NAS, 现在可创造Pod来使用该NAS:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">    <span class="attr">gcePersistentDisk:</span></span><br><span class="line">      <span class="attr">pdName:</span> <span class="string">mongodb</span></span><br><span class="line">      <span class="attr">fsType:</span> <span class="string">ext4</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>通过在volumes中标注gcePersistentDisk可将该Pod与GCP persistent disk绑定, 即使该Pod被移除或重新分配到其他worker node, 其数据也会被保留下来. 如下图:<br><img src="/images/Kubernetes/vol-5.png" alt="A pod with a single container running MongoDB, which mounts a volume referencing an external GCE Persistent Disk"></p>
<h3 id="4-2-AWS-Persistent-Data"><a href="#4-2-AWS-Persistent-Data" class="headerlink" title="4.2 AWS Persistent Data"></a>4.2 AWS Persistent Data</h3><p>AWS和Azure也提供了相同的NAS, 步骤与GCP的NAS相同: 在cluster所在的zone中创建volume, 再在Pod的YAML文件中使用该volume:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">aws ec2 create-volume --size 1 --availability-zone us-east-1a</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;AvailabilityZone&quot;</span>: <span class="string">&quot;us-east-1a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;Encrypted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;VolumeType&quot;</span>: <span class="string">&quot;gp2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;VolumeId&quot;</span>: <span class="string">&quot;vol-1234567890abcdef0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;State&quot;</span>: <span class="string">&quot;creating&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Iops&quot;</span>: 240,</span><br><span class="line">  <span class="string">&quot;SnapshotId&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;CreateTime&quot;</span>: <span class="string">&quot;YYYY-MM-DDTHH:MM:SS.000Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Size&quot;</span>: 80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">    <span class="attr">awsElasticBlockStore:</span></span><br><span class="line">    <span class="attr">volumeId:</span> <span class="string">vol-1234567890abcdef0</span></span><br><span class="line">      <span class="attr">fsType:</span> <span class="string">ext4</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-NFS-Volume"><a href="#4-3-NFS-Volume" class="headerlink" title="4.3 NFS Volume"></a>4.3 NFS Volume</h3><p>除了使用cloud infrastructure platform提供了NAS之外, 还可以自己搭建NFS server来提供NAS, 只需要标记NFS server的IP地址和暴露的路径即可:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">      <span class="attr">nfs:</span></span><br><span class="line">        <span class="attr">server:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/some/path</span> </span><br></pre></td></tr></table></figure>



<h2 id="5-Decouple-Pods-from-the-Underlying-Storage-Technology"><a href="#5-Decouple-Pods-from-the-Underlying-Storage-Technology" class="headerlink" title="5. Decouple Pods from the Underlying Storage Technology"></a>5. Decouple Pods from the Underlying Storage Technology</h2><p>上述Volume虽然解决了大部分persistent data问题, 但需要developer在部署应用到cloud的同时了解Kubernetes提供的底层volume知识. 但理想状态下, developer并不需要知道这些volume的配置与区别, 这些volume的配置应由cluster administrator来管理. Kubernetes为此提供PV(PersistentVolume)和PVC(PersistentVolumeClaim)来方便Volume的配置与管理.<br>简单来说, PV是对Kubernetes存储资源的一种抽象, 可手动或由Kubernetes自动创建; PVC则是需要存储资源的User(如Pod)对存储资源的请求声明. 这样存储资源被分割为两部分: cluster administrator使用PV预先分配存储资源; developer根据应用所需存储资源大小来决定使用哪个PVC, PVC会绑定最合适的PV从而获取存储资源, 如下图:<br><img src="/images/Kubernetes/vol-6.png" alt="PersistentVolumes are provisioned by cluster admins and consumed by pods through PersistentVolumeClaims"></p>
<h3 id="5-1-Claim-a-PersistentVolume"><a href="#5-1-Claim-a-PersistentVolume" class="headerlink" title="5.1 Claim a PersistentVolume"></a>5.1 Claim a PersistentVolume</h3><p>以GCP Persistent Disk为例, cluster administrator需要为developer提供PV:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-pv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadOnlyMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">gcePersistentDisk:</span></span><br><span class="line">    <span class="attr">pdName:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">fsType:</span> <span class="string">ext4</span> </span><br></pre></td></tr></table></figure>
<p>以上PV以GCP的Persistent Disk作为存储资源提供者, 每次绑定PV都会获得1Gb的存储资源, 将persistentVolumeReclaimPolicy设置为<strong>Retain</strong>可保证PV被解绑后也会保留数据. 可调用<strong>kubectl get pv</strong>来获取所有PV:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME       CAPACITY RECLAIMPOLICY ACCESSMODES STATUS    CLAIM</span><br><span class="line">mongodb-pv 1Gi      Retain        RWO,ROX     Available </span><br></pre></td></tr></table></figure>
<p>由于还未创建PVC, 所以mongodb-pv为<strong>Available</strong>而不是**<br>Bound**. PV不属于某个namespace, 只与cluster绑定; 但PVC有特定的namespace范围. </p>
<h3 id="5-2-Claim-a-PersistentVolumeClaim"><a href="#5-2-Claim-a-PersistentVolumeClaim" class="headerlink" title="5.2 Claim a PersistentVolumeClaim"></a>5.2 Claim a PersistentVolumeClaim</h3><p>以下PVC会去寻找存储空间至少为1Gb的PV并与其绑定, 其PV必须支持ReadWriteOnce的访问模式:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过以下命令可显示所有cluster的PVC:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME        STATUS VOLUME     CAPACITY ACCESSMODES AGE</span><br><span class="line">mongodb-pvc Bound  mongodb-pv 1Gi      RWO,ROX     3s</span><br></pre></td></tr></table></figure>
<p>Kubernetes为存储空间提供了三种访问模式:</p>
<ol>
<li>RWO(ReadWriteOnce): 只有一个node可读取或写入该存储资源</li>
<li>ROX(ReadOnlyMany): 可有多个node读取该存储资源</li>
<li>RWX(ReadWriteMany): 可有多个node读取或写入该存储资源</li>
</ol>
<p>PVC被创建后会自动寻找符合条件的PV, 以下是mongodb-pv的最新状态:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME       CAPACITY ACCESSMODES STATUS CLAIM               AGE</span><br><span class="line">mongodb-pv 1Gi      RWO,ROX     Bound  default/mongodb-pvc 1m</span><br></pre></td></tr></table></figure>

<h3 id="5-3-Use-a-PersistentVolumeClaim"><a href="#5-3-Use-a-PersistentVolumeClaim" class="headerlink" title="5.3 Use a PersistentVolumeClaim"></a>5.3 Use a PersistentVolumeClaim</h3><p>创建完毕PVC后就可以在Pod中使用PVC来获取存储资源:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data/db</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mongodb-data</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">    <span class="attr">claimName:</span> <span class="string">mongodb-pvc</span> </span><br></pre></td></tr></table></figure>
<p>整个使用的流程如下图:<br><img src="/images/Kubernetes/vol-7.png" alt="PV doesn’t belong to any namespace, unlike PVC"></p>
<h3 id="5-4-Recycle-PersistentVolume"><a href="#5-4-Recycle-PersistentVolume" class="headerlink" title="5.4 Recycle PersistentVolume"></a>5.4 Recycle PersistentVolume</h3><p>当PV所绑定的PVC和Pod被删除后, PV的状态会从<strong>Bound</strong>切换为<strong>Released</strong>, 而不是<strong>Available</strong>, 此时的PV不能被新的PVC所绑定. Kubernetes之所以不允许立刻绑定新的PVC, 是为了保证PV中的数据得到合适的处理(清理或再利用):</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl delete pod mongodb</span><br><span class="line">pod <span class="string">&quot;mongodb&quot;</span> deleted</span><br><span class="line">$ kubectl delete pvc mongodb-pvc</span><br><span class="line">persistentvolumeclaim <span class="string">&quot;mongodb-pvc&quot;</span> deleted</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME       CAPACITY ACCESSMODES STATUS   CLAIM               REASON AGE</span><br><span class="line">mongodb-pv 1Gi      RWO,ROX     Released default/mongodb-pvc        5m</span><br></pre></td></tr></table></figure>
<p>有两种回收PV的方式:</p>
<ol>
<li>手动回收: 将persistentVolumeReclaimPolicy设为Retain后, PV只能被删除后重新创建才能与新的PVC绑定</li>
<li>自动回收: 将persistentVolumeReclaimPolicy设为Recycle或Delete后, PV在与PVC解绑后会自动变为<strong>Available</strong>状态. Recycle表示PV保留原有数据; Delete表示PV所有数据会被删除.</li>
</ol>
<h2 id="6-Dynamic-Provisioning-of-PersistentVolume"><a href="#6-Dynamic-Provisioning-of-PersistentVolume" class="headerlink" title="6. Dynamic Provisioning of PersistentVolume"></a>6. Dynamic Provisioning of PersistentVolume</h2><p>PV和PVC让存储资源的获取步骤分离. developer只需创建PVC即可获取存储资源, 而不需了解存储资源的细节. 但cluster administrator面临一个难题: 随着cluster中Pod越来越多, 申请存储资源的PVC也越来越多时, 需要创建更多PV来满足请求, 这使得cluster administrator的工作量增大. Kubernetes为此提供了StorageClass来实现对PV的动态供给.<br>StorageClass会根据PVC的请求不断创建PV, 因此无需再创建任何PV. StorageClass与PV相同, 都不与namespace绑定, 只属于单个cluster. </p>
<h3 id="6-1-Define-a-StorageClass"><a href="#6-1-Define-a-StorageClass" class="headerlink" title="6.1 Define a StorageClass"></a>6.1 Define a StorageClass</h3><p>以GCP为例, 可创建StorageClass并使用GCP Persistent Disk作为底层存储资源自动为PVC创建相应PV:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fast</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">kubernetes.io/gce-pd</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">pd-ssd</span></span><br><span class="line">  <span class="attr">zone:</span> <span class="string">europe-west1-b</span> </span><br></pre></td></tr></table></figure>

<h3 id="6-2-Request-the-StorageClass-in-a-PersistentVolumeClaim"><a href="#6-2-Request-the-StorageClass-in-a-PersistentVolumeClaim" class="headerlink" title="6.2 Request the StorageClass in a PersistentVolumeClaim"></a>6.2 Request the StorageClass in a PersistentVolumeClaim</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mongodb-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">fast</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">100Mi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure>
<p>当运行kubectl get pvc时可看到PVC已自动绑定StorageClass且StorageClass为PVC创建了临时PV:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get pvc mongodb-pvc</span><br><span class="line">NAME        STATUS VOLUME       CAPACITY ACCESSMODES STORAGECLASS</span><br><span class="line">mongodb-pvc Bound  pvc-1e6bc048 1Gi      RWO         fast</span><br><span class="line"></span><br><span class="line">$ kubectl get pv</span><br><span class="line">NAME         CAPACITY ACCESSMODES RECLAIMPOLICY STATUS  STORAGECLASS</span><br><span class="line">pvc-1e6bc048 1Gi      RWO         Delete        Bound   fast</span><br></pre></td></tr></table></figure>

<h3 id="6-3-Dynamic-provisioning-without-specifying-a-StorageClass"><a href="#6-3-Dynamic-provisioning-without-specifying-a-StorageClass" class="headerlink" title="6.3 Dynamic provisioning without specifying a StorageClass"></a>6.3 Dynamic provisioning without specifying a StorageClass</h3><p>对于大多数cloud infrastructure platform来说, 其Kubernetes都自带provisioner. 通过调用<strong>kubectl get sc</strong>可获取所有的StorageClass:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get sc</span><br><span class="line">NAME               TYPE</span><br><span class="line">fast               kubernetes.io/gce-pd</span><br><span class="line">standard (default) kubernetes.io/gce-pd</span><br></pre></td></tr></table></figure>
<p>GCP提供一个默认StorageClass名为<strong>standard</strong>, 当PVC没有指定任何StorageClass时, 将会使用其作为StorageClass. </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ kubectl get sc standard -o yaml</span><br><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    storageclass.beta.kubernetes.io/is-default-class: <span class="string">&quot;true&quot;</span></span><br><span class="line">  creationTimestamp: 2017-05-16T15:24:11Z</span><br><span class="line">  labels:</span><br><span class="line">    addonmanager.kubernetes.io/mode: EnsureExists</span><br><span class="line">    kubernetes.io/cluster-service: <span class="string">&quot;true&quot;</span></span><br><span class="line">  name: standard</span><br><span class="line">  resourceVersion: <span class="string">&quot;180&quot;</span></span><br><span class="line">  selfLink: /apis/storage.k8s.io/v1/storageclassesstandard</span><br><span class="line">  uid: b6498511-3a4b-11e7-ba2c-42010a840014</span><br><span class="line">parameters:</span><br><span class="line">  <span class="built_in">type</span>: pd-standard</span><br><span class="line">provisioner: kubernetes.io/gce-pd </span><br></pre></td></tr></table></figure>
<p><strong>storageclass.beta.kubernetes.io&#x2F;is-default-class</strong>表示该StorageClass是否为默认选项. 若不想使用任何StorageClass, 则在PVC YAML文件中标注StorageClass为空:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>以下是整个Dynamically Provisoned PersistentVolume的使用步骤:<br><img src="/images/Kubernetes/vol-8.png" alt="The complete picture of dynamic provisioning of PersistentVolumes"></p>

    </div>

    <footer class="post-footer">
      
      <div class="post-tags">
        
          <a href="/tags/K8s/">K8s</a>
        
      </div>
      

      
      
  <nav class="post-nav">
    
      <a class="prev" href="/p/95.html">
        <i class="icon-left"></i>
        <span class="prev-text nav-default">ConfigMap and Secret</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/p/1936.html">
        <span class="next-text nav-default">Services</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="icon-right"></i>
      </a>
    
  </nav>

      
    </footer>
  </article>

  </div>
  
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    showProcessingMessages: true,
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: false,
        skipTags: ["script","noscript","style","textarea"]
    },
    TeX: {
        Macros:{
            Arr: ["\\{ #1 \\}", 1],
            fi: "{f\\,\\!_i}",
            SS: ["{#1\\:\\!_#2}",2],
            SUBx: ["{\\:\\!_#1}",1],
            EXPx: ["{\\;\\!^#1}",1],
            Ss: ["{#1\\,\\!_#2}",2],
            subx: ["{\\,\\!_#1}",1]
        }
    }
});
</script>


      </div>
    </div>

    
<script type="text/javascript">
  var disqus_shortname = 'zaf1ro';
  var disqus_identifier = 'p/f56f.html';
  var disqus_title = "Volumes";

  var disqus = {
    load : function disqus(){
        if(typeof DISQUS !== 'object') {
          (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
          }());
          $('#load-disqus').remove(); ///加载后移除按钮
        }
    }
  }

  
    var disqus_config = function () {
        this.page.url = disqus_url;
        this.page.identifier = disqus_identifier;
        this.page.title = disqus_title;
    };
  

</script>



    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.6.0.min.js"></script>
  

  

    
    <script type="text/javascript">
(function(){"use strict";var Theme={};Theme.backToTop={register:function(){var $backToTop=$('#back-to-top');$(window).scroll(function(){if($(window).scrollTop()>100){$backToTop.fadeIn(1000)}else{$backToTop.fadeOut(1000)}});$backToTop.click(function(){$('body').animate({scrollTop:0})})}};Theme.fancybox={register:function(){if($.fancybox){$('.post').each(function(){$(this).find('img').each(function(){$(this).wrap('<a class="fancybox" href="'+this.src+'" title="'+this.alt+'"></a>')})});$('.fancybox').fancybox({openEffect:'elastic',closeEffect:'elastic'})}}};this.Theme=Theme}.call(this));
</script>

<script type="text/javascript">
$(document).ready(function(){if(themeConfig.fancybox.enable){Theme.fancybox.register()}Theme.backToTop.register()});
</script>
    
<script type="text/javascript">
var themeConfig = {
  fancybox: {
    enable: false
  },
};
</script>

    <script>
    $('table').wrap('<div style="overflow-x: auto;"></div>');
</script>
    
    <script>
$(document).ready(function () {
    $('#sidebarCollapse').on('click', function(){
        $('#sidebar').toggleClass('active');
    });

    $('#toc ol li a').on('click', function(){
        $('#sidebar').toggleClass('active');
    });
});
</script>
  </body>
</html>
