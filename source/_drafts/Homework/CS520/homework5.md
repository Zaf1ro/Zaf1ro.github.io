---
title: CS520-homework5
category:
  - Homework
tag:
  - Homework
abbrlink: 3571645154
date: 2017-11-07 18:31:03
---

#### 1. Write a program that implements the Buddy System algorithm for memory management.
Please refer to program


#### 2. How large are the pages and how many are there in the address space?
offset=32-(11+9)=12bit
number of pages=2^12=4Kbit
bit for virtual page=20bit
number of pages=2^20 pages


#### 3. Produce the page reference string generated by this program
2020: LOAD @8118, R0    3,15
2024: MOVE R0, @SP      3,19
2028: SUBI SP, #4       3
2032: JSR @4120         3,8,19
2036: ADDI SP, #4       3
2040: CMP @SP, #7       3,19
2044: ADDI SP, #4       3
2048: JNZ @5000         4 or [4,9]


#### 4 
1. Explain the value and drawbacks of "non-traditional" hardware architectures for supporting virtual memory
Traditional hardware architecture has to consider lots of factors, like memory and consuming time. Usually hardware architecture has to reach a balance of several needs. But "non-traditional" hardware architecture has the ability to make up the shortcomings of traditional design. 
Such like `inverted page table`, traditional page table has to consider every process's conversion between physical memory address and virtual memory address. Alought it will waste lots of memory to record these conversions, it saves lookup time. For inverted page table, it only has one entry for each real page of memory, but waste more time to lookup. 

2. give the physical page frame number corresponding to virtual page numbers 0, 1, and 2 of Process 1
Because p=1, vpn=0, so offset=4
Because p=1, vpn=1, so offset=2
Because p=1, vpn=2, so offset=0


#### 5. Provide a proof, (1,2,3)^k(4,5,6)^l
1. MRU will result in 3(l+1) page faults
```text
1 -> page fault
2 -> page fault
3 -> page fault
if k>1: 1,2,3 will not cause page fault
4 -> page fault, replace 3
5 -> page fault, replace 4
6 -> page fault, replace 5
if l>1: 4,5,6 will cause page fault again
4 -> page fault, replace 6
5 -> page fault, replace 5
6 -> page fault, replace 4
so the number of page faults are 3(l+1) 
```
2. LFU will result in 3[min(k,l)+1] page faults
```text
1 -> page fault
2 -> page fault
3 -> page fault
if k>1: 1,2,3 will not cause page fault
4 -> page fault, replace 1
5 -> page fault, replace unknown
6 -> page fault, replace unknown
When insert 5, because we don't know number of l(l>1 or l==1), so we cannot know which page is replaced, it may be 4 or 2. It depends on k and l.
The number of page faults are 3[min(k,l)+1]
```

3. FIFO and LRU will result only in six page faults on a reference
FIFO:
```text
1 -> page fault
2 -> page fault
3 -> page fault
if k>1: 1,2,3 will not cause page fault
4 -> page fault
5 -> page fault
6 -> page fault
if l>1: 4,5,6 will not cause page fault
so the number of fault pages are 6
```
LRU:
```text
1 -> page fault - 1
2 -> page fault - 2 1
3 -> page fault - 3 2 1
if k>1:
1 -> 1 3 2
2 -> 2 1 3
3 -> 3 2 1
so 1,2,3 will not cause page fault
4 -> page fault, replace 1 - 4 3 2
5 -> page fault, replace 2 - 5 4 3
6 -> page fault, replace 3 - 6 5 4
if l>1:
4 -> 4 6 5
5 -> 5 4 6
6 -> 6 5 4
4,5,6 will not cause page fault
```
