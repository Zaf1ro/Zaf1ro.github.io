---
title: Memory Leak
category:
  - C++
tag:
  - C++
abbrlink: 1244741795
date: 2016-03-20 10:28:31
---

## 书籍记录:<高级C语言(语法经验)>
### C语言中各种可能导致内存错误的地方


#### 1. 未初始化的内存
```c
    char* p=malloc(10);
```
　　如果在对p赋值前,某个代码段试图访问它就能获得垃圾值,这会导致不可预测的行为
　　解决方案:
```c
    char* p=malloc(10);
    memset(p,'\0',10);	// memset的第二个值为无符号char, 第三个值为要填充的字节数
```
　　上述处理后对p的访问将能正确处理




#### 2. 内存覆盖
　　如果p指针已经被分配了`10字节`,如果某个代码块`向p写入了11个字节`,那么该操作会自动在p之后的一个字节填充上,假设q是p后面的内存指针
　　代码执行之前:
```c
char* q="character";
```
　　代码执行之后:
```c
char* q="&haracter";    // q的第一个字符被覆盖为&
```
　　即使代码编码良好,也可能由于一些共存模块导致内存操作错误
```c
char* name=(char*)malloc(11);
memcpy(p,name,11);	// 将11个字节写入给p,导致内存覆盖
```


#### 3. 内存读取越界
　　和内存覆盖相似,但并没有覆盖其他内存空间,而是`读取到了其他内存空间`
```
char* ptr=(char*)malloc(10);
char name[20];
memcpy(name,ptr,20);	// 这里尝试从ptr读取20字节空间,但ptr只有10字节,会导致读取越界
```


#### 4. 内存泄露
##### 4.1 重新赋值
```c
char* memoryArea=malloc(10);
char* newArea=malloc(10);
memoryArea=newArea;	// 这时memoryArea所指向的内存空间丢失,发生了内存泄露
```
　　解决方案:
　　在指针赋值前先`确保内存位置不会变为孤立的`
```
free(memoryArea);
```
　　假设memoryArea指向一个10字节的内存位置,该内存位置的第三个字节(newArea)又指向某个动态分配的10字节内存位置,那么不能直接free(memoryArea),这样会`导致newArea无效`,而原先newArea所指向的内存空间无法释放
　　解决方法:
```
free(memoryArea->newArea);
free(memoryArea);
```


##### 4.2 返回值的不正确处理
　　某些函数会返回对动态分配的内存的引用,调用该函数的函数必须正确处理被分配的内存
```c
    char* func(){
        return malloc(20);
    }
    
    void callingFunc(){
        func();	// 此时对func()的调用没有保存返回的地址,导致20字节的内存空间无法释放
    }
```


##### 4.3 归还所获得的
　　在开发项目时可能存在大量动态内存分配,这时会忘了跟踪所有指针,导致部分内存没有释放
　　始终要保持所有内存分配,并`在任何适当的时候释放它们`,可以开发某种机制来跟踪这些分配,比如在链表中保留一个计数器


##### 4.4 访问空指针
　　访问空指针会导致`Segmentation fault`错误(Linux),并导致程序中断
